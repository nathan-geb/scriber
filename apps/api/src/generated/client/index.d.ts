/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Organization
 *
 */
export type Organization =
  $Result.DefaultSelection<Prisma.$OrganizationPayload>;
/**
 * Model Membership
 *
 */
export type Membership = $Result.DefaultSelection<Prisma.$MembershipPayload>;
/**
 * Model MinutesTemplate
 *
 */
export type MinutesTemplate =
  $Result.DefaultSelection<Prisma.$MinutesTemplatePayload>;
/**
 * Model Plan
 *
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>;
/**
 * Model Subscription
 *
 */
export type Subscription =
  $Result.DefaultSelection<Prisma.$SubscriptionPayload>;
/**
 * Model WeeklyUsage
 *
 */
export type WeeklyUsage = $Result.DefaultSelection<Prisma.$WeeklyUsagePayload>;
/**
 * Model Meeting
 *
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>;
/**
 * Model KeyMoment
 *
 */
export type KeyMoment = $Result.DefaultSelection<Prisma.$KeyMomentPayload>;
/**
 * Model TranscriptSegment
 *
 */
export type TranscriptSegment =
  $Result.DefaultSelection<Prisma.$TranscriptSegmentPayload>;
/**
 * Model TranscriptCorrection
 *
 */
export type TranscriptCorrection =
  $Result.DefaultSelection<Prisma.$TranscriptCorrectionPayload>;
/**
 * Model SegmentEdit
 *
 */
export type SegmentEdit = $Result.DefaultSelection<Prisma.$SegmentEditPayload>;
/**
 * Model Speaker
 *
 */
export type Speaker = $Result.DefaultSelection<Prisma.$SpeakerPayload>;
/**
 * Model Minutes
 *
 */
export type Minutes = $Result.DefaultSelection<Prisma.$MinutesPayload>;
/**
 * Model MinutesVersion
 *
 */
export type MinutesVersion =
  $Result.DefaultSelection<Prisma.$MinutesVersionPayload>;
/**
 * Model NotificationPreference
 *
 */
export type NotificationPreference =
  $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>;
/**
 * Model Tag
 *
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>;
/**
 * Model MeetingTag
 *
 */
export type MeetingTag = $Result.DefaultSelection<Prisma.$MeetingTagPayload>;
/**
 * Model Notification
 *
 */
export type Notification =
  $Result.DefaultSelection<Prisma.$NotificationPayload>;
/**
 * Model ShareLink
 *
 */
export type ShareLink = $Result.DefaultSelection<Prisma.$ShareLinkPayload>;
/**
 * Model CalendarConnection
 *
 */
export type CalendarConnection =
  $Result.DefaultSelection<Prisma.$CalendarConnectionPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const CalendarProvider: {
    GOOGLE: 'GOOGLE';
    OUTLOOK: 'OUTLOOK';
  };

  export type CalendarProvider =
    (typeof CalendarProvider)[keyof typeof CalendarProvider];

  export const ConnectionStatus: {
    ACTIVE: 'ACTIVE';
    EXPIRED: 'EXPIRED';
    REVOKED: 'REVOKED';
  };

  export type ConnectionStatus =
    (typeof ConnectionStatus)[keyof typeof ConnectionStatus];

  export const MomentType: {
    DECISION: 'DECISION';
    ACTION_ITEM: 'ACTION_ITEM';
    QUESTION: 'QUESTION';
    KEY_POINT: 'KEY_POINT';
    DISAGREEMENT: 'DISAGREEMENT';
    CUSTOM: 'CUSTOM';
  };

  export type MomentType = (typeof MomentType)[keyof typeof MomentType];

  export const Role: {
    USER: 'USER';
    ADMIN: 'ADMIN';
    SYSTEM: 'SYSTEM';
  };

  export type Role = (typeof Role)[keyof typeof Role];

  export const MemberRole: {
    OWNER: 'OWNER';
    ADMIN: 'ADMIN';
    MEMBER: 'MEMBER';
    VIEWER: 'VIEWER';
    GUEST: 'GUEST';
  };

  export type MemberRole = (typeof MemberRole)[keyof typeof MemberRole];

  export const MeetingStatus: {
    UPLOADING: 'UPLOADING';
    UPLOADED: 'UPLOADED';
    PROCESSING_TRANSCRIPT: 'PROCESSING_TRANSCRIPT';
    TRANSCRIPT_READY: 'TRANSCRIPT_READY';
    ENHANCING: 'ENHANCING';
    REDACTING: 'REDACTING';
    PROCESSING_MINUTES: 'PROCESSING_MINUTES';
    COMPLETED: 'COMPLETED';
    FAILED: 'FAILED';
    CANCELLED: 'CANCELLED';
  };

  export type MeetingStatus =
    (typeof MeetingStatus)[keyof typeof MeetingStatus];

  export const NotificationType: {
    TRANSCRIPTION_COMPLETE: 'TRANSCRIPTION_COMPLETE';
    MINUTES_COMPLETE: 'MINUTES_COMPLETE';
    TRANSCRIPTION_FAILED: 'TRANSCRIPTION_FAILED';
    MINUTES_FAILED: 'MINUTES_FAILED';
    SYSTEM: 'SYSTEM';
  };

  export type NotificationType =
    (typeof NotificationType)[keyof typeof NotificationType];

  export const ShareType: {
    FULL: 'FULL';
    MINUTES: 'MINUTES';
    TRANSCRIPT: 'TRANSCRIPT';
  };

  export type ShareType = (typeof ShareType)[keyof typeof ShareType];

  export const MinutesStatus: {
    DRAFT: 'DRAFT';
    UNDER_REVIEW: 'UNDER_REVIEW';
    APPROVED: 'APPROVED';
  };

  export type MinutesStatus =
    (typeof MinutesStatus)[keyof typeof MinutesStatus];
}

export type CalendarProvider = $Enums.CalendarProvider;

export const CalendarProvider: typeof $Enums.CalendarProvider;

export type ConnectionStatus = $Enums.ConnectionStatus;

export const ConnectionStatus: typeof $Enums.ConnectionStatus;

export type MomentType = $Enums.MomentType;

export const MomentType: typeof $Enums.MomentType;

export type Role = $Enums.Role;

export const Role: typeof $Enums.Role;

export type MemberRole = $Enums.MemberRole;

export const MemberRole: typeof $Enums.MemberRole;

export type MeetingStatus = $Enums.MeetingStatus;

export const MeetingStatus: typeof $Enums.MeetingStatus;

export type NotificationType = $Enums.NotificationType;

export const NotificationType: typeof $Enums.NotificationType;

export type ShareType = $Enums.ShareType;

export const ShareType: typeof $Enums.ShareType;

export type MinutesStatus = $Enums.MinutesStatus;

export const MinutesStatus: typeof $Enums.MinutesStatus;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **Membership** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Memberships
   * const memberships = await prisma.membership.findMany()
   * ```
   */
  get membership(): Prisma.MembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.minutesTemplate`: Exposes CRUD operations for the **MinutesTemplate** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more MinutesTemplates
   * const minutesTemplates = await prisma.minutesTemplate.findMany()
   * ```
   */
  get minutesTemplate(): Prisma.MinutesTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Plans
   * const plans = await prisma.plan.findMany()
   * ```
   */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Subscriptions
   * const subscriptions = await prisma.subscription.findMany()
   * ```
   */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weeklyUsage`: Exposes CRUD operations for the **WeeklyUsage** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more WeeklyUsages
   * const weeklyUsages = await prisma.weeklyUsage.findMany()
   * ```
   */
  get weeklyUsage(): Prisma.WeeklyUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Meetings
   * const meetings = await prisma.meeting.findMany()
   * ```
   */
  get meeting(): Prisma.MeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyMoment`: Exposes CRUD operations for the **KeyMoment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more KeyMoments
   * const keyMoments = await prisma.keyMoment.findMany()
   * ```
   */
  get keyMoment(): Prisma.KeyMomentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcriptSegment`: Exposes CRUD operations for the **TranscriptSegment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TranscriptSegments
   * const transcriptSegments = await prisma.transcriptSegment.findMany()
   * ```
   */
  get transcriptSegment(): Prisma.TranscriptSegmentDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.transcriptCorrection`: Exposes CRUD operations for the **TranscriptCorrection** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TranscriptCorrections
   * const transcriptCorrections = await prisma.transcriptCorrection.findMany()
   * ```
   */
  get transcriptCorrection(): Prisma.TranscriptCorrectionDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.segmentEdit`: Exposes CRUD operations for the **SegmentEdit** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SegmentEdits
   * const segmentEdits = await prisma.segmentEdit.findMany()
   * ```
   */
  get segmentEdit(): Prisma.SegmentEditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speaker`: Exposes CRUD operations for the **Speaker** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Speakers
   * const speakers = await prisma.speaker.findMany()
   * ```
   */
  get speaker(): Prisma.SpeakerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.minutes`: Exposes CRUD operations for the **Minutes** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Minutes
   * const minutes = await prisma.minutes.findMany()
   * ```
   */
  get minutes(): Prisma.MinutesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.minutesVersion`: Exposes CRUD operations for the **MinutesVersion** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more MinutesVersions
   * const minutesVersions = await prisma.minutesVersion.findMany()
   * ```
   */
  get minutesVersion(): Prisma.MinutesVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationPreferences
   * const notificationPreferences = await prisma.notificationPreference.findMany()
   * ```
   */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tags
   * const tags = await prisma.tag.findMany()
   * ```
   */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meetingTag`: Exposes CRUD operations for the **MeetingTag** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more MeetingTags
   * const meetingTags = await prisma.meetingTag.findMany()
   * ```
   */
  get meetingTag(): Prisma.MeetingTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shareLink`: Exposes CRUD operations for the **ShareLink** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ShareLinks
   * const shareLinks = await prisma.shareLink.findMany()
   * ```
   */
  get shareLink(): Prisma.ShareLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarConnection`: Exposes CRUD operations for the **CalendarConnection** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CalendarConnections
   * const calendarConnections = await prisma.calendarConnection.findMany()
   * ```
   */
  get calendarConnection(): Prisma.CalendarConnectionDelegate<
    ExtArgs,
    ClientOptions
  >;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: 'User';
    Organization: 'Organization';
    Membership: 'Membership';
    MinutesTemplate: 'MinutesTemplate';
    Plan: 'Plan';
    Subscription: 'Subscription';
    WeeklyUsage: 'WeeklyUsage';
    Meeting: 'Meeting';
    KeyMoment: 'KeyMoment';
    TranscriptSegment: 'TranscriptSegment';
    TranscriptCorrection: 'TranscriptCorrection';
    SegmentEdit: 'SegmentEdit';
    Speaker: 'Speaker';
    Minutes: 'Minutes';
    MinutesVersion: 'MinutesVersion';
    NotificationPreference: 'NotificationPreference';
    Tag: 'Tag';
    MeetingTag: 'MeetingTag';
    Notification: 'Notification';
    ShareLink: 'ShareLink';
    CalendarConnection: 'CalendarConnection';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<
    { extArgs: $Extensions.InternalArgs },
    $Utils.Record<string, any>
  > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'user'
        | 'organization'
        | 'membership'
        | 'minutesTemplate'
        | 'plan'
        | 'subscription'
        | 'weeklyUsage'
        | 'meeting'
        | 'keyMoment'
        | 'transcriptSegment'
        | 'transcriptCorrection'
        | 'segmentEdit'
        | 'speaker'
        | 'minutes'
        | 'minutesVersion'
        | 'notificationPreference'
        | 'tag'
        | 'meetingTag'
        | 'notification'
        | 'shareLink'
        | 'calendarConnection';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>;
        fields: Prisma.OrganizationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrganization>;
          };
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrganizationGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<OrganizationCountAggregateOutputType>
              | number;
          };
        };
      };
      Membership: {
        payload: Prisma.$MembershipPayload<ExtArgs>;
        fields: Prisma.MembershipFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MembershipFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MembershipFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          findFirst: {
            args: Prisma.MembershipFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MembershipFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          findMany: {
            args: Prisma.MembershipFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[];
          };
          create: {
            args: Prisma.MembershipCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          createMany: {
            args: Prisma.MembershipCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MembershipCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[];
          };
          delete: {
            args: Prisma.MembershipDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          update: {
            args: Prisma.MembershipUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          deleteMany: {
            args: Prisma.MembershipDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MembershipUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MembershipUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[];
          };
          upsert: {
            args: Prisma.MembershipUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          aggregate: {
            args: Prisma.MembershipAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMembership>;
          };
          groupBy: {
            args: Prisma.MembershipGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MembershipGroupByOutputType>[];
          };
          count: {
            args: Prisma.MembershipCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<MembershipCountAggregateOutputType>
              | number;
          };
        };
      };
      MinutesTemplate: {
        payload: Prisma.$MinutesTemplatePayload<ExtArgs>;
        fields: Prisma.MinutesTemplateFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MinutesTemplateFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MinutesTemplateFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload>;
          };
          findFirst: {
            args: Prisma.MinutesTemplateFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MinutesTemplateFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload>;
          };
          findMany: {
            args: Prisma.MinutesTemplateFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload>[];
          };
          create: {
            args: Prisma.MinutesTemplateCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload>;
          };
          createMany: {
            args: Prisma.MinutesTemplateCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MinutesTemplateCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload>[];
          };
          delete: {
            args: Prisma.MinutesTemplateDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload>;
          };
          update: {
            args: Prisma.MinutesTemplateUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload>;
          };
          deleteMany: {
            args: Prisma.MinutesTemplateDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MinutesTemplateUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MinutesTemplateUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload>[];
          };
          upsert: {
            args: Prisma.MinutesTemplateUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesTemplatePayload>;
          };
          aggregate: {
            args: Prisma.MinutesTemplateAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMinutesTemplate>;
          };
          groupBy: {
            args: Prisma.MinutesTemplateGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MinutesTemplateGroupByOutputType>[];
          };
          count: {
            args: Prisma.MinutesTemplateCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<MinutesTemplateCountAggregateOutputType>
              | number;
          };
        };
      };
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>;
        fields: Prisma.PlanFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>;
          };
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>;
          };
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[];
          };
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>;
          };
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[];
          };
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>;
          };
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>;
          };
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[];
          };
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>;
          };
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePlan>;
          };
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PlanGroupByOutputType>[];
          };
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>;
            result: $Utils.Optional<PlanCountAggregateOutputType> | number;
          };
        };
      };
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>;
        fields: Prisma.SubscriptionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[];
          };
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[];
          };
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[];
          };
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubscription>;
          };
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubscriptionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<SubscriptionCountAggregateOutputType>
              | number;
          };
        };
      };
      WeeklyUsage: {
        payload: Prisma.$WeeklyUsagePayload<ExtArgs>;
        fields: Prisma.WeeklyUsageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WeeklyUsageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WeeklyUsageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload>;
          };
          findFirst: {
            args: Prisma.WeeklyUsageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WeeklyUsageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload>;
          };
          findMany: {
            args: Prisma.WeeklyUsageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload>[];
          };
          create: {
            args: Prisma.WeeklyUsageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload>;
          };
          createMany: {
            args: Prisma.WeeklyUsageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WeeklyUsageCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload>[];
          };
          delete: {
            args: Prisma.WeeklyUsageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload>;
          };
          update: {
            args: Prisma.WeeklyUsageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload>;
          };
          deleteMany: {
            args: Prisma.WeeklyUsageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WeeklyUsageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WeeklyUsageUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload>[];
          };
          upsert: {
            args: Prisma.WeeklyUsageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WeeklyUsagePayload>;
          };
          aggregate: {
            args: Prisma.WeeklyUsageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWeeklyUsage>;
          };
          groupBy: {
            args: Prisma.WeeklyUsageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WeeklyUsageGroupByOutputType>[];
          };
          count: {
            args: Prisma.WeeklyUsageCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<WeeklyUsageCountAggregateOutputType>
              | number;
          };
        };
      };
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>;
        fields: Prisma.MeetingFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>;
          };
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>;
          };
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[];
          };
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>;
          };
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MeetingCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[];
          };
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>;
          };
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>;
          };
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MeetingUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[];
          };
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>;
          };
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMeeting>;
          };
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MeetingGroupByOutputType>[];
          };
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>;
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number;
          };
        };
      };
      KeyMoment: {
        payload: Prisma.$KeyMomentPayload<ExtArgs>;
        fields: Prisma.KeyMomentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.KeyMomentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.KeyMomentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload>;
          };
          findFirst: {
            args: Prisma.KeyMomentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.KeyMomentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload>;
          };
          findMany: {
            args: Prisma.KeyMomentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload>[];
          };
          create: {
            args: Prisma.KeyMomentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload>;
          };
          createMany: {
            args: Prisma.KeyMomentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.KeyMomentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload>[];
          };
          delete: {
            args: Prisma.KeyMomentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload>;
          };
          update: {
            args: Prisma.KeyMomentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload>;
          };
          deleteMany: {
            args: Prisma.KeyMomentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.KeyMomentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.KeyMomentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload>[];
          };
          upsert: {
            args: Prisma.KeyMomentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$KeyMomentPayload>;
          };
          aggregate: {
            args: Prisma.KeyMomentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateKeyMoment>;
          };
          groupBy: {
            args: Prisma.KeyMomentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<KeyMomentGroupByOutputType>[];
          };
          count: {
            args: Prisma.KeyMomentCountArgs<ExtArgs>;
            result: $Utils.Optional<KeyMomentCountAggregateOutputType> | number;
          };
        };
      };
      TranscriptSegment: {
        payload: Prisma.$TranscriptSegmentPayload<ExtArgs>;
        fields: Prisma.TranscriptSegmentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TranscriptSegmentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TranscriptSegmentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>;
          };
          findFirst: {
            args: Prisma.TranscriptSegmentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TranscriptSegmentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>;
          };
          findMany: {
            args: Prisma.TranscriptSegmentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>[];
          };
          create: {
            args: Prisma.TranscriptSegmentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>;
          };
          createMany: {
            args: Prisma.TranscriptSegmentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TranscriptSegmentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>[];
          };
          delete: {
            args: Prisma.TranscriptSegmentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>;
          };
          update: {
            args: Prisma.TranscriptSegmentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>;
          };
          deleteMany: {
            args: Prisma.TranscriptSegmentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TranscriptSegmentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TranscriptSegmentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>[];
          };
          upsert: {
            args: Prisma.TranscriptSegmentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>;
          };
          aggregate: {
            args: Prisma.TranscriptSegmentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTranscriptSegment>;
          };
          groupBy: {
            args: Prisma.TranscriptSegmentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TranscriptSegmentGroupByOutputType>[];
          };
          count: {
            args: Prisma.TranscriptSegmentCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<TranscriptSegmentCountAggregateOutputType>
              | number;
          };
        };
      };
      TranscriptCorrection: {
        payload: Prisma.$TranscriptCorrectionPayload<ExtArgs>;
        fields: Prisma.TranscriptCorrectionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TranscriptCorrectionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TranscriptCorrectionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload>;
          };
          findFirst: {
            args: Prisma.TranscriptCorrectionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TranscriptCorrectionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload>;
          };
          findMany: {
            args: Prisma.TranscriptCorrectionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload>[];
          };
          create: {
            args: Prisma.TranscriptCorrectionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload>;
          };
          createMany: {
            args: Prisma.TranscriptCorrectionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TranscriptCorrectionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload>[];
          };
          delete: {
            args: Prisma.TranscriptCorrectionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload>;
          };
          update: {
            args: Prisma.TranscriptCorrectionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload>;
          };
          deleteMany: {
            args: Prisma.TranscriptCorrectionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TranscriptCorrectionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TranscriptCorrectionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload>[];
          };
          upsert: {
            args: Prisma.TranscriptCorrectionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TranscriptCorrectionPayload>;
          };
          aggregate: {
            args: Prisma.TranscriptCorrectionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTranscriptCorrection>;
          };
          groupBy: {
            args: Prisma.TranscriptCorrectionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TranscriptCorrectionGroupByOutputType>[];
          };
          count: {
            args: Prisma.TranscriptCorrectionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<TranscriptCorrectionCountAggregateOutputType>
              | number;
          };
        };
      };
      SegmentEdit: {
        payload: Prisma.$SegmentEditPayload<ExtArgs>;
        fields: Prisma.SegmentEditFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SegmentEditFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SegmentEditFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload>;
          };
          findFirst: {
            args: Prisma.SegmentEditFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SegmentEditFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload>;
          };
          findMany: {
            args: Prisma.SegmentEditFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload>[];
          };
          create: {
            args: Prisma.SegmentEditCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload>;
          };
          createMany: {
            args: Prisma.SegmentEditCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SegmentEditCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload>[];
          };
          delete: {
            args: Prisma.SegmentEditDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload>;
          };
          update: {
            args: Prisma.SegmentEditUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload>;
          };
          deleteMany: {
            args: Prisma.SegmentEditDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SegmentEditUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SegmentEditUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload>[];
          };
          upsert: {
            args: Prisma.SegmentEditUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SegmentEditPayload>;
          };
          aggregate: {
            args: Prisma.SegmentEditAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSegmentEdit>;
          };
          groupBy: {
            args: Prisma.SegmentEditGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SegmentEditGroupByOutputType>[];
          };
          count: {
            args: Prisma.SegmentEditCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<SegmentEditCountAggregateOutputType>
              | number;
          };
        };
      };
      Speaker: {
        payload: Prisma.$SpeakerPayload<ExtArgs>;
        fields: Prisma.SpeakerFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SpeakerFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SpeakerFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>;
          };
          findFirst: {
            args: Prisma.SpeakerFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SpeakerFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>;
          };
          findMany: {
            args: Prisma.SpeakerFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>[];
          };
          create: {
            args: Prisma.SpeakerCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>;
          };
          createMany: {
            args: Prisma.SpeakerCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SpeakerCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>[];
          };
          delete: {
            args: Prisma.SpeakerDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>;
          };
          update: {
            args: Prisma.SpeakerUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>;
          };
          deleteMany: {
            args: Prisma.SpeakerDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SpeakerUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SpeakerUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>[];
          };
          upsert: {
            args: Prisma.SpeakerUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>;
          };
          aggregate: {
            args: Prisma.SpeakerAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSpeaker>;
          };
          groupBy: {
            args: Prisma.SpeakerGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SpeakerGroupByOutputType>[];
          };
          count: {
            args: Prisma.SpeakerCountArgs<ExtArgs>;
            result: $Utils.Optional<SpeakerCountAggregateOutputType> | number;
          };
        };
      };
      Minutes: {
        payload: Prisma.$MinutesPayload<ExtArgs>;
        fields: Prisma.MinutesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MinutesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MinutesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload>;
          };
          findFirst: {
            args: Prisma.MinutesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MinutesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload>;
          };
          findMany: {
            args: Prisma.MinutesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload>[];
          };
          create: {
            args: Prisma.MinutesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload>;
          };
          createMany: {
            args: Prisma.MinutesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MinutesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload>[];
          };
          delete: {
            args: Prisma.MinutesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload>;
          };
          update: {
            args: Prisma.MinutesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload>;
          };
          deleteMany: {
            args: Prisma.MinutesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MinutesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MinutesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload>[];
          };
          upsert: {
            args: Prisma.MinutesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesPayload>;
          };
          aggregate: {
            args: Prisma.MinutesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMinutes>;
          };
          groupBy: {
            args: Prisma.MinutesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MinutesGroupByOutputType>[];
          };
          count: {
            args: Prisma.MinutesCountArgs<ExtArgs>;
            result: $Utils.Optional<MinutesCountAggregateOutputType> | number;
          };
        };
      };
      MinutesVersion: {
        payload: Prisma.$MinutesVersionPayload<ExtArgs>;
        fields: Prisma.MinutesVersionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MinutesVersionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MinutesVersionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload>;
          };
          findFirst: {
            args: Prisma.MinutesVersionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MinutesVersionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload>;
          };
          findMany: {
            args: Prisma.MinutesVersionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload>[];
          };
          create: {
            args: Prisma.MinutesVersionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload>;
          };
          createMany: {
            args: Prisma.MinutesVersionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MinutesVersionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload>[];
          };
          delete: {
            args: Prisma.MinutesVersionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload>;
          };
          update: {
            args: Prisma.MinutesVersionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload>;
          };
          deleteMany: {
            args: Prisma.MinutesVersionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MinutesVersionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MinutesVersionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload>[];
          };
          upsert: {
            args: Prisma.MinutesVersionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MinutesVersionPayload>;
          };
          aggregate: {
            args: Prisma.MinutesVersionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMinutesVersion>;
          };
          groupBy: {
            args: Prisma.MinutesVersionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MinutesVersionGroupByOutputType>[];
          };
          count: {
            args: Prisma.MinutesVersionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<MinutesVersionCountAggregateOutputType>
              | number;
          };
        };
      };
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>;
        fields: Prisma.NotificationPreferenceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[];
          };
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[];
          };
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[];
          };
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationPreference>;
          };
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<NotificationPreferenceCountAggregateOutputType>
              | number;
          };
        };
      };
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>;
        fields: Prisma.TagFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[];
          };
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[];
          };
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[];
          };
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTag>;
          };
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TagGroupByOutputType>[];
          };
          count: {
            args: Prisma.TagCountArgs<ExtArgs>;
            result: $Utils.Optional<TagCountAggregateOutputType> | number;
          };
        };
      };
      MeetingTag: {
        payload: Prisma.$MeetingTagPayload<ExtArgs>;
        fields: Prisma.MeetingTagFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MeetingTagFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MeetingTagFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload>;
          };
          findFirst: {
            args: Prisma.MeetingTagFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MeetingTagFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload>;
          };
          findMany: {
            args: Prisma.MeetingTagFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload>[];
          };
          create: {
            args: Prisma.MeetingTagCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload>;
          };
          createMany: {
            args: Prisma.MeetingTagCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MeetingTagCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload>[];
          };
          delete: {
            args: Prisma.MeetingTagDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload>;
          };
          update: {
            args: Prisma.MeetingTagUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload>;
          };
          deleteMany: {
            args: Prisma.MeetingTagDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MeetingTagUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MeetingTagUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload>[];
          };
          upsert: {
            args: Prisma.MeetingTagUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MeetingTagPayload>;
          };
          aggregate: {
            args: Prisma.MeetingTagAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMeetingTag>;
          };
          groupBy: {
            args: Prisma.MeetingTagGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MeetingTagGroupByOutputType>[];
          };
          count: {
            args: Prisma.MeetingTagCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<MeetingTagCountAggregateOutputType>
              | number;
          };
        };
      };
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>;
        fields: Prisma.NotificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotification>;
          };
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<NotificationCountAggregateOutputType>
              | number;
          };
        };
      };
      ShareLink: {
        payload: Prisma.$ShareLinkPayload<ExtArgs>;
        fields: Prisma.ShareLinkFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ShareLinkFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ShareLinkFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>;
          };
          findFirst: {
            args: Prisma.ShareLinkFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ShareLinkFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>;
          };
          findMany: {
            args: Prisma.ShareLinkFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[];
          };
          create: {
            args: Prisma.ShareLinkCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>;
          };
          createMany: {
            args: Prisma.ShareLinkCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ShareLinkCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[];
          };
          delete: {
            args: Prisma.ShareLinkDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>;
          };
          update: {
            args: Prisma.ShareLinkUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>;
          };
          deleteMany: {
            args: Prisma.ShareLinkDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ShareLinkUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ShareLinkUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[];
          };
          upsert: {
            args: Prisma.ShareLinkUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>;
          };
          aggregate: {
            args: Prisma.ShareLinkAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateShareLink>;
          };
          groupBy: {
            args: Prisma.ShareLinkGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ShareLinkGroupByOutputType>[];
          };
          count: {
            args: Prisma.ShareLinkCountArgs<ExtArgs>;
            result: $Utils.Optional<ShareLinkCountAggregateOutputType> | number;
          };
        };
      };
      CalendarConnection: {
        payload: Prisma.$CalendarConnectionPayload<ExtArgs>;
        fields: Prisma.CalendarConnectionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CalendarConnectionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CalendarConnectionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload>;
          };
          findFirst: {
            args: Prisma.CalendarConnectionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CalendarConnectionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload>;
          };
          findMany: {
            args: Prisma.CalendarConnectionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload>[];
          };
          create: {
            args: Prisma.CalendarConnectionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload>;
          };
          createMany: {
            args: Prisma.CalendarConnectionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CalendarConnectionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload>[];
          };
          delete: {
            args: Prisma.CalendarConnectionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload>;
          };
          update: {
            args: Prisma.CalendarConnectionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload>;
          };
          deleteMany: {
            args: Prisma.CalendarConnectionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CalendarConnectionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CalendarConnectionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload>[];
          };
          upsert: {
            args: Prisma.CalendarConnectionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CalendarConnectionPayload>;
          };
          aggregate: {
            args: Prisma.CalendarConnectionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCalendarConnection>;
          };
          groupBy: {
            args: Prisma.CalendarConnectionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CalendarConnectionGroupByOutputType>[];
          };
          count: {
            args: Prisma.CalendarConnectionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CalendarConnectionCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    organization?: OrganizationOmit;
    membership?: MembershipOmit;
    minutesTemplate?: MinutesTemplateOmit;
    plan?: PlanOmit;
    subscription?: SubscriptionOmit;
    weeklyUsage?: WeeklyUsageOmit;
    meeting?: MeetingOmit;
    keyMoment?: KeyMomentOmit;
    transcriptSegment?: TranscriptSegmentOmit;
    transcriptCorrection?: TranscriptCorrectionOmit;
    segmentEdit?: SegmentEditOmit;
    speaker?: SpeakerOmit;
    minutes?: MinutesOmit;
    minutesVersion?: MinutesVersionOmit;
    notificationPreference?: NotificationPreferenceOmit;
    tag?: TagOmit;
    meetingTag?: MeetingTagOmit;
    notification?: NotificationOmit;
    shareLink?: ShareLinkOmit;
    calendarConnection?: CalendarConnectionOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    meetings: number;
    templates: number;
    notifications: number;
    tags: number;
    memberships: number;
    reviewedMinutes: number;
    calendarConnections: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meetings?: boolean | UserCountOutputTypeCountMeetingsArgs;
    templates?: boolean | UserCountOutputTypeCountTemplatesArgs;
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs;
    tags?: boolean | UserCountOutputTypeCountTagsArgs;
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs;
    reviewedMinutes?: boolean | UserCountOutputTypeCountReviewedMinutesArgs;
    calendarConnections?:
      | boolean
      | UserCountOutputTypeCountCalendarConnectionsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMeetingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MeetingWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTemplatesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MinutesTemplateWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TagWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MembershipWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedMinutesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MinutesWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCalendarConnectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CalendarConnectionWhereInput;
  };

  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    members: number;
    meetings: number;
    templates: number;
    tags: number;
  };

  export type OrganizationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs;
    meetings?: boolean | OrganizationCountOutputTypeCountMeetingsArgs;
    templates?: boolean | OrganizationCountOutputTypeCountTemplatesArgs;
    tags?: boolean | OrganizationCountOutputTypeCountTagsArgs;
  };

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MembershipWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMeetingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MeetingWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTemplatesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MinutesTemplateWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TagWhereInput;
  };

  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    subscriptions: number;
  };

  export type PlanCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subscriptions?: boolean | PlanCountOutputTypeCountSubscriptionsArgs;
  };

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubscriptionWhereInput;
  };

  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    usage: number;
  };

  export type SubscriptionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usage?: boolean | SubscriptionCountOutputTypeCountUsageArgs;
  };

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountUsageArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WeeklyUsageWhereInput;
  };

  /**
   * Count Type MeetingCountOutputType
   */

  export type MeetingCountOutputType = {
    keyMoments: number;
    tags: number;
    shareLinks: number;
    speakers: number;
    transcript: number;
  };

  export type MeetingCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    keyMoments?: boolean | MeetingCountOutputTypeCountKeyMomentsArgs;
    tags?: boolean | MeetingCountOutputTypeCountTagsArgs;
    shareLinks?: boolean | MeetingCountOutputTypeCountShareLinksArgs;
    speakers?: boolean | MeetingCountOutputTypeCountSpeakersArgs;
    transcript?: boolean | MeetingCountOutputTypeCountTranscriptArgs;
  };

  // Custom InputTypes
  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingCountOutputType
     */
    select?: MeetingCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountKeyMomentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: KeyMomentWhereInput;
  };

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountTagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MeetingTagWhereInput;
  };

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountShareLinksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ShareLinkWhereInput;
  };

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountSpeakersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SpeakerWhereInput;
  };

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountTranscriptArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TranscriptSegmentWhereInput;
  };

  /**
   * Count Type TranscriptSegmentCountOutputType
   */

  export type TranscriptSegmentCountOutputType = {
    edits: number;
    corrections: number;
  };

  export type TranscriptSegmentCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    edits?: boolean | TranscriptSegmentCountOutputTypeCountEditsArgs;
    corrections?:
      | boolean
      | TranscriptSegmentCountOutputTypeCountCorrectionsArgs;
  };

  // Custom InputTypes
  /**
   * TranscriptSegmentCountOutputType without action
   */
  export type TranscriptSegmentCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegmentCountOutputType
     */
    select?: TranscriptSegmentCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TranscriptSegmentCountOutputType without action
   */
  export type TranscriptSegmentCountOutputTypeCountEditsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SegmentEditWhereInput;
  };

  /**
   * TranscriptSegmentCountOutputType without action
   */
  export type TranscriptSegmentCountOutputTypeCountCorrectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TranscriptCorrectionWhereInput;
  };

  /**
   * Count Type SpeakerCountOutputType
   */

  export type SpeakerCountOutputType = {
    segments: number;
  };

  export type SpeakerCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    segments?: boolean | SpeakerCountOutputTypeCountSegmentsArgs;
  };

  // Custom InputTypes
  /**
   * SpeakerCountOutputType without action
   */
  export type SpeakerCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SpeakerCountOutputType
     */
    select?: SpeakerCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SpeakerCountOutputType without action
   */
  export type SpeakerCountOutputTypeCountSegmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TranscriptSegmentWhereInput;
  };

  /**
   * Count Type MinutesCountOutputType
   */

  export type MinutesCountOutputType = {
    versions: number;
  };

  export type MinutesCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    versions?: boolean | MinutesCountOutputTypeCountVersionsArgs;
  };

  // Custom InputTypes
  /**
   * MinutesCountOutputType without action
   */
  export type MinutesCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesCountOutputType
     */
    select?: MinutesCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * MinutesCountOutputType without action
   */
  export type MinutesCountOutputTypeCountVersionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MinutesVersionWhereInput;
  };

  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    meetings: number;
  };

  export type TagCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meetings?: boolean | TagCountOutputTypeCountMeetingsArgs;
  };

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountMeetingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MeetingTagWhereInput;
  };

  /**
   * Count Type CalendarConnectionCountOutputType
   */

  export type CalendarConnectionCountOutputType = {
    meetings: number;
  };

  export type CalendarConnectionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meetings?: boolean | CalendarConnectionCountOutputTypeCountMeetingsArgs;
  };

  // Custom InputTypes
  /**
   * CalendarConnectionCountOutputType without action
   */
  export type CalendarConnectionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnectionCountOutputType
     */
    select?: CalendarConnectionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CalendarConnectionCountOutputType without action
   */
  export type CalendarConnectionCountOutputTypeCountMeetingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MeetingWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    password: string | null;
    name: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    role: $Enums.Role | null;
    isActive: boolean | null;
    telegramId: string | null;
    telegramChatId: string | null;
    telegramLinkCode: string | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    password: string | null;
    name: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    role: $Enums.Role | null;
    isActive: boolean | null;
    telegramId: string | null;
    telegramChatId: string | null;
    telegramLinkCode: string | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    password: number;
    name: number;
    createdAt: number;
    updatedAt: number;
    role: number;
    isActive: number;
    telegramId: number;
    telegramChatId: number;
    telegramLinkCode: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    password?: true;
    name?: true;
    createdAt?: true;
    updatedAt?: true;
    role?: true;
    isActive?: true;
    telegramId?: true;
    telegramChatId?: true;
    telegramLinkCode?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    password?: true;
    name?: true;
    createdAt?: true;
    updatedAt?: true;
    role?: true;
    isActive?: true;
    telegramId?: true;
    telegramChatId?: true;
    telegramLinkCode?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    password?: true;
    name?: true;
    createdAt?: true;
    updatedAt?: true;
    role?: true;
    isActive?: true;
    telegramId?: true;
    telegramChatId?: true;
    telegramLinkCode?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    password: string | null;
    name: string | null;
    createdAt: Date;
    updatedAt: Date;
    role: $Enums.Role;
    isActive: boolean;
    telegramId: string | null;
    telegramChatId: string | null;
    telegramLinkCode: string | null;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      password?: boolean;
      name?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      role?: boolean;
      isActive?: boolean;
      telegramId?: boolean;
      telegramChatId?: boolean;
      telegramLinkCode?: boolean;
      meetings?: boolean | User$meetingsArgs<ExtArgs>;
      templates?: boolean | User$templatesArgs<ExtArgs>;
      notifications?: boolean | User$notificationsArgs<ExtArgs>;
      notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>;
      subscription?: boolean | User$subscriptionArgs<ExtArgs>;
      tags?: boolean | User$tagsArgs<ExtArgs>;
      memberships?: boolean | User$membershipsArgs<ExtArgs>;
      reviewedMinutes?: boolean | User$reviewedMinutesArgs<ExtArgs>;
      calendarConnections?: boolean | User$calendarConnectionsArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      password?: boolean;
      name?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      role?: boolean;
      isActive?: boolean;
      telegramId?: boolean;
      telegramChatId?: boolean;
      telegramLinkCode?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      password?: boolean;
      name?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      role?: boolean;
      isActive?: boolean;
      telegramId?: boolean;
      telegramChatId?: boolean;
      telegramLinkCode?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    password?: boolean;
    name?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    role?: boolean;
    isActive?: boolean;
    telegramId?: boolean;
    telegramChatId?: boolean;
    telegramLinkCode?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'email'
    | 'password'
    | 'name'
    | 'createdAt'
    | 'updatedAt'
    | 'role'
    | 'isActive'
    | 'telegramId'
    | 'telegramChatId'
    | 'telegramLinkCode',
    ExtArgs['result']['user']
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meetings?: boolean | User$meetingsArgs<ExtArgs>;
    templates?: boolean | User$templatesArgs<ExtArgs>;
    notifications?: boolean | User$notificationsArgs<ExtArgs>;
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>;
    subscription?: boolean | User$subscriptionArgs<ExtArgs>;
    tags?: boolean | User$tagsArgs<ExtArgs>;
    memberships?: boolean | User$membershipsArgs<ExtArgs>;
    reviewedMinutes?: boolean | User$reviewedMinutesArgs<ExtArgs>;
    calendarConnections?: boolean | User$calendarConnectionsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'User';
    objects: {
      meetings: Prisma.$MeetingPayload<ExtArgs>[];
      templates: Prisma.$MinutesTemplatePayload<ExtArgs>[];
      notifications: Prisma.$NotificationPayload<ExtArgs>[];
      notificationSettings: Prisma.$NotificationPreferencePayload<ExtArgs> | null;
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null;
      tags: Prisma.$TagPayload<ExtArgs>[];
      memberships: Prisma.$MembershipPayload<ExtArgs>[];
      reviewedMinutes: Prisma.$MinutesPayload<ExtArgs>[];
      calendarConnections: Prisma.$CalendarConnectionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        password: string | null;
        name: string | null;
        createdAt: Date;
        updatedAt: Date;
        role: $Enums.Role;
        isActive: boolean;
        telegramId: string | null;
        telegramChatId: string | null;
        telegramLinkCode: string | null;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['User'];
      meta: { name: 'User' };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    meetings<T extends User$meetingsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$meetingsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MeetingPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    templates<T extends User$templatesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$templatesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MinutesTemplatePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$notificationsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    notificationSettings<T extends User$notificationSettingsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$notificationSettingsArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(
      args?: Subset<T, User$subscriptionArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tags<T extends User$tagsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$tagsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TagPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$membershipsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MembershipPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    reviewedMinutes<T extends User$reviewedMinutesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$reviewedMinutesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MinutesPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    calendarConnections<T extends User$calendarConnectionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$calendarConnectionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CalendarConnectionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly password: FieldRef<'User', 'String'>;
    readonly name: FieldRef<'User', 'String'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
    readonly role: FieldRef<'User', 'Role'>;
    readonly isActive: FieldRef<'User', 'Boolean'>;
    readonly telegramId: FieldRef<'User', 'String'>;
    readonly telegramChatId: FieldRef<'User', 'String'>;
    readonly telegramLinkCode: FieldRef<'User', 'String'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.meetings
   */
  export type User$meetingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    where?: MeetingWhereInput;
    orderBy?:
      | MeetingOrderByWithRelationInput
      | MeetingOrderByWithRelationInput[];
    cursor?: MeetingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[];
  };

  /**
   * User.templates
   */
  export type User$templatesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    where?: MinutesTemplateWhereInput;
    orderBy?:
      | MinutesTemplateOrderByWithRelationInput
      | MinutesTemplateOrderByWithRelationInput[];
    cursor?: MinutesTemplateWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | MinutesTemplateScalarFieldEnum
      | MinutesTemplateScalarFieldEnum[];
  };

  /**
   * User.notifications
   */
  export type User$notificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * User.notificationSettings
   */
  export type User$notificationSettingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    where?: NotificationPreferenceWhereInput;
  };

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    where?: SubscriptionWhereInput;
  };

  /**
   * User.tags
   */
  export type User$tagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    where?: TagWhereInput;
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    cursor?: TagWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[];
  };

  /**
   * User.memberships
   */
  export type User$membershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    where?: MembershipWhereInput;
    orderBy?:
      | MembershipOrderByWithRelationInput
      | MembershipOrderByWithRelationInput[];
    cursor?: MembershipWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * User.reviewedMinutes
   */
  export type User$reviewedMinutesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    where?: MinutesWhereInput;
    orderBy?:
      | MinutesOrderByWithRelationInput
      | MinutesOrderByWithRelationInput[];
    cursor?: MinutesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MinutesScalarFieldEnum | MinutesScalarFieldEnum[];
  };

  /**
   * User.calendarConnections
   */
  export type User$calendarConnectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    where?: CalendarConnectionWhereInput;
    orderBy?:
      | CalendarConnectionOrderByWithRelationInput
      | CalendarConnectionOrderByWithRelationInput[];
    cursor?: CalendarConnectionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | CalendarConnectionScalarFieldEnum
      | CalendarConnectionScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null;
    _avg: OrganizationAvgAggregateOutputType | null;
    _sum: OrganizationSumAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  export type OrganizationAvgAggregateOutputType = {
    retentionDays: number | null;
  };

  export type OrganizationSumAggregateOutputType = {
    retentionDays: number | null;
  };

  export type OrganizationMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    isPersonal: boolean | null;
    autoRedact: boolean | null;
    retentionDays: number | null;
  };

  export type OrganizationMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    isPersonal: boolean | null;
    autoRedact: boolean | null;
    retentionDays: number | null;
  };

  export type OrganizationCountAggregateOutputType = {
    id: number;
    name: number;
    slug: number;
    createdAt: number;
    updatedAt: number;
    isPersonal: number;
    autoRedact: number;
    retentionDays: number;
    _all: number;
  };

  export type OrganizationAvgAggregateInputType = {
    retentionDays?: true;
  };

  export type OrganizationSumAggregateInputType = {
    retentionDays?: true;
  };

  export type OrganizationMinAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    createdAt?: true;
    updatedAt?: true;
    isPersonal?: true;
    autoRedact?: true;
    retentionDays?: true;
  };

  export type OrganizationMaxAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    createdAt?: true;
    updatedAt?: true;
    isPersonal?: true;
    autoRedact?: true;
    retentionDays?: true;
  };

  export type OrganizationCountAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    createdAt?: true;
    updatedAt?: true;
    isPersonal?: true;
    autoRedact?: true;
    retentionDays?: true;
    _all?: true;
  };

  export type OrganizationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Organizations
     **/
    _count?: true | OrganizationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrganizationAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrganizationSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrganizationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrganizationMaxAggregateInputType;
  };

  export type GetOrganizationAggregateType<
    T extends OrganizationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>;
  };

  export type OrganizationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrganizationWhereInput;
    orderBy?:
      | OrganizationOrderByWithAggregationInput
      | OrganizationOrderByWithAggregationInput[];
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum;
    having?: OrganizationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrganizationCountAggregateInputType | true;
    _avg?: OrganizationAvgAggregateInputType;
    _sum?: OrganizationSumAggregateInputType;
    _min?: OrganizationMinAggregateInputType;
    _max?: OrganizationMaxAggregateInputType;
  };

  export type OrganizationGroupByOutputType = {
    id: string;
    name: string;
    slug: string;
    createdAt: Date;
    updatedAt: Date;
    isPersonal: boolean;
    autoRedact: boolean;
    retentionDays: number | null;
    _count: OrganizationCountAggregateOutputType | null;
    _avg: OrganizationAvgAggregateOutputType | null;
    _sum: OrganizationSumAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrganizationGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof OrganizationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>;
        }
      >
    >;

  export type OrganizationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      isPersonal?: boolean;
      autoRedact?: boolean;
      retentionDays?: boolean;
      members?: boolean | Organization$membersArgs<ExtArgs>;
      meetings?: boolean | Organization$meetingsArgs<ExtArgs>;
      templates?: boolean | Organization$templatesArgs<ExtArgs>;
      tags?: boolean | Organization$tagsArgs<ExtArgs>;
      _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['organization']
  >;

  export type OrganizationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      isPersonal?: boolean;
      autoRedact?: boolean;
      retentionDays?: boolean;
    },
    ExtArgs['result']['organization']
  >;

  export type OrganizationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      isPersonal?: boolean;
      autoRedact?: boolean;
      retentionDays?: boolean;
    },
    ExtArgs['result']['organization']
  >;

  export type OrganizationSelectScalar = {
    id?: boolean;
    name?: boolean;
    slug?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: boolean;
  };

  export type OrganizationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'slug'
    | 'createdAt'
    | 'updatedAt'
    | 'isPersonal'
    | 'autoRedact'
    | 'retentionDays',
    ExtArgs['result']['organization']
  >;
  export type OrganizationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    members?: boolean | Organization$membersArgs<ExtArgs>;
    meetings?: boolean | Organization$meetingsArgs<ExtArgs>;
    templates?: boolean | Organization$templatesArgs<ExtArgs>;
    tags?: boolean | Organization$tagsArgs<ExtArgs>;
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type OrganizationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type OrganizationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $OrganizationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Organization';
    objects: {
      members: Prisma.$MembershipPayload<ExtArgs>[];
      meetings: Prisma.$MeetingPayload<ExtArgs>[];
      templates: Prisma.$MinutesTemplatePayload<ExtArgs>[];
      tags: Prisma.$TagPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        slug: string;
        createdAt: Date;
        updatedAt: Date;
        isPersonal: boolean;
        autoRedact: boolean;
        retentionDays: number | null;
      },
      ExtArgs['result']['organization']
    >;
    composites: {};
  };

  type OrganizationGetPayload<
    S extends boolean | null | undefined | OrganizationDefaultArgs,
  > = $Result.GetResult<Prisma.$OrganizationPayload, S>;

  type OrganizationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    OrganizationFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: OrganizationCountAggregateInputType | true;
  };

  export interface OrganizationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Organization'];
      meta: { name: 'Organization' };
    };
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(
      args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(
      args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     *
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrganizationFindManyArgs>(
      args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     *
     */
    create<T extends OrganizationCreateArgs>(
      args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrganizationCreateManyArgs>(
      args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     *
     */
    delete<T extends OrganizationDeleteArgs>(
      args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrganizationUpdateArgs>(
      args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrganizationUpdateManyArgs>(
      args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(
      args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
     **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrganizationAggregateArgs>(
      args: Subset<T, OrganizationAggregateArgs>,
    ): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>;

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetOrganizationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Organization model
     */
    readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    members<T extends Organization$membersArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$membersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MembershipPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    meetings<T extends Organization$meetingsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$meetingsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MeetingPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    templates<T extends Organization$templatesArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$templatesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MinutesTemplatePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    tags<T extends Organization$tagsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$tagsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TagPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<'Organization', 'String'>;
    readonly name: FieldRef<'Organization', 'String'>;
    readonly slug: FieldRef<'Organization', 'String'>;
    readonly createdAt: FieldRef<'Organization', 'DateTime'>;
    readonly updatedAt: FieldRef<'Organization', 'DateTime'>;
    readonly isPersonal: FieldRef<'Organization', 'Boolean'>;
    readonly autoRedact: FieldRef<'Organization', 'Boolean'>;
    readonly retentionDays: FieldRef<'Organization', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
  };

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<
      OrganizationUpdateManyMutationInput,
      OrganizationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to update.
     */
    limit?: number;
  };

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * The data used to update Organizations.
     */
    data: XOR<
      OrganizationUpdateManyMutationInput,
      OrganizationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to update.
     */
    limit?: number;
  };

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput;
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
  };

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number;
  };

  /**
   * Organization.members
   */
  export type Organization$membersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    where?: MembershipWhereInput;
    orderBy?:
      | MembershipOrderByWithRelationInput
      | MembershipOrderByWithRelationInput[];
    cursor?: MembershipWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * Organization.meetings
   */
  export type Organization$meetingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    where?: MeetingWhereInput;
    orderBy?:
      | MeetingOrderByWithRelationInput
      | MeetingOrderByWithRelationInput[];
    cursor?: MeetingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[];
  };

  /**
   * Organization.templates
   */
  export type Organization$templatesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    where?: MinutesTemplateWhereInput;
    orderBy?:
      | MinutesTemplateOrderByWithRelationInput
      | MinutesTemplateOrderByWithRelationInput[];
    cursor?: MinutesTemplateWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | MinutesTemplateScalarFieldEnum
      | MinutesTemplateScalarFieldEnum[];
  };

  /**
   * Organization.tags
   */
  export type Organization$tagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    where?: TagWhereInput;
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    cursor?: TagWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[];
  };

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
  };

  /**
   * Model Membership
   */

  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null;
    _min: MembershipMinAggregateOutputType | null;
    _max: MembershipMaxAggregateOutputType | null;
  };

  export type MembershipMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    role: $Enums.MemberRole | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MembershipMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    role: $Enums.MemberRole | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MembershipCountAggregateOutputType = {
    id: number;
    userId: number;
    organizationId: number;
    role: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type MembershipMinAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    role?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MembershipMaxAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    role?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MembershipCountAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    role?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type MembershipAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Membership to aggregate.
     */
    where?: MembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Memberships to fetch.
     */
    orderBy?:
      | MembershipOrderByWithRelationInput
      | MembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Memberships.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Memberships
     **/
    _count?: true | MembershipCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MembershipMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MembershipMaxAggregateInputType;
  };

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
    [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>;
  };

  export type MembershipGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MembershipWhereInput;
    orderBy?:
      | MembershipOrderByWithAggregationInput
      | MembershipOrderByWithAggregationInput[];
    by: MembershipScalarFieldEnum[] | MembershipScalarFieldEnum;
    having?: MembershipScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MembershipCountAggregateInputType | true;
    _min?: MembershipMinAggregateInputType;
    _max?: MembershipMaxAggregateInputType;
  };

  export type MembershipGroupByOutputType = {
    id: string;
    userId: string;
    organizationId: string;
    role: $Enums.MemberRole;
    createdAt: Date;
    updatedAt: Date;
    _count: MembershipCountAggregateOutputType | null;
    _min: MembershipMinAggregateOutputType | null;
    _max: MembershipMaxAggregateOutputType | null;
  };

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MembershipGroupByOutputType, T['by']> & {
          [P in keyof T & keyof MembershipGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>;
        }
      >
    >;

  export type MembershipSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['membership']
  >;

  export type MembershipSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['membership']
  >;

  export type MembershipSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['membership']
  >;

  export type MembershipSelectScalar = {
    id?: boolean;
    userId?: boolean;
    organizationId?: boolean;
    role?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type MembershipOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'userId' | 'organizationId' | 'role' | 'createdAt' | 'updatedAt',
    ExtArgs['result']['membership']
  >;
  export type MembershipInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type MembershipIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type MembershipIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $MembershipPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Membership';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      organization: Prisma.$OrganizationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        organizationId: string;
        role: $Enums.MemberRole;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['membership']
    >;
    composites: {};
  };

  type MembershipGetPayload<
    S extends boolean | null | undefined | MembershipDefaultArgs,
  > = $Result.GetResult<Prisma.$MembershipPayload, S>;

  type MembershipCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    MembershipFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: MembershipCountAggregateInputType | true;
  };

  export interface MembershipDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Membership'];
      meta: { name: 'Membership' };
    };
    /**
     * Find zero or one Membership that matches the filter.
     * @param {MembershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipFindUniqueArgs>(
      args: SelectSubset<T, MembershipFindUniqueArgs<ExtArgs>>,
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Membership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipFindUniqueOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MembershipFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipFindFirstArgs>(
      args?: SelectSubset<T, MembershipFindFirstArgs<ExtArgs>>,
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Membership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MembershipFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     *
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const membershipWithIdOnly = await prisma.membership.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MembershipFindManyArgs>(
      args?: SelectSubset<T, MembershipFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Membership.
     * @param {MembershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     *
     */
    create<T extends MembershipCreateArgs>(
      args: SelectSubset<T, MembershipCreateArgs<ExtArgs>>,
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Memberships.
     * @param {MembershipCreateManyArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MembershipCreateManyArgs>(
      args?: SelectSubset<T, MembershipCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Memberships and returns the data saved in the database.
     * @param {MembershipCreateManyAndReturnArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MembershipCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MembershipCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Membership.
     * @param {MembershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     *
     */
    delete<T extends MembershipDeleteArgs>(
      args: SelectSubset<T, MembershipDeleteArgs<ExtArgs>>,
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Membership.
     * @param {MembershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MembershipUpdateArgs>(
      args: SelectSubset<T, MembershipUpdateArgs<ExtArgs>>,
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Memberships.
     * @param {MembershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MembershipDeleteManyArgs>(
      args?: SelectSubset<T, MembershipDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MembershipUpdateManyArgs>(
      args: SelectSubset<T, MembershipUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Memberships and returns the data updated in the database.
     * @param {MembershipUpdateManyAndReturnArgs} args - Arguments to update many Memberships.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MembershipUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MembershipUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Membership.
     * @param {MembershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUpsertArgs>(
      args: SelectSubset<T, MembershipUpsertArgs<ExtArgs>>,
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
     **/
    count<T extends MembershipCountArgs>(
      args?: Subset<T, MembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MembershipAggregateArgs>(
      args: Subset<T, MembershipAggregateArgs>,
    ): Prisma.PrismaPromise<GetMembershipAggregateType<T>>;

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetMembershipGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Membership model
     */
    readonly fields: MembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Membership model
   */
  interface MembershipFieldRefs {
    readonly id: FieldRef<'Membership', 'String'>;
    readonly userId: FieldRef<'Membership', 'String'>;
    readonly organizationId: FieldRef<'Membership', 'String'>;
    readonly role: FieldRef<'Membership', 'MemberRole'>;
    readonly createdAt: FieldRef<'Membership', 'DateTime'>;
    readonly updatedAt: FieldRef<'Membership', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Membership findUnique
   */
  export type MembershipFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput;
  };

  /**
   * Membership findUniqueOrThrow
   */
  export type MembershipFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput;
  };

  /**
   * Membership findFirst
   */
  export type MembershipFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Memberships to fetch.
     */
    orderBy?:
      | MembershipOrderByWithRelationInput
      | MembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Memberships.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * Membership findFirstOrThrow
   */
  export type MembershipFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Memberships to fetch.
     */
    orderBy?:
      | MembershipOrderByWithRelationInput
      | MembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Memberships.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * Membership findMany
   */
  export type MembershipFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Memberships to fetch.
     */
    orderBy?:
      | MembershipOrderByWithRelationInput
      | MembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Memberships.
     */
    cursor?: MembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Memberships.
     */
    skip?: number;
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * Membership create
   */
  export type MembershipCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * The data needed to create a Membership.
     */
    data: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>;
  };

  /**
   * Membership createMany
   */
  export type MembershipCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Membership createManyAndReturn
   */
  export type MembershipCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Membership update
   */
  export type MembershipUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * The data needed to update a Membership.
     */
    data: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>;
    /**
     * Choose, which Membership to update.
     */
    where: MembershipWhereUniqueInput;
  };

  /**
   * Membership updateMany
   */
  export type MembershipUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Memberships.
     */
    data: XOR<
      MembershipUpdateManyMutationInput,
      MembershipUncheckedUpdateManyInput
    >;
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput;
    /**
     * Limit how many Memberships to update.
     */
    limit?: number;
  };

  /**
   * Membership updateManyAndReturn
   */
  export type MembershipUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * The data used to update Memberships.
     */
    data: XOR<
      MembershipUpdateManyMutationInput,
      MembershipUncheckedUpdateManyInput
    >;
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput;
    /**
     * Limit how many Memberships to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Membership upsert
   */
  export type MembershipUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * The filter to search for the Membership to update in case it exists.
     */
    where: MembershipWhereUniqueInput;
    /**
     * In case the Membership found by the `where` argument doesn't exist, create a new Membership with this data.
     */
    create: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>;
    /**
     * In case the Membership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>;
  };

  /**
   * Membership delete
   */
  export type MembershipDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter which Membership to delete.
     */
    where: MembershipWhereUniqueInput;
  };

  /**
   * Membership deleteMany
   */
  export type MembershipDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Memberships to delete
     */
    where?: MembershipWhereInput;
    /**
     * Limit how many Memberships to delete.
     */
    limit?: number;
  };

  /**
   * Membership without action
   */
  export type MembershipDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
  };

  /**
   * Model MinutesTemplate
   */

  export type AggregateMinutesTemplate = {
    _count: MinutesTemplateCountAggregateOutputType | null;
    _min: MinutesTemplateMinAggregateOutputType | null;
    _max: MinutesTemplateMaxAggregateOutputType | null;
  };

  export type MinutesTemplateMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    name: string | null;
    description: string | null;
    format: string | null;
    isDefault: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MinutesTemplateMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    name: string | null;
    description: string | null;
    format: string | null;
    isDefault: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MinutesTemplateCountAggregateOutputType = {
    id: number;
    userId: number;
    organizationId: number;
    name: number;
    description: number;
    format: number;
    sections: number;
    isDefault: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type MinutesTemplateMinAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    name?: true;
    description?: true;
    format?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MinutesTemplateMaxAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    name?: true;
    description?: true;
    format?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MinutesTemplateCountAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    name?: true;
    description?: true;
    format?: true;
    sections?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type MinutesTemplateAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MinutesTemplate to aggregate.
     */
    where?: MinutesTemplateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MinutesTemplates to fetch.
     */
    orderBy?:
      | MinutesTemplateOrderByWithRelationInput
      | MinutesTemplateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MinutesTemplateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MinutesTemplates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MinutesTemplates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned MinutesTemplates
     **/
    _count?: true | MinutesTemplateCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MinutesTemplateMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MinutesTemplateMaxAggregateInputType;
  };

  export type GetMinutesTemplateAggregateType<
    T extends MinutesTemplateAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateMinutesTemplate]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinutesTemplate[P]>
      : GetScalarType<T[P], AggregateMinutesTemplate[P]>;
  };

  export type MinutesTemplateGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MinutesTemplateWhereInput;
    orderBy?:
      | MinutesTemplateOrderByWithAggregationInput
      | MinutesTemplateOrderByWithAggregationInput[];
    by: MinutesTemplateScalarFieldEnum[] | MinutesTemplateScalarFieldEnum;
    having?: MinutesTemplateScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MinutesTemplateCountAggregateInputType | true;
    _min?: MinutesTemplateMinAggregateInputType;
    _max?: MinutesTemplateMaxAggregateInputType;
  };

  export type MinutesTemplateGroupByOutputType = {
    id: string;
    userId: string;
    organizationId: string | null;
    name: string;
    description: string | null;
    format: string;
    sections: JsonValue;
    isDefault: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: MinutesTemplateCountAggregateOutputType | null;
    _min: MinutesTemplateMinAggregateOutputType | null;
    _max: MinutesTemplateMaxAggregateOutputType | null;
  };

  type GetMinutesTemplateGroupByPayload<T extends MinutesTemplateGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MinutesTemplateGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof MinutesTemplateGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinutesTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], MinutesTemplateGroupByOutputType[P]>;
        }
      >
    >;

  export type MinutesTemplateSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      name?: boolean;
      description?: boolean;
      format?: boolean;
      sections?: boolean;
      isDefault?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | MinutesTemplate$organizationArgs<ExtArgs>;
    },
    ExtArgs['result']['minutesTemplate']
  >;

  export type MinutesTemplateSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      name?: boolean;
      description?: boolean;
      format?: boolean;
      sections?: boolean;
      isDefault?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | MinutesTemplate$organizationArgs<ExtArgs>;
    },
    ExtArgs['result']['minutesTemplate']
  >;

  export type MinutesTemplateSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      name?: boolean;
      description?: boolean;
      format?: boolean;
      sections?: boolean;
      isDefault?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | MinutesTemplate$organizationArgs<ExtArgs>;
    },
    ExtArgs['result']['minutesTemplate']
  >;

  export type MinutesTemplateSelectScalar = {
    id?: boolean;
    userId?: boolean;
    organizationId?: boolean;
    name?: boolean;
    description?: boolean;
    format?: boolean;
    sections?: boolean;
    isDefault?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type MinutesTemplateOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'organizationId'
    | 'name'
    | 'description'
    | 'format'
    | 'sections'
    | 'isDefault'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['minutesTemplate']
  >;
  export type MinutesTemplateInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | MinutesTemplate$organizationArgs<ExtArgs>;
  };
  export type MinutesTemplateIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | MinutesTemplate$organizationArgs<ExtArgs>;
  };
  export type MinutesTemplateIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | MinutesTemplate$organizationArgs<ExtArgs>;
  };

  export type $MinutesTemplatePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'MinutesTemplate';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      organization: Prisma.$OrganizationPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        organizationId: string | null;
        name: string;
        description: string | null;
        format: string;
        sections: Prisma.JsonValue;
        isDefault: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['minutesTemplate']
    >;
    composites: {};
  };

  type MinutesTemplateGetPayload<
    S extends boolean | null | undefined | MinutesTemplateDefaultArgs,
  > = $Result.GetResult<Prisma.$MinutesTemplatePayload, S>;

  type MinutesTemplateCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    MinutesTemplateFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: MinutesTemplateCountAggregateInputType | true;
  };

  export interface MinutesTemplateDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['MinutesTemplate'];
      meta: { name: 'MinutesTemplate' };
    };
    /**
     * Find zero or one MinutesTemplate that matches the filter.
     * @param {MinutesTemplateFindUniqueArgs} args - Arguments to find a MinutesTemplate
     * @example
     * // Get one MinutesTemplate
     * const minutesTemplate = await prisma.minutesTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MinutesTemplateFindUniqueArgs>(
      args: SelectSubset<T, MinutesTemplateFindUniqueArgs<ExtArgs>>,
    ): Prisma__MinutesTemplateClient<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one MinutesTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MinutesTemplateFindUniqueOrThrowArgs} args - Arguments to find a MinutesTemplate
     * @example
     * // Get one MinutesTemplate
     * const minutesTemplate = await prisma.minutesTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MinutesTemplateFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MinutesTemplateFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__MinutesTemplateClient<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MinutesTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesTemplateFindFirstArgs} args - Arguments to find a MinutesTemplate
     * @example
     * // Get one MinutesTemplate
     * const minutesTemplate = await prisma.minutesTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MinutesTemplateFindFirstArgs>(
      args?: SelectSubset<T, MinutesTemplateFindFirstArgs<ExtArgs>>,
    ): Prisma__MinutesTemplateClient<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MinutesTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesTemplateFindFirstOrThrowArgs} args - Arguments to find a MinutesTemplate
     * @example
     * // Get one MinutesTemplate
     * const minutesTemplate = await prisma.minutesTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MinutesTemplateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MinutesTemplateFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__MinutesTemplateClient<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more MinutesTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MinutesTemplates
     * const minutesTemplates = await prisma.minutesTemplate.findMany()
     *
     * // Get first 10 MinutesTemplates
     * const minutesTemplates = await prisma.minutesTemplate.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const minutesTemplateWithIdOnly = await prisma.minutesTemplate.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MinutesTemplateFindManyArgs>(
      args?: SelectSubset<T, MinutesTemplateFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a MinutesTemplate.
     * @param {MinutesTemplateCreateArgs} args - Arguments to create a MinutesTemplate.
     * @example
     * // Create one MinutesTemplate
     * const MinutesTemplate = await prisma.minutesTemplate.create({
     *   data: {
     *     // ... data to create a MinutesTemplate
     *   }
     * })
     *
     */
    create<T extends MinutesTemplateCreateArgs>(
      args: SelectSubset<T, MinutesTemplateCreateArgs<ExtArgs>>,
    ): Prisma__MinutesTemplateClient<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many MinutesTemplates.
     * @param {MinutesTemplateCreateManyArgs} args - Arguments to create many MinutesTemplates.
     * @example
     * // Create many MinutesTemplates
     * const minutesTemplate = await prisma.minutesTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MinutesTemplateCreateManyArgs>(
      args?: SelectSubset<T, MinutesTemplateCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many MinutesTemplates and returns the data saved in the database.
     * @param {MinutesTemplateCreateManyAndReturnArgs} args - Arguments to create many MinutesTemplates.
     * @example
     * // Create many MinutesTemplates
     * const minutesTemplate = await prisma.minutesTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many MinutesTemplates and only return the `id`
     * const minutesTemplateWithIdOnly = await prisma.minutesTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MinutesTemplateCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MinutesTemplateCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a MinutesTemplate.
     * @param {MinutesTemplateDeleteArgs} args - Arguments to delete one MinutesTemplate.
     * @example
     * // Delete one MinutesTemplate
     * const MinutesTemplate = await prisma.minutesTemplate.delete({
     *   where: {
     *     // ... filter to delete one MinutesTemplate
     *   }
     * })
     *
     */
    delete<T extends MinutesTemplateDeleteArgs>(
      args: SelectSubset<T, MinutesTemplateDeleteArgs<ExtArgs>>,
    ): Prisma__MinutesTemplateClient<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one MinutesTemplate.
     * @param {MinutesTemplateUpdateArgs} args - Arguments to update one MinutesTemplate.
     * @example
     * // Update one MinutesTemplate
     * const minutesTemplate = await prisma.minutesTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MinutesTemplateUpdateArgs>(
      args: SelectSubset<T, MinutesTemplateUpdateArgs<ExtArgs>>,
    ): Prisma__MinutesTemplateClient<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more MinutesTemplates.
     * @param {MinutesTemplateDeleteManyArgs} args - Arguments to filter MinutesTemplates to delete.
     * @example
     * // Delete a few MinutesTemplates
     * const { count } = await prisma.minutesTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MinutesTemplateDeleteManyArgs>(
      args?: SelectSubset<T, MinutesTemplateDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MinutesTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MinutesTemplates
     * const minutesTemplate = await prisma.minutesTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MinutesTemplateUpdateManyArgs>(
      args: SelectSubset<T, MinutesTemplateUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MinutesTemplates and returns the data updated in the database.
     * @param {MinutesTemplateUpdateManyAndReturnArgs} args - Arguments to update many MinutesTemplates.
     * @example
     * // Update many MinutesTemplates
     * const minutesTemplate = await prisma.minutesTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more MinutesTemplates and only return the `id`
     * const minutesTemplateWithIdOnly = await prisma.minutesTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MinutesTemplateUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MinutesTemplateUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one MinutesTemplate.
     * @param {MinutesTemplateUpsertArgs} args - Arguments to update or create a MinutesTemplate.
     * @example
     * // Update or create a MinutesTemplate
     * const minutesTemplate = await prisma.minutesTemplate.upsert({
     *   create: {
     *     // ... data to create a MinutesTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MinutesTemplate we want to update
     *   }
     * })
     */
    upsert<T extends MinutesTemplateUpsertArgs>(
      args: SelectSubset<T, MinutesTemplateUpsertArgs<ExtArgs>>,
    ): Prisma__MinutesTemplateClient<
      $Result.GetResult<
        Prisma.$MinutesTemplatePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of MinutesTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesTemplateCountArgs} args - Arguments to filter MinutesTemplates to count.
     * @example
     * // Count the number of MinutesTemplates
     * const count = await prisma.minutesTemplate.count({
     *   where: {
     *     // ... the filter for the MinutesTemplates we want to count
     *   }
     * })
     **/
    count<T extends MinutesTemplateCountArgs>(
      args?: Subset<T, MinutesTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinutesTemplateCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a MinutesTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MinutesTemplateAggregateArgs>(
      args: Subset<T, MinutesTemplateAggregateArgs>,
    ): Prisma.PrismaPromise<GetMinutesTemplateAggregateType<T>>;

    /**
     * Group by MinutesTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MinutesTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MinutesTemplateGroupByArgs['orderBy'] }
        : { orderBy?: MinutesTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MinutesTemplateGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetMinutesTemplateGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the MinutesTemplate model
     */
    readonly fields: MinutesTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MinutesTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MinutesTemplateClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends MinutesTemplate$organizationArgs<ExtArgs> = {}>(
      args?: Subset<T, MinutesTemplate$organizationArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the MinutesTemplate model
   */
  interface MinutesTemplateFieldRefs {
    readonly id: FieldRef<'MinutesTemplate', 'String'>;
    readonly userId: FieldRef<'MinutesTemplate', 'String'>;
    readonly organizationId: FieldRef<'MinutesTemplate', 'String'>;
    readonly name: FieldRef<'MinutesTemplate', 'String'>;
    readonly description: FieldRef<'MinutesTemplate', 'String'>;
    readonly format: FieldRef<'MinutesTemplate', 'String'>;
    readonly sections: FieldRef<'MinutesTemplate', 'Json'>;
    readonly isDefault: FieldRef<'MinutesTemplate', 'Boolean'>;
    readonly createdAt: FieldRef<'MinutesTemplate', 'DateTime'>;
    readonly updatedAt: FieldRef<'MinutesTemplate', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * MinutesTemplate findUnique
   */
  export type MinutesTemplateFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesTemplate to fetch.
     */
    where: MinutesTemplateWhereUniqueInput;
  };

  /**
   * MinutesTemplate findUniqueOrThrow
   */
  export type MinutesTemplateFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesTemplate to fetch.
     */
    where: MinutesTemplateWhereUniqueInput;
  };

  /**
   * MinutesTemplate findFirst
   */
  export type MinutesTemplateFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesTemplate to fetch.
     */
    where?: MinutesTemplateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MinutesTemplates to fetch.
     */
    orderBy?:
      | MinutesTemplateOrderByWithRelationInput
      | MinutesTemplateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MinutesTemplates.
     */
    cursor?: MinutesTemplateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MinutesTemplates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MinutesTemplates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MinutesTemplates.
     */
    distinct?:
      | MinutesTemplateScalarFieldEnum
      | MinutesTemplateScalarFieldEnum[];
  };

  /**
   * MinutesTemplate findFirstOrThrow
   */
  export type MinutesTemplateFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesTemplate to fetch.
     */
    where?: MinutesTemplateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MinutesTemplates to fetch.
     */
    orderBy?:
      | MinutesTemplateOrderByWithRelationInput
      | MinutesTemplateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MinutesTemplates.
     */
    cursor?: MinutesTemplateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MinutesTemplates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MinutesTemplates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MinutesTemplates.
     */
    distinct?:
      | MinutesTemplateScalarFieldEnum
      | MinutesTemplateScalarFieldEnum[];
  };

  /**
   * MinutesTemplate findMany
   */
  export type MinutesTemplateFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesTemplates to fetch.
     */
    where?: MinutesTemplateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MinutesTemplates to fetch.
     */
    orderBy?:
      | MinutesTemplateOrderByWithRelationInput
      | MinutesTemplateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing MinutesTemplates.
     */
    cursor?: MinutesTemplateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MinutesTemplates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MinutesTemplates.
     */
    skip?: number;
    distinct?:
      | MinutesTemplateScalarFieldEnum
      | MinutesTemplateScalarFieldEnum[];
  };

  /**
   * MinutesTemplate create
   */
  export type MinutesTemplateCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    /**
     * The data needed to create a MinutesTemplate.
     */
    data: XOR<MinutesTemplateCreateInput, MinutesTemplateUncheckedCreateInput>;
  };

  /**
   * MinutesTemplate createMany
   */
  export type MinutesTemplateCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many MinutesTemplates.
     */
    data: MinutesTemplateCreateManyInput | MinutesTemplateCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * MinutesTemplate createManyAndReturn
   */
  export type MinutesTemplateCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * The data used to create many MinutesTemplates.
     */
    data: MinutesTemplateCreateManyInput | MinutesTemplateCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MinutesTemplate update
   */
  export type MinutesTemplateUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    /**
     * The data needed to update a MinutesTemplate.
     */
    data: XOR<MinutesTemplateUpdateInput, MinutesTemplateUncheckedUpdateInput>;
    /**
     * Choose, which MinutesTemplate to update.
     */
    where: MinutesTemplateWhereUniqueInput;
  };

  /**
   * MinutesTemplate updateMany
   */
  export type MinutesTemplateUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update MinutesTemplates.
     */
    data: XOR<
      MinutesTemplateUpdateManyMutationInput,
      MinutesTemplateUncheckedUpdateManyInput
    >;
    /**
     * Filter which MinutesTemplates to update
     */
    where?: MinutesTemplateWhereInput;
    /**
     * Limit how many MinutesTemplates to update.
     */
    limit?: number;
  };

  /**
   * MinutesTemplate updateManyAndReturn
   */
  export type MinutesTemplateUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * The data used to update MinutesTemplates.
     */
    data: XOR<
      MinutesTemplateUpdateManyMutationInput,
      MinutesTemplateUncheckedUpdateManyInput
    >;
    /**
     * Filter which MinutesTemplates to update
     */
    where?: MinutesTemplateWhereInput;
    /**
     * Limit how many MinutesTemplates to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MinutesTemplate upsert
   */
  export type MinutesTemplateUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    /**
     * The filter to search for the MinutesTemplate to update in case it exists.
     */
    where: MinutesTemplateWhereUniqueInput;
    /**
     * In case the MinutesTemplate found by the `where` argument doesn't exist, create a new MinutesTemplate with this data.
     */
    create: XOR<
      MinutesTemplateCreateInput,
      MinutesTemplateUncheckedCreateInput
    >;
    /**
     * In case the MinutesTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      MinutesTemplateUpdateInput,
      MinutesTemplateUncheckedUpdateInput
    >;
  };

  /**
   * MinutesTemplate delete
   */
  export type MinutesTemplateDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
    /**
     * Filter which MinutesTemplate to delete.
     */
    where: MinutesTemplateWhereUniqueInput;
  };

  /**
   * MinutesTemplate deleteMany
   */
  export type MinutesTemplateDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MinutesTemplates to delete
     */
    where?: MinutesTemplateWhereInput;
    /**
     * Limit how many MinutesTemplates to delete.
     */
    limit?: number;
  };

  /**
   * MinutesTemplate.organization
   */
  export type MinutesTemplate$organizationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    where?: OrganizationWhereInput;
  };

  /**
   * MinutesTemplate without action
   */
  export type MinutesTemplateDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesTemplate
     */
    select?: MinutesTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesTemplate
     */
    omit?: MinutesTemplateOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesTemplateInclude<ExtArgs> | null;
  };

  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null;
    _avg: PlanAvgAggregateOutputType | null;
    _sum: PlanSumAggregateOutputType | null;
    _min: PlanMinAggregateOutputType | null;
    _max: PlanMaxAggregateOutputType | null;
  };

  export type PlanAvgAggregateOutputType = {
    maxMinutesPerUpload: number | null;
    maxUploadsPerWeek: number | null;
    monthlyMinutesLimit: number | null;
    price: Decimal | null;
  };

  export type PlanSumAggregateOutputType = {
    maxMinutesPerUpload: number | null;
    maxUploadsPerWeek: number | null;
    monthlyMinutesLimit: number | null;
    price: Decimal | null;
  };

  export type PlanMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    maxMinutesPerUpload: number | null;
    maxUploadsPerWeek: number | null;
    monthlyMinutesLimit: number | null;
    price: Decimal | null;
    currency: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PlanMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    maxMinutesPerUpload: number | null;
    maxUploadsPerWeek: number | null;
    monthlyMinutesLimit: number | null;
    price: Decimal | null;
    currency: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PlanCountAggregateOutputType = {
    id: number;
    name: number;
    maxMinutesPerUpload: number;
    maxUploadsPerWeek: number;
    monthlyMinutesLimit: number;
    price: number;
    currency: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type PlanAvgAggregateInputType = {
    maxMinutesPerUpload?: true;
    maxUploadsPerWeek?: true;
    monthlyMinutesLimit?: true;
    price?: true;
  };

  export type PlanSumAggregateInputType = {
    maxMinutesPerUpload?: true;
    maxUploadsPerWeek?: true;
    monthlyMinutesLimit?: true;
    price?: true;
  };

  export type PlanMinAggregateInputType = {
    id?: true;
    name?: true;
    maxMinutesPerUpload?: true;
    maxUploadsPerWeek?: true;
    monthlyMinutesLimit?: true;
    price?: true;
    currency?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PlanMaxAggregateInputType = {
    id?: true;
    name?: true;
    maxMinutesPerUpload?: true;
    maxUploadsPerWeek?: true;
    monthlyMinutesLimit?: true;
    price?: true;
    currency?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PlanCountAggregateInputType = {
    id?: true;
    name?: true;
    maxMinutesPerUpload?: true;
    maxUploadsPerWeek?: true;
    monthlyMinutesLimit?: true;
    price?: true;
    currency?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type PlanAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Plans.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Plans
     **/
    _count?: true | PlanCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PlanAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PlanSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PlanMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PlanMaxAggregateInputType;
  };

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
    [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>;
  };

  export type PlanGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PlanWhereInput;
    orderBy?:
      | PlanOrderByWithAggregationInput
      | PlanOrderByWithAggregationInput[];
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum;
    having?: PlanScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PlanCountAggregateInputType | true;
    _avg?: PlanAvgAggregateInputType;
    _sum?: PlanSumAggregateInputType;
    _min?: PlanMinAggregateInputType;
    _max?: PlanMaxAggregateInputType;
  };

  export type PlanGroupByOutputType = {
    id: string;
    name: string;
    maxMinutesPerUpload: number;
    maxUploadsPerWeek: number;
    monthlyMinutesLimit: number;
    price: Decimal;
    currency: string;
    createdAt: Date;
    updatedAt: Date;
    _count: PlanCountAggregateOutputType | null;
    _avg: PlanAvgAggregateOutputType | null;
    _sum: PlanSumAggregateOutputType | null;
    _min: PlanMinAggregateOutputType | null;
    _max: PlanMaxAggregateOutputType | null;
  };

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PlanGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
          : GetScalarType<T[P], PlanGroupByOutputType[P]>;
      }
    >
  >;

  export type PlanSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      maxMinutesPerUpload?: boolean;
      maxUploadsPerWeek?: boolean;
      monthlyMinutesLimit?: boolean;
      price?: boolean;
      currency?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>;
      _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['plan']
  >;

  export type PlanSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      maxMinutesPerUpload?: boolean;
      maxUploadsPerWeek?: boolean;
      monthlyMinutesLimit?: boolean;
      price?: boolean;
      currency?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['plan']
  >;

  export type PlanSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      maxMinutesPerUpload?: boolean;
      maxUploadsPerWeek?: boolean;
      monthlyMinutesLimit?: boolean;
      price?: boolean;
      currency?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['plan']
  >;

  export type PlanSelectScalar = {
    id?: boolean;
    name?: boolean;
    maxMinutesPerUpload?: boolean;
    maxUploadsPerWeek?: boolean;
    monthlyMinutesLimit?: boolean;
    price?: boolean;
    currency?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type PlanOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'maxMinutesPerUpload'
    | 'maxUploadsPerWeek'
    | 'monthlyMinutesLimit'
    | 'price'
    | 'currency'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['plan']
  >;
  export type PlanInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>;
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type PlanIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type PlanIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $PlanPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Plan';
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        maxMinutesPerUpload: number;
        maxUploadsPerWeek: number;
        monthlyMinutesLimit: number;
        price: Prisma.Decimal;
        currency: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['plan']
    >;
    composites: {};
  };

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> =
    $Result.GetResult<Prisma.$PlanPayload, S>;

  type PlanCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PlanCountAggregateInputType | true;
  };

  export interface PlanDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Plan'];
      meta: { name: 'Plan' };
    };
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(
      args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>,
    ): Prisma__PlanClient<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__PlanClient<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(
      args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>,
    ): Prisma__PlanClient<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__PlanClient<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     *
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PlanFindManyArgs>(
      args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     *
     */
    create<T extends PlanCreateArgs>(
      args: SelectSubset<T, PlanCreateArgs<ExtArgs>>,
    ): Prisma__PlanClient<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PlanCreateManyArgs>(
      args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     *
     */
    delete<T extends PlanDeleteArgs>(
      args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>,
    ): Prisma__PlanClient<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PlanUpdateArgs>(
      args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>,
    ): Prisma__PlanClient<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PlanDeleteManyArgs>(
      args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PlanUpdateManyArgs>(
      args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(
      args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>,
    ): Prisma__PlanClient<
      $Result.GetResult<
        Prisma.$PlanPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
     **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PlanAggregateArgs>(
      args: Subset<T, PlanAggregateArgs>,
    ): Prisma.PrismaPromise<GetPlanAggregateType<T>>;

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetPlanGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Plan model
     */
    readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    subscriptions<T extends Plan$subscriptionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Plan$subscriptionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SubscriptionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<'Plan', 'String'>;
    readonly name: FieldRef<'Plan', 'String'>;
    readonly maxMinutesPerUpload: FieldRef<'Plan', 'Int'>;
    readonly maxUploadsPerWeek: FieldRef<'Plan', 'Int'>;
    readonly monthlyMinutesLimit: FieldRef<'Plan', 'Int'>;
    readonly price: FieldRef<'Plan', 'Decimal'>;
    readonly currency: FieldRef<'Plan', 'String'>;
    readonly createdAt: FieldRef<'Plan', 'DateTime'>;
    readonly updatedAt: FieldRef<'Plan', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput;
  };

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput;
  };

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Plans.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[];
  };

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Plans.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[];
  };

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Plans.
     */
    skip?: number;
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[];
  };

  /**
   * Plan create
   */
  export type PlanCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>;
  };

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Plan update
   */
  export type PlanUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>;
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput;
  };

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>;
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput;
    /**
     * Limit how many Plans to update.
     */
    limit?: number;
  };

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>;
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput;
    /**
     * Limit how many Plans to update.
     */
    limit?: number;
  };

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput;
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>;
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>;
  };

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput;
  };

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput;
    /**
     * Limit how many Plans to delete.
     */
    limit?: number;
  };

  /**
   * Plan.subscriptions
   */
  export type Plan$subscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    where?: SubscriptionWhereInput;
    orderBy?:
      | SubscriptionOrderByWithRelationInput
      | SubscriptionOrderByWithRelationInput[];
    cursor?: SubscriptionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[];
  };

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null;
  };

  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null;
    _min: SubscriptionMinAggregateOutputType | null;
    _max: SubscriptionMaxAggregateOutputType | null;
  };

  export type SubscriptionMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    planId: string | null;
    active: boolean | null;
    startsAt: Date | null;
    endsAt: Date | null;
  };

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    planId: string | null;
    active: boolean | null;
    startsAt: Date | null;
    endsAt: Date | null;
  };

  export type SubscriptionCountAggregateOutputType = {
    id: number;
    userId: number;
    planId: number;
    active: number;
    startsAt: number;
    endsAt: number;
    _all: number;
  };

  export type SubscriptionMinAggregateInputType = {
    id?: true;
    userId?: true;
    planId?: true;
    active?: true;
    startsAt?: true;
    endsAt?: true;
  };

  export type SubscriptionMaxAggregateInputType = {
    id?: true;
    userId?: true;
    planId?: true;
    active?: true;
    startsAt?: true;
    endsAt?: true;
  };

  export type SubscriptionCountAggregateInputType = {
    id?: true;
    userId?: true;
    planId?: true;
    active?: true;
    startsAt?: true;
    endsAt?: true;
    _all?: true;
  };

  export type SubscriptionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?:
      | SubscriptionOrderByWithRelationInput
      | SubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Subscriptions
     **/
    _count?: true | SubscriptionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubscriptionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubscriptionMaxAggregateInputType;
  };

  export type GetSubscriptionAggregateType<
    T extends SubscriptionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>;
  };

  export type SubscriptionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubscriptionWhereInput;
    orderBy?:
      | SubscriptionOrderByWithAggregationInput
      | SubscriptionOrderByWithAggregationInput[];
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum;
    having?: SubscriptionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubscriptionCountAggregateInputType | true;
    _min?: SubscriptionMinAggregateInputType;
    _max?: SubscriptionMaxAggregateInputType;
  };

  export type SubscriptionGroupByOutputType = {
    id: string;
    userId: string;
    planId: string;
    active: boolean;
    startsAt: Date;
    endsAt: Date | null;
    _count: SubscriptionCountAggregateOutputType | null;
    _min: SubscriptionMinAggregateOutputType | null;
    _max: SubscriptionMaxAggregateOutputType | null;
  };

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SubscriptionGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof SubscriptionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>;
        }
      >
    >;

  export type SubscriptionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      planId?: boolean;
      active?: boolean;
      startsAt?: boolean;
      endsAt?: boolean;
      plan?: boolean | PlanDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      usage?: boolean | Subscription$usageArgs<ExtArgs>;
      _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['subscription']
  >;

  export type SubscriptionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      planId?: boolean;
      active?: boolean;
      startsAt?: boolean;
      endsAt?: boolean;
      plan?: boolean | PlanDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['subscription']
  >;

  export type SubscriptionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      planId?: boolean;
      active?: boolean;
      startsAt?: boolean;
      endsAt?: boolean;
      plan?: boolean | PlanDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['subscription']
  >;

  export type SubscriptionSelectScalar = {
    id?: boolean;
    userId?: boolean;
    planId?: boolean;
    active?: boolean;
    startsAt?: boolean;
    endsAt?: boolean;
  };

  export type SubscriptionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'userId' | 'planId' | 'active' | 'startsAt' | 'endsAt',
    ExtArgs['result']['subscription']
  >;
  export type SubscriptionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
    usage?: boolean | Subscription$usageArgs<ExtArgs>;
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type SubscriptionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SubscriptionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SubscriptionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Subscription';
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
      usage: Prisma.$WeeklyUsagePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        planId: string;
        active: boolean;
        startsAt: Date;
        endsAt: Date | null;
      },
      ExtArgs['result']['subscription']
    >;
    composites: {};
  };

  type SubscriptionGetPayload<
    S extends boolean | null | undefined | SubscriptionDefaultArgs,
  > = $Result.GetResult<Prisma.$SubscriptionPayload, S>;

  type SubscriptionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    SubscriptionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: SubscriptionCountAggregateInputType | true;
  };

  export interface SubscriptionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Subscription'];
      meta: { name: 'Subscription' };
    };
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     *
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SubscriptionFindManyArgs>(
      args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     *
     */
    create<T extends SubscriptionCreateArgs>(
      args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SubscriptionCreateManyArgs>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     *
     */
    delete<T extends SubscriptionDeleteArgs>(
      args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SubscriptionUpdateArgs>(
      args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(
      args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
     **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubscriptionAggregateArgs>(
      args: Subset<T, SubscriptionAggregateArgs>,
    ): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>;

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetSubscriptionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Subscription model
     */
    readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PlanDefaultArgs<ExtArgs>>,
    ): Prisma__PlanClient<
      | $Result.GetResult<
          Prisma.$PlanPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    usage<T extends Subscription$usageArgs<ExtArgs> = {}>(
      args?: Subset<T, Subscription$usageArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$WeeklyUsagePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<'Subscription', 'String'>;
    readonly userId: FieldRef<'Subscription', 'String'>;
    readonly planId: FieldRef<'Subscription', 'String'>;
    readonly active: FieldRef<'Subscription', 'Boolean'>;
    readonly startsAt: FieldRef<'Subscription', 'DateTime'>;
    readonly endsAt: FieldRef<'Subscription', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput;
  };

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput;
  };

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?:
      | SubscriptionOrderByWithRelationInput
      | SubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[];
  };

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?:
      | SubscriptionOrderByWithRelationInput
      | SubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[];
  };

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?:
      | SubscriptionOrderByWithRelationInput
      | SubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subscriptions.
     */
    skip?: number;
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[];
  };

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>;
  };

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>;
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput;
  };

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<
      SubscriptionUpdateManyMutationInput,
      SubscriptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput;
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number;
  };

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<
      SubscriptionUpdateManyMutationInput,
      SubscriptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput;
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput;
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>;
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>;
  };

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput;
  };

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput;
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number;
  };

  /**
   * Subscription.usage
   */
  export type Subscription$usageArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    where?: WeeklyUsageWhereInput;
    orderBy?:
      | WeeklyUsageOrderByWithRelationInput
      | WeeklyUsageOrderByWithRelationInput[];
    cursor?: WeeklyUsageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WeeklyUsageScalarFieldEnum | WeeklyUsageScalarFieldEnum[];
  };

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
  };

  /**
   * Model WeeklyUsage
   */

  export type AggregateWeeklyUsage = {
    _count: WeeklyUsageCountAggregateOutputType | null;
    _avg: WeeklyUsageAvgAggregateOutputType | null;
    _sum: WeeklyUsageSumAggregateOutputType | null;
    _min: WeeklyUsageMinAggregateOutputType | null;
    _max: WeeklyUsageMaxAggregateOutputType | null;
  };

  export type WeeklyUsageAvgAggregateOutputType = {
    uploadCount: number | null;
    minutesProcessed: number | null;
  };

  export type WeeklyUsageSumAggregateOutputType = {
    uploadCount: number | null;
    minutesProcessed: number | null;
  };

  export type WeeklyUsageMinAggregateOutputType = {
    id: string | null;
    subscriptionId: string | null;
    weekStartDate: Date | null;
    uploadCount: number | null;
    minutesProcessed: number | null;
  };

  export type WeeklyUsageMaxAggregateOutputType = {
    id: string | null;
    subscriptionId: string | null;
    weekStartDate: Date | null;
    uploadCount: number | null;
    minutesProcessed: number | null;
  };

  export type WeeklyUsageCountAggregateOutputType = {
    id: number;
    subscriptionId: number;
    weekStartDate: number;
    uploadCount: number;
    minutesProcessed: number;
    _all: number;
  };

  export type WeeklyUsageAvgAggregateInputType = {
    uploadCount?: true;
    minutesProcessed?: true;
  };

  export type WeeklyUsageSumAggregateInputType = {
    uploadCount?: true;
    minutesProcessed?: true;
  };

  export type WeeklyUsageMinAggregateInputType = {
    id?: true;
    subscriptionId?: true;
    weekStartDate?: true;
    uploadCount?: true;
    minutesProcessed?: true;
  };

  export type WeeklyUsageMaxAggregateInputType = {
    id?: true;
    subscriptionId?: true;
    weekStartDate?: true;
    uploadCount?: true;
    minutesProcessed?: true;
  };

  export type WeeklyUsageCountAggregateInputType = {
    id?: true;
    subscriptionId?: true;
    weekStartDate?: true;
    uploadCount?: true;
    minutesProcessed?: true;
    _all?: true;
  };

  export type WeeklyUsageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WeeklyUsage to aggregate.
     */
    where?: WeeklyUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WeeklyUsages to fetch.
     */
    orderBy?:
      | WeeklyUsageOrderByWithRelationInput
      | WeeklyUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WeeklyUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WeeklyUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WeeklyUsages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned WeeklyUsages
     **/
    _count?: true | WeeklyUsageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: WeeklyUsageAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: WeeklyUsageSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WeeklyUsageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WeeklyUsageMaxAggregateInputType;
  };

  export type GetWeeklyUsageAggregateType<T extends WeeklyUsageAggregateArgs> =
    {
      [P in keyof T & keyof AggregateWeeklyUsage]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateWeeklyUsage[P]>
        : GetScalarType<T[P], AggregateWeeklyUsage[P]>;
    };

  export type WeeklyUsageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WeeklyUsageWhereInput;
    orderBy?:
      | WeeklyUsageOrderByWithAggregationInput
      | WeeklyUsageOrderByWithAggregationInput[];
    by: WeeklyUsageScalarFieldEnum[] | WeeklyUsageScalarFieldEnum;
    having?: WeeklyUsageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WeeklyUsageCountAggregateInputType | true;
    _avg?: WeeklyUsageAvgAggregateInputType;
    _sum?: WeeklyUsageSumAggregateInputType;
    _min?: WeeklyUsageMinAggregateInputType;
    _max?: WeeklyUsageMaxAggregateInputType;
  };

  export type WeeklyUsageGroupByOutputType = {
    id: string;
    subscriptionId: string;
    weekStartDate: Date;
    uploadCount: number;
    minutesProcessed: number;
    _count: WeeklyUsageCountAggregateOutputType | null;
    _avg: WeeklyUsageAvgAggregateOutputType | null;
    _sum: WeeklyUsageSumAggregateOutputType | null;
    _min: WeeklyUsageMinAggregateOutputType | null;
    _max: WeeklyUsageMaxAggregateOutputType | null;
  };

  type GetWeeklyUsageGroupByPayload<T extends WeeklyUsageGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<WeeklyUsageGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof WeeklyUsageGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyUsageGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyUsageGroupByOutputType[P]>;
        }
      >
    >;

  export type WeeklyUsageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      subscriptionId?: boolean;
      weekStartDate?: boolean;
      uploadCount?: boolean;
      minutesProcessed?: boolean;
      subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['weeklyUsage']
  >;

  export type WeeklyUsageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      subscriptionId?: boolean;
      weekStartDate?: boolean;
      uploadCount?: boolean;
      minutesProcessed?: boolean;
      subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['weeklyUsage']
  >;

  export type WeeklyUsageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      subscriptionId?: boolean;
      weekStartDate?: boolean;
      uploadCount?: boolean;
      minutesProcessed?: boolean;
      subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['weeklyUsage']
  >;

  export type WeeklyUsageSelectScalar = {
    id?: boolean;
    subscriptionId?: boolean;
    weekStartDate?: boolean;
    uploadCount?: boolean;
    minutesProcessed?: boolean;
  };

  export type WeeklyUsageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'subscriptionId'
    | 'weekStartDate'
    | 'uploadCount'
    | 'minutesProcessed',
    ExtArgs['result']['weeklyUsage']
  >;
  export type WeeklyUsageInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
  };
  export type WeeklyUsageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
  };
  export type WeeklyUsageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
  };

  export type $WeeklyUsagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'WeeklyUsage';
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        subscriptionId: string;
        weekStartDate: Date;
        uploadCount: number;
        minutesProcessed: number;
      },
      ExtArgs['result']['weeklyUsage']
    >;
    composites: {};
  };

  type WeeklyUsageGetPayload<
    S extends boolean | null | undefined | WeeklyUsageDefaultArgs,
  > = $Result.GetResult<Prisma.$WeeklyUsagePayload, S>;

  type WeeklyUsageCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    WeeklyUsageFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: WeeklyUsageCountAggregateInputType | true;
  };

  export interface WeeklyUsageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['WeeklyUsage'];
      meta: { name: 'WeeklyUsage' };
    };
    /**
     * Find zero or one WeeklyUsage that matches the filter.
     * @param {WeeklyUsageFindUniqueArgs} args - Arguments to find a WeeklyUsage
     * @example
     * // Get one WeeklyUsage
     * const weeklyUsage = await prisma.weeklyUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyUsageFindUniqueArgs>(
      args: SelectSubset<T, WeeklyUsageFindUniqueArgs<ExtArgs>>,
    ): Prisma__WeeklyUsageClient<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one WeeklyUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeeklyUsageFindUniqueOrThrowArgs} args - Arguments to find a WeeklyUsage
     * @example
     * // Get one WeeklyUsage
     * const weeklyUsage = await prisma.weeklyUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyUsageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WeeklyUsageFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__WeeklyUsageClient<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WeeklyUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyUsageFindFirstArgs} args - Arguments to find a WeeklyUsage
     * @example
     * // Get one WeeklyUsage
     * const weeklyUsage = await prisma.weeklyUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyUsageFindFirstArgs>(
      args?: SelectSubset<T, WeeklyUsageFindFirstArgs<ExtArgs>>,
    ): Prisma__WeeklyUsageClient<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WeeklyUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyUsageFindFirstOrThrowArgs} args - Arguments to find a WeeklyUsage
     * @example
     * // Get one WeeklyUsage
     * const weeklyUsage = await prisma.weeklyUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyUsageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WeeklyUsageFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__WeeklyUsageClient<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more WeeklyUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklyUsages
     * const weeklyUsages = await prisma.weeklyUsage.findMany()
     *
     * // Get first 10 WeeklyUsages
     * const weeklyUsages = await prisma.weeklyUsage.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const weeklyUsageWithIdOnly = await prisma.weeklyUsage.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WeeklyUsageFindManyArgs>(
      args?: SelectSubset<T, WeeklyUsageFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a WeeklyUsage.
     * @param {WeeklyUsageCreateArgs} args - Arguments to create a WeeklyUsage.
     * @example
     * // Create one WeeklyUsage
     * const WeeklyUsage = await prisma.weeklyUsage.create({
     *   data: {
     *     // ... data to create a WeeklyUsage
     *   }
     * })
     *
     */
    create<T extends WeeklyUsageCreateArgs>(
      args: SelectSubset<T, WeeklyUsageCreateArgs<ExtArgs>>,
    ): Prisma__WeeklyUsageClient<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many WeeklyUsages.
     * @param {WeeklyUsageCreateManyArgs} args - Arguments to create many WeeklyUsages.
     * @example
     * // Create many WeeklyUsages
     * const weeklyUsage = await prisma.weeklyUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WeeklyUsageCreateManyArgs>(
      args?: SelectSubset<T, WeeklyUsageCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many WeeklyUsages and returns the data saved in the database.
     * @param {WeeklyUsageCreateManyAndReturnArgs} args - Arguments to create many WeeklyUsages.
     * @example
     * // Create many WeeklyUsages
     * const weeklyUsage = await prisma.weeklyUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many WeeklyUsages and only return the `id`
     * const weeklyUsageWithIdOnly = await prisma.weeklyUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WeeklyUsageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WeeklyUsageCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a WeeklyUsage.
     * @param {WeeklyUsageDeleteArgs} args - Arguments to delete one WeeklyUsage.
     * @example
     * // Delete one WeeklyUsage
     * const WeeklyUsage = await prisma.weeklyUsage.delete({
     *   where: {
     *     // ... filter to delete one WeeklyUsage
     *   }
     * })
     *
     */
    delete<T extends WeeklyUsageDeleteArgs>(
      args: SelectSubset<T, WeeklyUsageDeleteArgs<ExtArgs>>,
    ): Prisma__WeeklyUsageClient<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one WeeklyUsage.
     * @param {WeeklyUsageUpdateArgs} args - Arguments to update one WeeklyUsage.
     * @example
     * // Update one WeeklyUsage
     * const weeklyUsage = await prisma.weeklyUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WeeklyUsageUpdateArgs>(
      args: SelectSubset<T, WeeklyUsageUpdateArgs<ExtArgs>>,
    ): Prisma__WeeklyUsageClient<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more WeeklyUsages.
     * @param {WeeklyUsageDeleteManyArgs} args - Arguments to filter WeeklyUsages to delete.
     * @example
     * // Delete a few WeeklyUsages
     * const { count } = await prisma.weeklyUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WeeklyUsageDeleteManyArgs>(
      args?: SelectSubset<T, WeeklyUsageDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WeeklyUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklyUsages
     * const weeklyUsage = await prisma.weeklyUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WeeklyUsageUpdateManyArgs>(
      args: SelectSubset<T, WeeklyUsageUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WeeklyUsages and returns the data updated in the database.
     * @param {WeeklyUsageUpdateManyAndReturnArgs} args - Arguments to update many WeeklyUsages.
     * @example
     * // Update many WeeklyUsages
     * const weeklyUsage = await prisma.weeklyUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more WeeklyUsages and only return the `id`
     * const weeklyUsageWithIdOnly = await prisma.weeklyUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WeeklyUsageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WeeklyUsageUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one WeeklyUsage.
     * @param {WeeklyUsageUpsertArgs} args - Arguments to update or create a WeeklyUsage.
     * @example
     * // Update or create a WeeklyUsage
     * const weeklyUsage = await prisma.weeklyUsage.upsert({
     *   create: {
     *     // ... data to create a WeeklyUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklyUsage we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyUsageUpsertArgs>(
      args: SelectSubset<T, WeeklyUsageUpsertArgs<ExtArgs>>,
    ): Prisma__WeeklyUsageClient<
      $Result.GetResult<
        Prisma.$WeeklyUsagePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of WeeklyUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyUsageCountArgs} args - Arguments to filter WeeklyUsages to count.
     * @example
     * // Count the number of WeeklyUsages
     * const count = await prisma.weeklyUsage.count({
     *   where: {
     *     // ... the filter for the WeeklyUsages we want to count
     *   }
     * })
     **/
    count<T extends WeeklyUsageCountArgs>(
      args?: Subset<T, WeeklyUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyUsageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a WeeklyUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WeeklyUsageAggregateArgs>(
      args: Subset<T, WeeklyUsageAggregateArgs>,
    ): Prisma.PrismaPromise<GetWeeklyUsageAggregateType<T>>;

    /**
     * Group by WeeklyUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WeeklyUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyUsageGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WeeklyUsageGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetWeeklyUsageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the WeeklyUsage model
     */
    readonly fields: WeeklyUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklyUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyUsageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>,
    ): Prisma__SubscriptionClient<
      | $Result.GetResult<
          Prisma.$SubscriptionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the WeeklyUsage model
   */
  interface WeeklyUsageFieldRefs {
    readonly id: FieldRef<'WeeklyUsage', 'String'>;
    readonly subscriptionId: FieldRef<'WeeklyUsage', 'String'>;
    readonly weekStartDate: FieldRef<'WeeklyUsage', 'DateTime'>;
    readonly uploadCount: FieldRef<'WeeklyUsage', 'Int'>;
    readonly minutesProcessed: FieldRef<'WeeklyUsage', 'Int'>;
  }

  // Custom InputTypes
  /**
   * WeeklyUsage findUnique
   */
  export type WeeklyUsageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    /**
     * Filter, which WeeklyUsage to fetch.
     */
    where: WeeklyUsageWhereUniqueInput;
  };

  /**
   * WeeklyUsage findUniqueOrThrow
   */
  export type WeeklyUsageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    /**
     * Filter, which WeeklyUsage to fetch.
     */
    where: WeeklyUsageWhereUniqueInput;
  };

  /**
   * WeeklyUsage findFirst
   */
  export type WeeklyUsageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    /**
     * Filter, which WeeklyUsage to fetch.
     */
    where?: WeeklyUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WeeklyUsages to fetch.
     */
    orderBy?:
      | WeeklyUsageOrderByWithRelationInput
      | WeeklyUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WeeklyUsages.
     */
    cursor?: WeeklyUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WeeklyUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WeeklyUsages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WeeklyUsages.
     */
    distinct?: WeeklyUsageScalarFieldEnum | WeeklyUsageScalarFieldEnum[];
  };

  /**
   * WeeklyUsage findFirstOrThrow
   */
  export type WeeklyUsageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    /**
     * Filter, which WeeklyUsage to fetch.
     */
    where?: WeeklyUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WeeklyUsages to fetch.
     */
    orderBy?:
      | WeeklyUsageOrderByWithRelationInput
      | WeeklyUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WeeklyUsages.
     */
    cursor?: WeeklyUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WeeklyUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WeeklyUsages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WeeklyUsages.
     */
    distinct?: WeeklyUsageScalarFieldEnum | WeeklyUsageScalarFieldEnum[];
  };

  /**
   * WeeklyUsage findMany
   */
  export type WeeklyUsageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    /**
     * Filter, which WeeklyUsages to fetch.
     */
    where?: WeeklyUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WeeklyUsages to fetch.
     */
    orderBy?:
      | WeeklyUsageOrderByWithRelationInput
      | WeeklyUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing WeeklyUsages.
     */
    cursor?: WeeklyUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WeeklyUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WeeklyUsages.
     */
    skip?: number;
    distinct?: WeeklyUsageScalarFieldEnum | WeeklyUsageScalarFieldEnum[];
  };

  /**
   * WeeklyUsage create
   */
  export type WeeklyUsageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    /**
     * The data needed to create a WeeklyUsage.
     */
    data: XOR<WeeklyUsageCreateInput, WeeklyUsageUncheckedCreateInput>;
  };

  /**
   * WeeklyUsage createMany
   */
  export type WeeklyUsageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many WeeklyUsages.
     */
    data: WeeklyUsageCreateManyInput | WeeklyUsageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * WeeklyUsage createManyAndReturn
   */
  export type WeeklyUsageCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * The data used to create many WeeklyUsages.
     */
    data: WeeklyUsageCreateManyInput | WeeklyUsageCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * WeeklyUsage update
   */
  export type WeeklyUsageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    /**
     * The data needed to update a WeeklyUsage.
     */
    data: XOR<WeeklyUsageUpdateInput, WeeklyUsageUncheckedUpdateInput>;
    /**
     * Choose, which WeeklyUsage to update.
     */
    where: WeeklyUsageWhereUniqueInput;
  };

  /**
   * WeeklyUsage updateMany
   */
  export type WeeklyUsageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update WeeklyUsages.
     */
    data: XOR<
      WeeklyUsageUpdateManyMutationInput,
      WeeklyUsageUncheckedUpdateManyInput
    >;
    /**
     * Filter which WeeklyUsages to update
     */
    where?: WeeklyUsageWhereInput;
    /**
     * Limit how many WeeklyUsages to update.
     */
    limit?: number;
  };

  /**
   * WeeklyUsage updateManyAndReturn
   */
  export type WeeklyUsageUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * The data used to update WeeklyUsages.
     */
    data: XOR<
      WeeklyUsageUpdateManyMutationInput,
      WeeklyUsageUncheckedUpdateManyInput
    >;
    /**
     * Filter which WeeklyUsages to update
     */
    where?: WeeklyUsageWhereInput;
    /**
     * Limit how many WeeklyUsages to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * WeeklyUsage upsert
   */
  export type WeeklyUsageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    /**
     * The filter to search for the WeeklyUsage to update in case it exists.
     */
    where: WeeklyUsageWhereUniqueInput;
    /**
     * In case the WeeklyUsage found by the `where` argument doesn't exist, create a new WeeklyUsage with this data.
     */
    create: XOR<WeeklyUsageCreateInput, WeeklyUsageUncheckedCreateInput>;
    /**
     * In case the WeeklyUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyUsageUpdateInput, WeeklyUsageUncheckedUpdateInput>;
  };

  /**
   * WeeklyUsage delete
   */
  export type WeeklyUsageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
    /**
     * Filter which WeeklyUsage to delete.
     */
    where: WeeklyUsageWhereUniqueInput;
  };

  /**
   * WeeklyUsage deleteMany
   */
  export type WeeklyUsageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WeeklyUsages to delete
     */
    where?: WeeklyUsageWhereInput;
    /**
     * Limit how many WeeklyUsages to delete.
     */
    limit?: number;
  };

  /**
   * WeeklyUsage without action
   */
  export type WeeklyUsageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WeeklyUsage
     */
    select?: WeeklyUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WeeklyUsage
     */
    omit?: WeeklyUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyUsageInclude<ExtArgs> | null;
  };

  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null;
    _avg: MeetingAvgAggregateOutputType | null;
    _sum: MeetingSumAggregateOutputType | null;
    _min: MeetingMinAggregateOutputType | null;
    _max: MeetingMaxAggregateOutputType | null;
  };

  export type MeetingAvgAggregateOutputType = {
    durationSeconds: number | null;
    avgSpeakerConfidence: number | null;
    inaudibleCount: number | null;
    qualityScore: number | null;
  };

  export type MeetingSumAggregateOutputType = {
    durationSeconds: number | null;
    avgSpeakerConfidence: number | null;
    inaudibleCount: number | null;
    qualityScore: number | null;
  };

  export type MeetingMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    calendarConnectionId: string | null;
    title: string | null;
    originalFileName: string | null;
    durationSeconds: number | null;
    fileUrl: string | null;
    status: $Enums.MeetingStatus | null;
    languageCode: string | null;
    transcriptLang: string | null;
    minutesLang: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    avgSpeakerConfidence: number | null;
    inaudibleCount: number | null;
    qualityScore: number | null;
    lastProcessedAt: Date | null;
  };

  export type MeetingMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    calendarConnectionId: string | null;
    title: string | null;
    originalFileName: string | null;
    durationSeconds: number | null;
    fileUrl: string | null;
    status: $Enums.MeetingStatus | null;
    languageCode: string | null;
    transcriptLang: string | null;
    minutesLang: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    avgSpeakerConfidence: number | null;
    inaudibleCount: number | null;
    qualityScore: number | null;
    lastProcessedAt: Date | null;
  };

  export type MeetingCountAggregateOutputType = {
    id: number;
    userId: number;
    organizationId: number;
    calendarConnectionId: number;
    title: number;
    originalFileName: number;
    durationSeconds: number;
    fileUrl: number;
    status: number;
    languageCode: number;
    transcriptLang: number;
    minutesLang: number;
    createdAt: number;
    updatedAt: number;
    avgSpeakerConfidence: number;
    inaudibleCount: number;
    qualityScore: number;
    lastProcessedAt: number;
    _all: number;
  };

  export type MeetingAvgAggregateInputType = {
    durationSeconds?: true;
    avgSpeakerConfidence?: true;
    inaudibleCount?: true;
    qualityScore?: true;
  };

  export type MeetingSumAggregateInputType = {
    durationSeconds?: true;
    avgSpeakerConfidence?: true;
    inaudibleCount?: true;
    qualityScore?: true;
  };

  export type MeetingMinAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    calendarConnectionId?: true;
    title?: true;
    originalFileName?: true;
    durationSeconds?: true;
    fileUrl?: true;
    status?: true;
    languageCode?: true;
    transcriptLang?: true;
    minutesLang?: true;
    createdAt?: true;
    updatedAt?: true;
    avgSpeakerConfidence?: true;
    inaudibleCount?: true;
    qualityScore?: true;
    lastProcessedAt?: true;
  };

  export type MeetingMaxAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    calendarConnectionId?: true;
    title?: true;
    originalFileName?: true;
    durationSeconds?: true;
    fileUrl?: true;
    status?: true;
    languageCode?: true;
    transcriptLang?: true;
    minutesLang?: true;
    createdAt?: true;
    updatedAt?: true;
    avgSpeakerConfidence?: true;
    inaudibleCount?: true;
    qualityScore?: true;
    lastProcessedAt?: true;
  };

  export type MeetingCountAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    calendarConnectionId?: true;
    title?: true;
    originalFileName?: true;
    durationSeconds?: true;
    fileUrl?: true;
    status?: true;
    languageCode?: true;
    transcriptLang?: true;
    minutesLang?: true;
    createdAt?: true;
    updatedAt?: true;
    avgSpeakerConfidence?: true;
    inaudibleCount?: true;
    qualityScore?: true;
    lastProcessedAt?: true;
    _all?: true;
  };

  export type MeetingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Meetings to fetch.
     */
    orderBy?:
      | MeetingOrderByWithRelationInput
      | MeetingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Meetings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Meetings
     **/
    _count?: true | MeetingCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MeetingAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MeetingSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MeetingMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MeetingMaxAggregateInputType;
  };

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
    [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>;
  };

  export type MeetingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MeetingWhereInput;
    orderBy?:
      | MeetingOrderByWithAggregationInput
      | MeetingOrderByWithAggregationInput[];
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum;
    having?: MeetingScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MeetingCountAggregateInputType | true;
    _avg?: MeetingAvgAggregateInputType;
    _sum?: MeetingSumAggregateInputType;
    _min?: MeetingMinAggregateInputType;
    _max?: MeetingMaxAggregateInputType;
  };

  export type MeetingGroupByOutputType = {
    id: string;
    userId: string;
    organizationId: string | null;
    calendarConnectionId: string | null;
    title: string;
    originalFileName: string;
    durationSeconds: number;
    fileUrl: string | null;
    status: $Enums.MeetingStatus;
    languageCode: string | null;
    transcriptLang: string | null;
    minutesLang: string | null;
    createdAt: Date;
    updatedAt: Date;
    avgSpeakerConfidence: number | null;
    inaudibleCount: number;
    qualityScore: number | null;
    lastProcessedAt: Date | null;
    _count: MeetingCountAggregateOutputType | null;
    _avg: MeetingAvgAggregateOutputType | null;
    _sum: MeetingSumAggregateOutputType | null;
    _min: MeetingMinAggregateOutputType | null;
    _max: MeetingMaxAggregateOutputType | null;
  };

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MeetingGroupByOutputType, T['by']> & {
          [P in keyof T & keyof MeetingGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>;
        }
      >
    >;

  export type MeetingSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      calendarConnectionId?: boolean;
      title?: boolean;
      originalFileName?: boolean;
      durationSeconds?: boolean;
      fileUrl?: boolean;
      status?: boolean;
      languageCode?: boolean;
      transcriptLang?: boolean;
      minutesLang?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      avgSpeakerConfidence?: boolean;
      inaudibleCount?: boolean;
      qualityScore?: boolean;
      lastProcessedAt?: boolean;
      keyMoments?: boolean | Meeting$keyMomentsArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | Meeting$organizationArgs<ExtArgs>;
      calendarConnection?: boolean | Meeting$calendarConnectionArgs<ExtArgs>;
      tags?: boolean | Meeting$tagsArgs<ExtArgs>;
      minutes?: boolean | Meeting$minutesArgs<ExtArgs>;
      shareLinks?: boolean | Meeting$shareLinksArgs<ExtArgs>;
      speakers?: boolean | Meeting$speakersArgs<ExtArgs>;
      transcript?: boolean | Meeting$transcriptArgs<ExtArgs>;
      _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['meeting']
  >;

  export type MeetingSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      calendarConnectionId?: boolean;
      title?: boolean;
      originalFileName?: boolean;
      durationSeconds?: boolean;
      fileUrl?: boolean;
      status?: boolean;
      languageCode?: boolean;
      transcriptLang?: boolean;
      minutesLang?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      avgSpeakerConfidence?: boolean;
      inaudibleCount?: boolean;
      qualityScore?: boolean;
      lastProcessedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | Meeting$organizationArgs<ExtArgs>;
      calendarConnection?: boolean | Meeting$calendarConnectionArgs<ExtArgs>;
    },
    ExtArgs['result']['meeting']
  >;

  export type MeetingSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      calendarConnectionId?: boolean;
      title?: boolean;
      originalFileName?: boolean;
      durationSeconds?: boolean;
      fileUrl?: boolean;
      status?: boolean;
      languageCode?: boolean;
      transcriptLang?: boolean;
      minutesLang?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      avgSpeakerConfidence?: boolean;
      inaudibleCount?: boolean;
      qualityScore?: boolean;
      lastProcessedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | Meeting$organizationArgs<ExtArgs>;
      calendarConnection?: boolean | Meeting$calendarConnectionArgs<ExtArgs>;
    },
    ExtArgs['result']['meeting']
  >;

  export type MeetingSelectScalar = {
    id?: boolean;
    userId?: boolean;
    organizationId?: boolean;
    calendarConnectionId?: boolean;
    title?: boolean;
    originalFileName?: boolean;
    durationSeconds?: boolean;
    fileUrl?: boolean;
    status?: boolean;
    languageCode?: boolean;
    transcriptLang?: boolean;
    minutesLang?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    avgSpeakerConfidence?: boolean;
    inaudibleCount?: boolean;
    qualityScore?: boolean;
    lastProcessedAt?: boolean;
  };

  export type MeetingOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'organizationId'
    | 'calendarConnectionId'
    | 'title'
    | 'originalFileName'
    | 'durationSeconds'
    | 'fileUrl'
    | 'status'
    | 'languageCode'
    | 'transcriptLang'
    | 'minutesLang'
    | 'createdAt'
    | 'updatedAt'
    | 'avgSpeakerConfidence'
    | 'inaudibleCount'
    | 'qualityScore'
    | 'lastProcessedAt',
    ExtArgs['result']['meeting']
  >;
  export type MeetingInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    keyMoments?: boolean | Meeting$keyMomentsArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | Meeting$organizationArgs<ExtArgs>;
    calendarConnection?: boolean | Meeting$calendarConnectionArgs<ExtArgs>;
    tags?: boolean | Meeting$tagsArgs<ExtArgs>;
    minutes?: boolean | Meeting$minutesArgs<ExtArgs>;
    shareLinks?: boolean | Meeting$shareLinksArgs<ExtArgs>;
    speakers?: boolean | Meeting$speakersArgs<ExtArgs>;
    transcript?: boolean | Meeting$transcriptArgs<ExtArgs>;
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type MeetingIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | Meeting$organizationArgs<ExtArgs>;
    calendarConnection?: boolean | Meeting$calendarConnectionArgs<ExtArgs>;
  };
  export type MeetingIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | Meeting$organizationArgs<ExtArgs>;
    calendarConnection?: boolean | Meeting$calendarConnectionArgs<ExtArgs>;
  };

  export type $MeetingPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Meeting';
    objects: {
      keyMoments: Prisma.$KeyMomentPayload<ExtArgs>[];
      user: Prisma.$UserPayload<ExtArgs>;
      organization: Prisma.$OrganizationPayload<ExtArgs> | null;
      calendarConnection: Prisma.$CalendarConnectionPayload<ExtArgs> | null;
      tags: Prisma.$MeetingTagPayload<ExtArgs>[];
      minutes: Prisma.$MinutesPayload<ExtArgs> | null;
      shareLinks: Prisma.$ShareLinkPayload<ExtArgs>[];
      speakers: Prisma.$SpeakerPayload<ExtArgs>[];
      transcript: Prisma.$TranscriptSegmentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        organizationId: string | null;
        calendarConnectionId: string | null;
        title: string;
        originalFileName: string;
        durationSeconds: number;
        fileUrl: string | null;
        status: $Enums.MeetingStatus;
        languageCode: string | null;
        transcriptLang: string | null;
        minutesLang: string | null;
        createdAt: Date;
        updatedAt: Date;
        avgSpeakerConfidence: number | null;
        inaudibleCount: number;
        qualityScore: number | null;
        lastProcessedAt: Date | null;
      },
      ExtArgs['result']['meeting']
    >;
    composites: {};
  };

  type MeetingGetPayload<
    S extends boolean | null | undefined | MeetingDefaultArgs,
  > = $Result.GetResult<Prisma.$MeetingPayload, S>;

  type MeetingCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MeetingCountAggregateInputType | true;
  };

  export interface MeetingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Meeting'];
      meta: { name: 'Meeting' };
    };
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(
      args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(
      args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     *
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MeetingFindManyArgs>(
      args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     *
     */
    create<T extends MeetingCreateArgs>(
      args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MeetingCreateManyArgs>(
      args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Meetings and returns the data saved in the database.
     * @param {MeetingCreateManyAndReturnArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MeetingCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MeetingCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     *
     */
    delete<T extends MeetingDeleteArgs>(
      args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MeetingUpdateArgs>(
      args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MeetingDeleteManyArgs>(
      args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MeetingUpdateManyArgs>(
      args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Meetings and returns the data updated in the database.
     * @param {MeetingUpdateManyAndReturnArgs} args - Arguments to update many Meetings.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MeetingUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MeetingUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(
      args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      $Result.GetResult<
        Prisma.$MeetingPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
     **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MeetingAggregateArgs>(
      args: Subset<T, MeetingAggregateArgs>,
    ): Prisma.PrismaPromise<GetMeetingAggregateType<T>>;

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetMeetingGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Meeting model
     */
    readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    keyMoments<T extends Meeting$keyMomentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Meeting$keyMomentsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$KeyMomentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends Meeting$organizationArgs<ExtArgs> = {}>(
      args?: Subset<T, Meeting$organizationArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    calendarConnection<T extends Meeting$calendarConnectionArgs<ExtArgs> = {}>(
      args?: Subset<T, Meeting$calendarConnectionArgs<ExtArgs>>,
    ): Prisma__CalendarConnectionClient<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tags<T extends Meeting$tagsArgs<ExtArgs> = {}>(
      args?: Subset<T, Meeting$tagsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MeetingTagPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    minutes<T extends Meeting$minutesArgs<ExtArgs> = {}>(
      args?: Subset<T, Meeting$minutesArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    shareLinks<T extends Meeting$shareLinksArgs<ExtArgs> = {}>(
      args?: Subset<T, Meeting$shareLinksArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ShareLinkPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    speakers<T extends Meeting$speakersArgs<ExtArgs> = {}>(
      args?: Subset<T, Meeting$speakersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SpeakerPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    transcript<T extends Meeting$transcriptArgs<ExtArgs> = {}>(
      args?: Subset<T, Meeting$transcriptArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TranscriptSegmentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Meeting model
   */
  interface MeetingFieldRefs {
    readonly id: FieldRef<'Meeting', 'String'>;
    readonly userId: FieldRef<'Meeting', 'String'>;
    readonly organizationId: FieldRef<'Meeting', 'String'>;
    readonly calendarConnectionId: FieldRef<'Meeting', 'String'>;
    readonly title: FieldRef<'Meeting', 'String'>;
    readonly originalFileName: FieldRef<'Meeting', 'String'>;
    readonly durationSeconds: FieldRef<'Meeting', 'Int'>;
    readonly fileUrl: FieldRef<'Meeting', 'String'>;
    readonly status: FieldRef<'Meeting', 'MeetingStatus'>;
    readonly languageCode: FieldRef<'Meeting', 'String'>;
    readonly transcriptLang: FieldRef<'Meeting', 'String'>;
    readonly minutesLang: FieldRef<'Meeting', 'String'>;
    readonly createdAt: FieldRef<'Meeting', 'DateTime'>;
    readonly updatedAt: FieldRef<'Meeting', 'DateTime'>;
    readonly avgSpeakerConfidence: FieldRef<'Meeting', 'Float'>;
    readonly inaudibleCount: FieldRef<'Meeting', 'Int'>;
    readonly qualityScore: FieldRef<'Meeting', 'Float'>;
    readonly lastProcessedAt: FieldRef<'Meeting', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput;
  };

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput;
  };

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Meetings to fetch.
     */
    orderBy?:
      | MeetingOrderByWithRelationInput
      | MeetingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Meetings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[];
  };

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Meetings to fetch.
     */
    orderBy?:
      | MeetingOrderByWithRelationInput
      | MeetingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Meetings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[];
  };

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Meetings to fetch.
     */
    orderBy?:
      | MeetingOrderByWithRelationInput
      | MeetingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Meetings.
     */
    skip?: number;
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[];
  };

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>;
  };

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Meeting createManyAndReturn
   */
  export type MeetingCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>;
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput;
  };

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>;
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput;
    /**
     * Limit how many Meetings to update.
     */
    limit?: number;
  };

  /**
   * Meeting updateManyAndReturn
   */
  export type MeetingUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>;
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput;
    /**
     * Limit how many Meetings to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput;
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>;
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>;
  };

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput;
  };

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput;
    /**
     * Limit how many Meetings to delete.
     */
    limit?: number;
  };

  /**
   * Meeting.keyMoments
   */
  export type Meeting$keyMomentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    where?: KeyMomentWhereInput;
    orderBy?:
      | KeyMomentOrderByWithRelationInput
      | KeyMomentOrderByWithRelationInput[];
    cursor?: KeyMomentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: KeyMomentScalarFieldEnum | KeyMomentScalarFieldEnum[];
  };

  /**
   * Meeting.organization
   */
  export type Meeting$organizationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    where?: OrganizationWhereInput;
  };

  /**
   * Meeting.calendarConnection
   */
  export type Meeting$calendarConnectionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    where?: CalendarConnectionWhereInput;
  };

  /**
   * Meeting.tags
   */
  export type Meeting$tagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    where?: MeetingTagWhereInput;
    orderBy?:
      | MeetingTagOrderByWithRelationInput
      | MeetingTagOrderByWithRelationInput[];
    cursor?: MeetingTagWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MeetingTagScalarFieldEnum | MeetingTagScalarFieldEnum[];
  };

  /**
   * Meeting.minutes
   */
  export type Meeting$minutesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    where?: MinutesWhereInput;
  };

  /**
   * Meeting.shareLinks
   */
  export type Meeting$shareLinksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    where?: ShareLinkWhereInput;
    orderBy?:
      | ShareLinkOrderByWithRelationInput
      | ShareLinkOrderByWithRelationInput[];
    cursor?: ShareLinkWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[];
  };

  /**
   * Meeting.speakers
   */
  export type Meeting$speakersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    where?: SpeakerWhereInput;
    orderBy?:
      | SpeakerOrderByWithRelationInput
      | SpeakerOrderByWithRelationInput[];
    cursor?: SpeakerWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[];
  };

  /**
   * Meeting.transcript
   */
  export type Meeting$transcriptArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    where?: TranscriptSegmentWhereInput;
    orderBy?:
      | TranscriptSegmentOrderByWithRelationInput
      | TranscriptSegmentOrderByWithRelationInput[];
    cursor?: TranscriptSegmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | TranscriptSegmentScalarFieldEnum
      | TranscriptSegmentScalarFieldEnum[];
  };

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
  };

  /**
   * Model KeyMoment
   */

  export type AggregateKeyMoment = {
    _count: KeyMomentCountAggregateOutputType | null;
    _avg: KeyMomentAvgAggregateOutputType | null;
    _sum: KeyMomentSumAggregateOutputType | null;
    _min: KeyMomentMinAggregateOutputType | null;
    _max: KeyMomentMaxAggregateOutputType | null;
  };

  export type KeyMomentAvgAggregateOutputType = {
    timestamp: number | null;
  };

  export type KeyMomentSumAggregateOutputType = {
    timestamp: number | null;
  };

  export type KeyMomentMinAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    timestamp: number | null;
    label: string | null;
    description: string | null;
    type: $Enums.MomentType | null;
    isAutomatic: boolean | null;
    createdBy: string | null;
    createdAt: Date | null;
  };

  export type KeyMomentMaxAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    timestamp: number | null;
    label: string | null;
    description: string | null;
    type: $Enums.MomentType | null;
    isAutomatic: boolean | null;
    createdBy: string | null;
    createdAt: Date | null;
  };

  export type KeyMomentCountAggregateOutputType = {
    id: number;
    meetingId: number;
    timestamp: number;
    label: number;
    description: number;
    type: number;
    isAutomatic: number;
    createdBy: number;
    createdAt: number;
    _all: number;
  };

  export type KeyMomentAvgAggregateInputType = {
    timestamp?: true;
  };

  export type KeyMomentSumAggregateInputType = {
    timestamp?: true;
  };

  export type KeyMomentMinAggregateInputType = {
    id?: true;
    meetingId?: true;
    timestamp?: true;
    label?: true;
    description?: true;
    type?: true;
    isAutomatic?: true;
    createdBy?: true;
    createdAt?: true;
  };

  export type KeyMomentMaxAggregateInputType = {
    id?: true;
    meetingId?: true;
    timestamp?: true;
    label?: true;
    description?: true;
    type?: true;
    isAutomatic?: true;
    createdBy?: true;
    createdAt?: true;
  };

  export type KeyMomentCountAggregateInputType = {
    id?: true;
    meetingId?: true;
    timestamp?: true;
    label?: true;
    description?: true;
    type?: true;
    isAutomatic?: true;
    createdBy?: true;
    createdAt?: true;
    _all?: true;
  };

  export type KeyMomentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which KeyMoment to aggregate.
     */
    where?: KeyMomentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of KeyMoments to fetch.
     */
    orderBy?:
      | KeyMomentOrderByWithRelationInput
      | KeyMomentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: KeyMomentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` KeyMoments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` KeyMoments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned KeyMoments
     **/
    _count?: true | KeyMomentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: KeyMomentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: KeyMomentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: KeyMomentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: KeyMomentMaxAggregateInputType;
  };

  export type GetKeyMomentAggregateType<T extends KeyMomentAggregateArgs> = {
    [P in keyof T & keyof AggregateKeyMoment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyMoment[P]>
      : GetScalarType<T[P], AggregateKeyMoment[P]>;
  };

  export type KeyMomentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: KeyMomentWhereInput;
    orderBy?:
      | KeyMomentOrderByWithAggregationInput
      | KeyMomentOrderByWithAggregationInput[];
    by: KeyMomentScalarFieldEnum[] | KeyMomentScalarFieldEnum;
    having?: KeyMomentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: KeyMomentCountAggregateInputType | true;
    _avg?: KeyMomentAvgAggregateInputType;
    _sum?: KeyMomentSumAggregateInputType;
    _min?: KeyMomentMinAggregateInputType;
    _max?: KeyMomentMaxAggregateInputType;
  };

  export type KeyMomentGroupByOutputType = {
    id: string;
    meetingId: string;
    timestamp: number;
    label: string;
    description: string | null;
    type: $Enums.MomentType;
    isAutomatic: boolean;
    createdBy: string | null;
    createdAt: Date;
    _count: KeyMomentCountAggregateOutputType | null;
    _avg: KeyMomentAvgAggregateOutputType | null;
    _sum: KeyMomentSumAggregateOutputType | null;
    _min: KeyMomentMinAggregateOutputType | null;
    _max: KeyMomentMaxAggregateOutputType | null;
  };

  type GetKeyMomentGroupByPayload<T extends KeyMomentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<KeyMomentGroupByOutputType, T['by']> & {
          [P in keyof T & keyof KeyMomentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeyMomentGroupByOutputType[P]>
            : GetScalarType<T[P], KeyMomentGroupByOutputType[P]>;
        }
      >
    >;

  export type KeyMomentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      timestamp?: boolean;
      label?: boolean;
      description?: boolean;
      type?: boolean;
      isAutomatic?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['keyMoment']
  >;

  export type KeyMomentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      timestamp?: boolean;
      label?: boolean;
      description?: boolean;
      type?: boolean;
      isAutomatic?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['keyMoment']
  >;

  export type KeyMomentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      timestamp?: boolean;
      label?: boolean;
      description?: boolean;
      type?: boolean;
      isAutomatic?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['keyMoment']
  >;

  export type KeyMomentSelectScalar = {
    id?: boolean;
    meetingId?: boolean;
    timestamp?: boolean;
    label?: boolean;
    description?: boolean;
    type?: boolean;
    isAutomatic?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
  };

  export type KeyMomentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'meetingId'
    | 'timestamp'
    | 'label'
    | 'description'
    | 'type'
    | 'isAutomatic'
    | 'createdBy'
    | 'createdAt',
    ExtArgs['result']['keyMoment']
  >;
  export type KeyMomentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
  };
  export type KeyMomentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
  };
  export type KeyMomentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
  };

  export type $KeyMomentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'KeyMoment';
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        meetingId: string;
        timestamp: number;
        label: string;
        description: string | null;
        type: $Enums.MomentType;
        isAutomatic: boolean;
        createdBy: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['keyMoment']
    >;
    composites: {};
  };

  type KeyMomentGetPayload<
    S extends boolean | null | undefined | KeyMomentDefaultArgs,
  > = $Result.GetResult<Prisma.$KeyMomentPayload, S>;

  type KeyMomentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    KeyMomentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: KeyMomentCountAggregateInputType | true;
  };

  export interface KeyMomentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['KeyMoment'];
      meta: { name: 'KeyMoment' };
    };
    /**
     * Find zero or one KeyMoment that matches the filter.
     * @param {KeyMomentFindUniqueArgs} args - Arguments to find a KeyMoment
     * @example
     * // Get one KeyMoment
     * const keyMoment = await prisma.keyMoment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeyMomentFindUniqueArgs>(
      args: SelectSubset<T, KeyMomentFindUniqueArgs<ExtArgs>>,
    ): Prisma__KeyMomentClient<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one KeyMoment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeyMomentFindUniqueOrThrowArgs} args - Arguments to find a KeyMoment
     * @example
     * // Get one KeyMoment
     * const keyMoment = await prisma.keyMoment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeyMomentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, KeyMomentFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__KeyMomentClient<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first KeyMoment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyMomentFindFirstArgs} args - Arguments to find a KeyMoment
     * @example
     * // Get one KeyMoment
     * const keyMoment = await prisma.keyMoment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeyMomentFindFirstArgs>(
      args?: SelectSubset<T, KeyMomentFindFirstArgs<ExtArgs>>,
    ): Prisma__KeyMomentClient<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first KeyMoment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyMomentFindFirstOrThrowArgs} args - Arguments to find a KeyMoment
     * @example
     * // Get one KeyMoment
     * const keyMoment = await prisma.keyMoment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeyMomentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KeyMomentFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__KeyMomentClient<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more KeyMoments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyMomentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeyMoments
     * const keyMoments = await prisma.keyMoment.findMany()
     *
     * // Get first 10 KeyMoments
     * const keyMoments = await prisma.keyMoment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const keyMomentWithIdOnly = await prisma.keyMoment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends KeyMomentFindManyArgs>(
      args?: SelectSubset<T, KeyMomentFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a KeyMoment.
     * @param {KeyMomentCreateArgs} args - Arguments to create a KeyMoment.
     * @example
     * // Create one KeyMoment
     * const KeyMoment = await prisma.keyMoment.create({
     *   data: {
     *     // ... data to create a KeyMoment
     *   }
     * })
     *
     */
    create<T extends KeyMomentCreateArgs>(
      args: SelectSubset<T, KeyMomentCreateArgs<ExtArgs>>,
    ): Prisma__KeyMomentClient<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many KeyMoments.
     * @param {KeyMomentCreateManyArgs} args - Arguments to create many KeyMoments.
     * @example
     * // Create many KeyMoments
     * const keyMoment = await prisma.keyMoment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends KeyMomentCreateManyArgs>(
      args?: SelectSubset<T, KeyMomentCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many KeyMoments and returns the data saved in the database.
     * @param {KeyMomentCreateManyAndReturnArgs} args - Arguments to create many KeyMoments.
     * @example
     * // Create many KeyMoments
     * const keyMoment = await prisma.keyMoment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many KeyMoments and only return the `id`
     * const keyMomentWithIdOnly = await prisma.keyMoment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends KeyMomentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, KeyMomentCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a KeyMoment.
     * @param {KeyMomentDeleteArgs} args - Arguments to delete one KeyMoment.
     * @example
     * // Delete one KeyMoment
     * const KeyMoment = await prisma.keyMoment.delete({
     *   where: {
     *     // ... filter to delete one KeyMoment
     *   }
     * })
     *
     */
    delete<T extends KeyMomentDeleteArgs>(
      args: SelectSubset<T, KeyMomentDeleteArgs<ExtArgs>>,
    ): Prisma__KeyMomentClient<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one KeyMoment.
     * @param {KeyMomentUpdateArgs} args - Arguments to update one KeyMoment.
     * @example
     * // Update one KeyMoment
     * const keyMoment = await prisma.keyMoment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends KeyMomentUpdateArgs>(
      args: SelectSubset<T, KeyMomentUpdateArgs<ExtArgs>>,
    ): Prisma__KeyMomentClient<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more KeyMoments.
     * @param {KeyMomentDeleteManyArgs} args - Arguments to filter KeyMoments to delete.
     * @example
     * // Delete a few KeyMoments
     * const { count } = await prisma.keyMoment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends KeyMomentDeleteManyArgs>(
      args?: SelectSubset<T, KeyMomentDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more KeyMoments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyMomentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeyMoments
     * const keyMoment = await prisma.keyMoment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends KeyMomentUpdateManyArgs>(
      args: SelectSubset<T, KeyMomentUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more KeyMoments and returns the data updated in the database.
     * @param {KeyMomentUpdateManyAndReturnArgs} args - Arguments to update many KeyMoments.
     * @example
     * // Update many KeyMoments
     * const keyMoment = await prisma.keyMoment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more KeyMoments and only return the `id`
     * const keyMomentWithIdOnly = await prisma.keyMoment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends KeyMomentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, KeyMomentUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one KeyMoment.
     * @param {KeyMomentUpsertArgs} args - Arguments to update or create a KeyMoment.
     * @example
     * // Update or create a KeyMoment
     * const keyMoment = await prisma.keyMoment.upsert({
     *   create: {
     *     // ... data to create a KeyMoment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeyMoment we want to update
     *   }
     * })
     */
    upsert<T extends KeyMomentUpsertArgs>(
      args: SelectSubset<T, KeyMomentUpsertArgs<ExtArgs>>,
    ): Prisma__KeyMomentClient<
      $Result.GetResult<
        Prisma.$KeyMomentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of KeyMoments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyMomentCountArgs} args - Arguments to filter KeyMoments to count.
     * @example
     * // Count the number of KeyMoments
     * const count = await prisma.keyMoment.count({
     *   where: {
     *     // ... the filter for the KeyMoments we want to count
     *   }
     * })
     **/
    count<T extends KeyMomentCountArgs>(
      args?: Subset<T, KeyMomentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeyMomentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a KeyMoment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyMomentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends KeyMomentAggregateArgs>(
      args: Subset<T, KeyMomentAggregateArgs>,
    ): Prisma.PrismaPromise<GetKeyMomentAggregateType<T>>;

    /**
     * Group by KeyMoment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyMomentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends KeyMomentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeyMomentGroupByArgs['orderBy'] }
        : { orderBy?: KeyMomentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, KeyMomentGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetKeyMomentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the KeyMoment model
     */
    readonly fields: KeyMomentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeyMoment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeyMomentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MeetingDefaultArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      | $Result.GetResult<
          Prisma.$MeetingPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the KeyMoment model
   */
  interface KeyMomentFieldRefs {
    readonly id: FieldRef<'KeyMoment', 'String'>;
    readonly meetingId: FieldRef<'KeyMoment', 'String'>;
    readonly timestamp: FieldRef<'KeyMoment', 'Float'>;
    readonly label: FieldRef<'KeyMoment', 'String'>;
    readonly description: FieldRef<'KeyMoment', 'String'>;
    readonly type: FieldRef<'KeyMoment', 'MomentType'>;
    readonly isAutomatic: FieldRef<'KeyMoment', 'Boolean'>;
    readonly createdBy: FieldRef<'KeyMoment', 'String'>;
    readonly createdAt: FieldRef<'KeyMoment', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * KeyMoment findUnique
   */
  export type KeyMomentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    /**
     * Filter, which KeyMoment to fetch.
     */
    where: KeyMomentWhereUniqueInput;
  };

  /**
   * KeyMoment findUniqueOrThrow
   */
  export type KeyMomentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    /**
     * Filter, which KeyMoment to fetch.
     */
    where: KeyMomentWhereUniqueInput;
  };

  /**
   * KeyMoment findFirst
   */
  export type KeyMomentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    /**
     * Filter, which KeyMoment to fetch.
     */
    where?: KeyMomentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of KeyMoments to fetch.
     */
    orderBy?:
      | KeyMomentOrderByWithRelationInput
      | KeyMomentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for KeyMoments.
     */
    cursor?: KeyMomentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` KeyMoments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` KeyMoments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of KeyMoments.
     */
    distinct?: KeyMomentScalarFieldEnum | KeyMomentScalarFieldEnum[];
  };

  /**
   * KeyMoment findFirstOrThrow
   */
  export type KeyMomentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    /**
     * Filter, which KeyMoment to fetch.
     */
    where?: KeyMomentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of KeyMoments to fetch.
     */
    orderBy?:
      | KeyMomentOrderByWithRelationInput
      | KeyMomentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for KeyMoments.
     */
    cursor?: KeyMomentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` KeyMoments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` KeyMoments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of KeyMoments.
     */
    distinct?: KeyMomentScalarFieldEnum | KeyMomentScalarFieldEnum[];
  };

  /**
   * KeyMoment findMany
   */
  export type KeyMomentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    /**
     * Filter, which KeyMoments to fetch.
     */
    where?: KeyMomentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of KeyMoments to fetch.
     */
    orderBy?:
      | KeyMomentOrderByWithRelationInput
      | KeyMomentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing KeyMoments.
     */
    cursor?: KeyMomentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` KeyMoments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` KeyMoments.
     */
    skip?: number;
    distinct?: KeyMomentScalarFieldEnum | KeyMomentScalarFieldEnum[];
  };

  /**
   * KeyMoment create
   */
  export type KeyMomentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    /**
     * The data needed to create a KeyMoment.
     */
    data: XOR<KeyMomentCreateInput, KeyMomentUncheckedCreateInput>;
  };

  /**
   * KeyMoment createMany
   */
  export type KeyMomentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many KeyMoments.
     */
    data: KeyMomentCreateManyInput | KeyMomentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * KeyMoment createManyAndReturn
   */
  export type KeyMomentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * The data used to create many KeyMoments.
     */
    data: KeyMomentCreateManyInput | KeyMomentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * KeyMoment update
   */
  export type KeyMomentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    /**
     * The data needed to update a KeyMoment.
     */
    data: XOR<KeyMomentUpdateInput, KeyMomentUncheckedUpdateInput>;
    /**
     * Choose, which KeyMoment to update.
     */
    where: KeyMomentWhereUniqueInput;
  };

  /**
   * KeyMoment updateMany
   */
  export type KeyMomentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update KeyMoments.
     */
    data: XOR<
      KeyMomentUpdateManyMutationInput,
      KeyMomentUncheckedUpdateManyInput
    >;
    /**
     * Filter which KeyMoments to update
     */
    where?: KeyMomentWhereInput;
    /**
     * Limit how many KeyMoments to update.
     */
    limit?: number;
  };

  /**
   * KeyMoment updateManyAndReturn
   */
  export type KeyMomentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * The data used to update KeyMoments.
     */
    data: XOR<
      KeyMomentUpdateManyMutationInput,
      KeyMomentUncheckedUpdateManyInput
    >;
    /**
     * Filter which KeyMoments to update
     */
    where?: KeyMomentWhereInput;
    /**
     * Limit how many KeyMoments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * KeyMoment upsert
   */
  export type KeyMomentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    /**
     * The filter to search for the KeyMoment to update in case it exists.
     */
    where: KeyMomentWhereUniqueInput;
    /**
     * In case the KeyMoment found by the `where` argument doesn't exist, create a new KeyMoment with this data.
     */
    create: XOR<KeyMomentCreateInput, KeyMomentUncheckedCreateInput>;
    /**
     * In case the KeyMoment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeyMomentUpdateInput, KeyMomentUncheckedUpdateInput>;
  };

  /**
   * KeyMoment delete
   */
  export type KeyMomentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
    /**
     * Filter which KeyMoment to delete.
     */
    where: KeyMomentWhereUniqueInput;
  };

  /**
   * KeyMoment deleteMany
   */
  export type KeyMomentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which KeyMoments to delete
     */
    where?: KeyMomentWhereInput;
    /**
     * Limit how many KeyMoments to delete.
     */
    limit?: number;
  };

  /**
   * KeyMoment without action
   */
  export type KeyMomentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the KeyMoment
     */
    select?: KeyMomentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the KeyMoment
     */
    omit?: KeyMomentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyMomentInclude<ExtArgs> | null;
  };

  /**
   * Model TranscriptSegment
   */

  export type AggregateTranscriptSegment = {
    _count: TranscriptSegmentCountAggregateOutputType | null;
    _avg: TranscriptSegmentAvgAggregateOutputType | null;
    _sum: TranscriptSegmentSumAggregateOutputType | null;
    _min: TranscriptSegmentMinAggregateOutputType | null;
    _max: TranscriptSegmentMaxAggregateOutputType | null;
  };

  export type TranscriptSegmentAvgAggregateOutputType = {
    startTime: number | null;
    endTime: number | null;
  };

  export type TranscriptSegmentSumAggregateOutputType = {
    startTime: number | null;
    endTime: number | null;
  };

  export type TranscriptSegmentMinAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    speakerId: string | null;
    startTime: number | null;
    endTime: number | null;
    text: string | null;
    originalText: string | null;
  };

  export type TranscriptSegmentMaxAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    speakerId: string | null;
    startTime: number | null;
    endTime: number | null;
    text: string | null;
    originalText: string | null;
  };

  export type TranscriptSegmentCountAggregateOutputType = {
    id: number;
    meetingId: number;
    speakerId: number;
    startTime: number;
    endTime: number;
    text: number;
    languagesUsed: number;
    originalText: number;
    _all: number;
  };

  export type TranscriptSegmentAvgAggregateInputType = {
    startTime?: true;
    endTime?: true;
  };

  export type TranscriptSegmentSumAggregateInputType = {
    startTime?: true;
    endTime?: true;
  };

  export type TranscriptSegmentMinAggregateInputType = {
    id?: true;
    meetingId?: true;
    speakerId?: true;
    startTime?: true;
    endTime?: true;
    text?: true;
    originalText?: true;
  };

  export type TranscriptSegmentMaxAggregateInputType = {
    id?: true;
    meetingId?: true;
    speakerId?: true;
    startTime?: true;
    endTime?: true;
    text?: true;
    originalText?: true;
  };

  export type TranscriptSegmentCountAggregateInputType = {
    id?: true;
    meetingId?: true;
    speakerId?: true;
    startTime?: true;
    endTime?: true;
    text?: true;
    languagesUsed?: true;
    originalText?: true;
    _all?: true;
  };

  export type TranscriptSegmentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TranscriptSegment to aggregate.
     */
    where?: TranscriptSegmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TranscriptSegments to fetch.
     */
    orderBy?:
      | TranscriptSegmentOrderByWithRelationInput
      | TranscriptSegmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TranscriptSegmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TranscriptSegments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TranscriptSegments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TranscriptSegments
     **/
    _count?: true | TranscriptSegmentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TranscriptSegmentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TranscriptSegmentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TranscriptSegmentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TranscriptSegmentMaxAggregateInputType;
  };

  export type GetTranscriptSegmentAggregateType<
    T extends TranscriptSegmentAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateTranscriptSegment]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptSegment[P]>
      : GetScalarType<T[P], AggregateTranscriptSegment[P]>;
  };

  export type TranscriptSegmentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TranscriptSegmentWhereInput;
    orderBy?:
      | TranscriptSegmentOrderByWithAggregationInput
      | TranscriptSegmentOrderByWithAggregationInput[];
    by: TranscriptSegmentScalarFieldEnum[] | TranscriptSegmentScalarFieldEnum;
    having?: TranscriptSegmentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TranscriptSegmentCountAggregateInputType | true;
    _avg?: TranscriptSegmentAvgAggregateInputType;
    _sum?: TranscriptSegmentSumAggregateInputType;
    _min?: TranscriptSegmentMinAggregateInputType;
    _max?: TranscriptSegmentMaxAggregateInputType;
  };

  export type TranscriptSegmentGroupByOutputType = {
    id: string;
    meetingId: string;
    speakerId: string | null;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed: string[];
    originalText: string | null;
    _count: TranscriptSegmentCountAggregateOutputType | null;
    _avg: TranscriptSegmentAvgAggregateOutputType | null;
    _sum: TranscriptSegmentSumAggregateOutputType | null;
    _min: TranscriptSegmentMinAggregateOutputType | null;
    _max: TranscriptSegmentMaxAggregateOutputType | null;
  };

  type GetTranscriptSegmentGroupByPayload<
    T extends TranscriptSegmentGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptSegmentGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof TranscriptSegmentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TranscriptSegmentGroupByOutputType[P]>
          : GetScalarType<T[P], TranscriptSegmentGroupByOutputType[P]>;
      }
    >
  >;

  export type TranscriptSegmentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      speakerId?: boolean;
      startTime?: boolean;
      endTime?: boolean;
      text?: boolean;
      languagesUsed?: boolean;
      originalText?: boolean;
      edits?: boolean | TranscriptSegment$editsArgs<ExtArgs>;
      corrections?: boolean | TranscriptSegment$correctionsArgs<ExtArgs>;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      speaker?: boolean | TranscriptSegment$speakerArgs<ExtArgs>;
      _count?: boolean | TranscriptSegmentCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['transcriptSegment']
  >;

  export type TranscriptSegmentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      speakerId?: boolean;
      startTime?: boolean;
      endTime?: boolean;
      text?: boolean;
      languagesUsed?: boolean;
      originalText?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      speaker?: boolean | TranscriptSegment$speakerArgs<ExtArgs>;
    },
    ExtArgs['result']['transcriptSegment']
  >;

  export type TranscriptSegmentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      speakerId?: boolean;
      startTime?: boolean;
      endTime?: boolean;
      text?: boolean;
      languagesUsed?: boolean;
      originalText?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      speaker?: boolean | TranscriptSegment$speakerArgs<ExtArgs>;
    },
    ExtArgs['result']['transcriptSegment']
  >;

  export type TranscriptSegmentSelectScalar = {
    id?: boolean;
    meetingId?: boolean;
    speakerId?: boolean;
    startTime?: boolean;
    endTime?: boolean;
    text?: boolean;
    languagesUsed?: boolean;
    originalText?: boolean;
  };

  export type TranscriptSegmentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'meetingId'
    | 'speakerId'
    | 'startTime'
    | 'endTime'
    | 'text'
    | 'languagesUsed'
    | 'originalText',
    ExtArgs['result']['transcriptSegment']
  >;
  export type TranscriptSegmentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    edits?: boolean | TranscriptSegment$editsArgs<ExtArgs>;
    corrections?: boolean | TranscriptSegment$correctionsArgs<ExtArgs>;
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    speaker?: boolean | TranscriptSegment$speakerArgs<ExtArgs>;
    _count?: boolean | TranscriptSegmentCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type TranscriptSegmentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    speaker?: boolean | TranscriptSegment$speakerArgs<ExtArgs>;
  };
  export type TranscriptSegmentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    speaker?: boolean | TranscriptSegment$speakerArgs<ExtArgs>;
  };

  export type $TranscriptSegmentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'TranscriptSegment';
    objects: {
      edits: Prisma.$SegmentEditPayload<ExtArgs>[];
      corrections: Prisma.$TranscriptCorrectionPayload<ExtArgs>[];
      meeting: Prisma.$MeetingPayload<ExtArgs>;
      speaker: Prisma.$SpeakerPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        meetingId: string;
        speakerId: string | null;
        startTime: number;
        endTime: number;
        text: string;
        languagesUsed: string[];
        originalText: string | null;
      },
      ExtArgs['result']['transcriptSegment']
    >;
    composites: {};
  };

  type TranscriptSegmentGetPayload<
    S extends boolean | null | undefined | TranscriptSegmentDefaultArgs,
  > = $Result.GetResult<Prisma.$TranscriptSegmentPayload, S>;

  type TranscriptSegmentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    TranscriptSegmentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: TranscriptSegmentCountAggregateInputType | true;
  };

  export interface TranscriptSegmentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TranscriptSegment'];
      meta: { name: 'TranscriptSegment' };
    };
    /**
     * Find zero or one TranscriptSegment that matches the filter.
     * @param {TranscriptSegmentFindUniqueArgs} args - Arguments to find a TranscriptSegment
     * @example
     * // Get one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptSegmentFindUniqueArgs>(
      args: SelectSubset<T, TranscriptSegmentFindUniqueArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TranscriptSegment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptSegmentFindUniqueOrThrowArgs} args - Arguments to find a TranscriptSegment
     * @example
     * // Get one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptSegmentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TranscriptSegmentFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TranscriptSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentFindFirstArgs} args - Arguments to find a TranscriptSegment
     * @example
     * // Get one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptSegmentFindFirstArgs>(
      args?: SelectSubset<T, TranscriptSegmentFindFirstArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TranscriptSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentFindFirstOrThrowArgs} args - Arguments to find a TranscriptSegment
     * @example
     * // Get one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptSegmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TranscriptSegmentFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TranscriptSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptSegments
     * const transcriptSegments = await prisma.transcriptSegment.findMany()
     *
     * // Get first 10 TranscriptSegments
     * const transcriptSegments = await prisma.transcriptSegment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const transcriptSegmentWithIdOnly = await prisma.transcriptSegment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TranscriptSegmentFindManyArgs>(
      args?: SelectSubset<T, TranscriptSegmentFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TranscriptSegment.
     * @param {TranscriptSegmentCreateArgs} args - Arguments to create a TranscriptSegment.
     * @example
     * // Create one TranscriptSegment
     * const TranscriptSegment = await prisma.transcriptSegment.create({
     *   data: {
     *     // ... data to create a TranscriptSegment
     *   }
     * })
     *
     */
    create<T extends TranscriptSegmentCreateArgs>(
      args: SelectSubset<T, TranscriptSegmentCreateArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TranscriptSegments.
     * @param {TranscriptSegmentCreateManyArgs} args - Arguments to create many TranscriptSegments.
     * @example
     * // Create many TranscriptSegments
     * const transcriptSegment = await prisma.transcriptSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TranscriptSegmentCreateManyArgs>(
      args?: SelectSubset<T, TranscriptSegmentCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many TranscriptSegments and returns the data saved in the database.
     * @param {TranscriptSegmentCreateManyAndReturnArgs} args - Arguments to create many TranscriptSegments.
     * @example
     * // Create many TranscriptSegments
     * const transcriptSegment = await prisma.transcriptSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TranscriptSegments and only return the `id`
     * const transcriptSegmentWithIdOnly = await prisma.transcriptSegment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TranscriptSegmentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TranscriptSegmentCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a TranscriptSegment.
     * @param {TranscriptSegmentDeleteArgs} args - Arguments to delete one TranscriptSegment.
     * @example
     * // Delete one TranscriptSegment
     * const TranscriptSegment = await prisma.transcriptSegment.delete({
     *   where: {
     *     // ... filter to delete one TranscriptSegment
     *   }
     * })
     *
     */
    delete<T extends TranscriptSegmentDeleteArgs>(
      args: SelectSubset<T, TranscriptSegmentDeleteArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TranscriptSegment.
     * @param {TranscriptSegmentUpdateArgs} args - Arguments to update one TranscriptSegment.
     * @example
     * // Update one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TranscriptSegmentUpdateArgs>(
      args: SelectSubset<T, TranscriptSegmentUpdateArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TranscriptSegments.
     * @param {TranscriptSegmentDeleteManyArgs} args - Arguments to filter TranscriptSegments to delete.
     * @example
     * // Delete a few TranscriptSegments
     * const { count } = await prisma.transcriptSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TranscriptSegmentDeleteManyArgs>(
      args?: SelectSubset<T, TranscriptSegmentDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TranscriptSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptSegments
     * const transcriptSegment = await prisma.transcriptSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TranscriptSegmentUpdateManyArgs>(
      args: SelectSubset<T, TranscriptSegmentUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TranscriptSegments and returns the data updated in the database.
     * @param {TranscriptSegmentUpdateManyAndReturnArgs} args - Arguments to update many TranscriptSegments.
     * @example
     * // Update many TranscriptSegments
     * const transcriptSegment = await prisma.transcriptSegment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more TranscriptSegments and only return the `id`
     * const transcriptSegmentWithIdOnly = await prisma.transcriptSegment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TranscriptSegmentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TranscriptSegmentUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one TranscriptSegment.
     * @param {TranscriptSegmentUpsertArgs} args - Arguments to update or create a TranscriptSegment.
     * @example
     * // Update or create a TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.upsert({
     *   create: {
     *     // ... data to create a TranscriptSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptSegment we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptSegmentUpsertArgs>(
      args: SelectSubset<T, TranscriptSegmentUpsertArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      $Result.GetResult<
        Prisma.$TranscriptSegmentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TranscriptSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentCountArgs} args - Arguments to filter TranscriptSegments to count.
     * @example
     * // Count the number of TranscriptSegments
     * const count = await prisma.transcriptSegment.count({
     *   where: {
     *     // ... the filter for the TranscriptSegments we want to count
     *   }
     * })
     **/
    count<T extends TranscriptSegmentCountArgs>(
      args?: Subset<T, TranscriptSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              TranscriptSegmentCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TranscriptSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TranscriptSegmentAggregateArgs>(
      args: Subset<T, TranscriptSegmentAggregateArgs>,
    ): Prisma.PrismaPromise<GetTranscriptSegmentAggregateType<T>>;

    /**
     * Group by TranscriptSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TranscriptSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptSegmentGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TranscriptSegmentGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTranscriptSegmentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TranscriptSegment model
     */
    readonly fields: TranscriptSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptSegmentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    edits<T extends TranscriptSegment$editsArgs<ExtArgs> = {}>(
      args?: Subset<T, TranscriptSegment$editsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SegmentEditPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    corrections<T extends TranscriptSegment$correctionsArgs<ExtArgs> = {}>(
      args?: Subset<T, TranscriptSegment$correctionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TranscriptCorrectionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MeetingDefaultArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      | $Result.GetResult<
          Prisma.$MeetingPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    speaker<T extends TranscriptSegment$speakerArgs<ExtArgs> = {}>(
      args?: Subset<T, TranscriptSegment$speakerArgs<ExtArgs>>,
    ): Prisma__SpeakerClient<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TranscriptSegment model
   */
  interface TranscriptSegmentFieldRefs {
    readonly id: FieldRef<'TranscriptSegment', 'String'>;
    readonly meetingId: FieldRef<'TranscriptSegment', 'String'>;
    readonly speakerId: FieldRef<'TranscriptSegment', 'String'>;
    readonly startTime: FieldRef<'TranscriptSegment', 'Float'>;
    readonly endTime: FieldRef<'TranscriptSegment', 'Float'>;
    readonly text: FieldRef<'TranscriptSegment', 'String'>;
    readonly languagesUsed: FieldRef<'TranscriptSegment', 'String[]'>;
    readonly originalText: FieldRef<'TranscriptSegment', 'String'>;
  }

  // Custom InputTypes
  /**
   * TranscriptSegment findUnique
   */
  export type TranscriptSegmentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptSegment to fetch.
     */
    where: TranscriptSegmentWhereUniqueInput;
  };

  /**
   * TranscriptSegment findUniqueOrThrow
   */
  export type TranscriptSegmentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptSegment to fetch.
     */
    where: TranscriptSegmentWhereUniqueInput;
  };

  /**
   * TranscriptSegment findFirst
   */
  export type TranscriptSegmentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptSegment to fetch.
     */
    where?: TranscriptSegmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TranscriptSegments to fetch.
     */
    orderBy?:
      | TranscriptSegmentOrderByWithRelationInput
      | TranscriptSegmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TranscriptSegments.
     */
    cursor?: TranscriptSegmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TranscriptSegments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TranscriptSegments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TranscriptSegments.
     */
    distinct?:
      | TranscriptSegmentScalarFieldEnum
      | TranscriptSegmentScalarFieldEnum[];
  };

  /**
   * TranscriptSegment findFirstOrThrow
   */
  export type TranscriptSegmentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptSegment to fetch.
     */
    where?: TranscriptSegmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TranscriptSegments to fetch.
     */
    orderBy?:
      | TranscriptSegmentOrderByWithRelationInput
      | TranscriptSegmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TranscriptSegments.
     */
    cursor?: TranscriptSegmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TranscriptSegments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TranscriptSegments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TranscriptSegments.
     */
    distinct?:
      | TranscriptSegmentScalarFieldEnum
      | TranscriptSegmentScalarFieldEnum[];
  };

  /**
   * TranscriptSegment findMany
   */
  export type TranscriptSegmentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptSegments to fetch.
     */
    where?: TranscriptSegmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TranscriptSegments to fetch.
     */
    orderBy?:
      | TranscriptSegmentOrderByWithRelationInput
      | TranscriptSegmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TranscriptSegments.
     */
    cursor?: TranscriptSegmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TranscriptSegments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TranscriptSegments.
     */
    skip?: number;
    distinct?:
      | TranscriptSegmentScalarFieldEnum
      | TranscriptSegmentScalarFieldEnum[];
  };

  /**
   * TranscriptSegment create
   */
  export type TranscriptSegmentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    /**
     * The data needed to create a TranscriptSegment.
     */
    data: XOR<
      TranscriptSegmentCreateInput,
      TranscriptSegmentUncheckedCreateInput
    >;
  };

  /**
   * TranscriptSegment createMany
   */
  export type TranscriptSegmentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TranscriptSegments.
     */
    data: TranscriptSegmentCreateManyInput | TranscriptSegmentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TranscriptSegment createManyAndReturn
   */
  export type TranscriptSegmentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * The data used to create many TranscriptSegments.
     */
    data: TranscriptSegmentCreateManyInput | TranscriptSegmentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TranscriptSegment update
   */
  export type TranscriptSegmentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    /**
     * The data needed to update a TranscriptSegment.
     */
    data: XOR<
      TranscriptSegmentUpdateInput,
      TranscriptSegmentUncheckedUpdateInput
    >;
    /**
     * Choose, which TranscriptSegment to update.
     */
    where: TranscriptSegmentWhereUniqueInput;
  };

  /**
   * TranscriptSegment updateMany
   */
  export type TranscriptSegmentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TranscriptSegments.
     */
    data: XOR<
      TranscriptSegmentUpdateManyMutationInput,
      TranscriptSegmentUncheckedUpdateManyInput
    >;
    /**
     * Filter which TranscriptSegments to update
     */
    where?: TranscriptSegmentWhereInput;
    /**
     * Limit how many TranscriptSegments to update.
     */
    limit?: number;
  };

  /**
   * TranscriptSegment updateManyAndReturn
   */
  export type TranscriptSegmentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * The data used to update TranscriptSegments.
     */
    data: XOR<
      TranscriptSegmentUpdateManyMutationInput,
      TranscriptSegmentUncheckedUpdateManyInput
    >;
    /**
     * Filter which TranscriptSegments to update
     */
    where?: TranscriptSegmentWhereInput;
    /**
     * Limit how many TranscriptSegments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TranscriptSegment upsert
   */
  export type TranscriptSegmentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    /**
     * The filter to search for the TranscriptSegment to update in case it exists.
     */
    where: TranscriptSegmentWhereUniqueInput;
    /**
     * In case the TranscriptSegment found by the `where` argument doesn't exist, create a new TranscriptSegment with this data.
     */
    create: XOR<
      TranscriptSegmentCreateInput,
      TranscriptSegmentUncheckedCreateInput
    >;
    /**
     * In case the TranscriptSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      TranscriptSegmentUpdateInput,
      TranscriptSegmentUncheckedUpdateInput
    >;
  };

  /**
   * TranscriptSegment delete
   */
  export type TranscriptSegmentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    /**
     * Filter which TranscriptSegment to delete.
     */
    where: TranscriptSegmentWhereUniqueInput;
  };

  /**
   * TranscriptSegment deleteMany
   */
  export type TranscriptSegmentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TranscriptSegments to delete
     */
    where?: TranscriptSegmentWhereInput;
    /**
     * Limit how many TranscriptSegments to delete.
     */
    limit?: number;
  };

  /**
   * TranscriptSegment.edits
   */
  export type TranscriptSegment$editsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    where?: SegmentEditWhereInput;
    orderBy?:
      | SegmentEditOrderByWithRelationInput
      | SegmentEditOrderByWithRelationInput[];
    cursor?: SegmentEditWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SegmentEditScalarFieldEnum | SegmentEditScalarFieldEnum[];
  };

  /**
   * TranscriptSegment.corrections
   */
  export type TranscriptSegment$correctionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    where?: TranscriptCorrectionWhereInput;
    orderBy?:
      | TranscriptCorrectionOrderByWithRelationInput
      | TranscriptCorrectionOrderByWithRelationInput[];
    cursor?: TranscriptCorrectionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | TranscriptCorrectionScalarFieldEnum
      | TranscriptCorrectionScalarFieldEnum[];
  };

  /**
   * TranscriptSegment.speaker
   */
  export type TranscriptSegment$speakerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    where?: SpeakerWhereInput;
  };

  /**
   * TranscriptSegment without action
   */
  export type TranscriptSegmentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
  };

  /**
   * Model TranscriptCorrection
   */

  export type AggregateTranscriptCorrection = {
    _count: TranscriptCorrectionCountAggregateOutputType | null;
    _min: TranscriptCorrectionMinAggregateOutputType | null;
    _max: TranscriptCorrectionMaxAggregateOutputType | null;
  };

  export type TranscriptCorrectionMinAggregateOutputType = {
    id: string | null;
    segmentId: string | null;
    originalText: string | null;
    correctedText: string | null;
    correctedBy: string | null;
    createdAt: Date | null;
  };

  export type TranscriptCorrectionMaxAggregateOutputType = {
    id: string | null;
    segmentId: string | null;
    originalText: string | null;
    correctedText: string | null;
    correctedBy: string | null;
    createdAt: Date | null;
  };

  export type TranscriptCorrectionCountAggregateOutputType = {
    id: number;
    segmentId: number;
    originalText: number;
    correctedText: number;
    correctedBy: number;
    createdAt: number;
    _all: number;
  };

  export type TranscriptCorrectionMinAggregateInputType = {
    id?: true;
    segmentId?: true;
    originalText?: true;
    correctedText?: true;
    correctedBy?: true;
    createdAt?: true;
  };

  export type TranscriptCorrectionMaxAggregateInputType = {
    id?: true;
    segmentId?: true;
    originalText?: true;
    correctedText?: true;
    correctedBy?: true;
    createdAt?: true;
  };

  export type TranscriptCorrectionCountAggregateInputType = {
    id?: true;
    segmentId?: true;
    originalText?: true;
    correctedText?: true;
    correctedBy?: true;
    createdAt?: true;
    _all?: true;
  };

  export type TranscriptCorrectionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TranscriptCorrection to aggregate.
     */
    where?: TranscriptCorrectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TranscriptCorrections to fetch.
     */
    orderBy?:
      | TranscriptCorrectionOrderByWithRelationInput
      | TranscriptCorrectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TranscriptCorrectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TranscriptCorrections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TranscriptCorrections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TranscriptCorrections
     **/
    _count?: true | TranscriptCorrectionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TranscriptCorrectionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TranscriptCorrectionMaxAggregateInputType;
  };

  export type GetTranscriptCorrectionAggregateType<
    T extends TranscriptCorrectionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateTranscriptCorrection]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptCorrection[P]>
      : GetScalarType<T[P], AggregateTranscriptCorrection[P]>;
  };

  export type TranscriptCorrectionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TranscriptCorrectionWhereInput;
    orderBy?:
      | TranscriptCorrectionOrderByWithAggregationInput
      | TranscriptCorrectionOrderByWithAggregationInput[];
    by:
      | TranscriptCorrectionScalarFieldEnum[]
      | TranscriptCorrectionScalarFieldEnum;
    having?: TranscriptCorrectionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TranscriptCorrectionCountAggregateInputType | true;
    _min?: TranscriptCorrectionMinAggregateInputType;
    _max?: TranscriptCorrectionMaxAggregateInputType;
  };

  export type TranscriptCorrectionGroupByOutputType = {
    id: string;
    segmentId: string;
    originalText: string;
    correctedText: string;
    correctedBy: string;
    createdAt: Date;
    _count: TranscriptCorrectionCountAggregateOutputType | null;
    _min: TranscriptCorrectionMinAggregateOutputType | null;
    _max: TranscriptCorrectionMaxAggregateOutputType | null;
  };

  type GetTranscriptCorrectionGroupByPayload<
    T extends TranscriptCorrectionGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptCorrectionGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof TranscriptCorrectionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TranscriptCorrectionGroupByOutputType[P]>
          : GetScalarType<T[P], TranscriptCorrectionGroupByOutputType[P]>;
      }
    >
  >;

  export type TranscriptCorrectionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      segmentId?: boolean;
      originalText?: boolean;
      correctedText?: boolean;
      correctedBy?: boolean;
      createdAt?: boolean;
      segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['transcriptCorrection']
  >;

  export type TranscriptCorrectionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      segmentId?: boolean;
      originalText?: boolean;
      correctedText?: boolean;
      correctedBy?: boolean;
      createdAt?: boolean;
      segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['transcriptCorrection']
  >;

  export type TranscriptCorrectionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      segmentId?: boolean;
      originalText?: boolean;
      correctedText?: boolean;
      correctedBy?: boolean;
      createdAt?: boolean;
      segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['transcriptCorrection']
  >;

  export type TranscriptCorrectionSelectScalar = {
    id?: boolean;
    segmentId?: boolean;
    originalText?: boolean;
    correctedText?: boolean;
    correctedBy?: boolean;
    createdAt?: boolean;
  };

  export type TranscriptCorrectionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'segmentId'
    | 'originalText'
    | 'correctedText'
    | 'correctedBy'
    | 'createdAt',
    ExtArgs['result']['transcriptCorrection']
  >;
  export type TranscriptCorrectionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
  };
  export type TranscriptCorrectionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
  };
  export type TranscriptCorrectionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
  };

  export type $TranscriptCorrectionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'TranscriptCorrection';
    objects: {
      segment: Prisma.$TranscriptSegmentPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        segmentId: string;
        originalText: string;
        correctedText: string;
        correctedBy: string;
        createdAt: Date;
      },
      ExtArgs['result']['transcriptCorrection']
    >;
    composites: {};
  };

  type TranscriptCorrectionGetPayload<
    S extends boolean | null | undefined | TranscriptCorrectionDefaultArgs,
  > = $Result.GetResult<Prisma.$TranscriptCorrectionPayload, S>;

  type TranscriptCorrectionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    TranscriptCorrectionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: TranscriptCorrectionCountAggregateInputType | true;
  };

  export interface TranscriptCorrectionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TranscriptCorrection'];
      meta: { name: 'TranscriptCorrection' };
    };
    /**
     * Find zero or one TranscriptCorrection that matches the filter.
     * @param {TranscriptCorrectionFindUniqueArgs} args - Arguments to find a TranscriptCorrection
     * @example
     * // Get one TranscriptCorrection
     * const transcriptCorrection = await prisma.transcriptCorrection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptCorrectionFindUniqueArgs>(
      args: SelectSubset<T, TranscriptCorrectionFindUniqueArgs<ExtArgs>>,
    ): Prisma__TranscriptCorrectionClient<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TranscriptCorrection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptCorrectionFindUniqueOrThrowArgs} args - Arguments to find a TranscriptCorrection
     * @example
     * // Get one TranscriptCorrection
     * const transcriptCorrection = await prisma.transcriptCorrection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptCorrectionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TranscriptCorrectionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TranscriptCorrectionClient<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TranscriptCorrection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCorrectionFindFirstArgs} args - Arguments to find a TranscriptCorrection
     * @example
     * // Get one TranscriptCorrection
     * const transcriptCorrection = await prisma.transcriptCorrection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptCorrectionFindFirstArgs>(
      args?: SelectSubset<T, TranscriptCorrectionFindFirstArgs<ExtArgs>>,
    ): Prisma__TranscriptCorrectionClient<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TranscriptCorrection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCorrectionFindFirstOrThrowArgs} args - Arguments to find a TranscriptCorrection
     * @example
     * // Get one TranscriptCorrection
     * const transcriptCorrection = await prisma.transcriptCorrection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptCorrectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TranscriptCorrectionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TranscriptCorrectionClient<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TranscriptCorrections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCorrectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptCorrections
     * const transcriptCorrections = await prisma.transcriptCorrection.findMany()
     *
     * // Get first 10 TranscriptCorrections
     * const transcriptCorrections = await prisma.transcriptCorrection.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const transcriptCorrectionWithIdOnly = await prisma.transcriptCorrection.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TranscriptCorrectionFindManyArgs>(
      args?: SelectSubset<T, TranscriptCorrectionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TranscriptCorrection.
     * @param {TranscriptCorrectionCreateArgs} args - Arguments to create a TranscriptCorrection.
     * @example
     * // Create one TranscriptCorrection
     * const TranscriptCorrection = await prisma.transcriptCorrection.create({
     *   data: {
     *     // ... data to create a TranscriptCorrection
     *   }
     * })
     *
     */
    create<T extends TranscriptCorrectionCreateArgs>(
      args: SelectSubset<T, TranscriptCorrectionCreateArgs<ExtArgs>>,
    ): Prisma__TranscriptCorrectionClient<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TranscriptCorrections.
     * @param {TranscriptCorrectionCreateManyArgs} args - Arguments to create many TranscriptCorrections.
     * @example
     * // Create many TranscriptCorrections
     * const transcriptCorrection = await prisma.transcriptCorrection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TranscriptCorrectionCreateManyArgs>(
      args?: SelectSubset<T, TranscriptCorrectionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many TranscriptCorrections and returns the data saved in the database.
     * @param {TranscriptCorrectionCreateManyAndReturnArgs} args - Arguments to create many TranscriptCorrections.
     * @example
     * // Create many TranscriptCorrections
     * const transcriptCorrection = await prisma.transcriptCorrection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TranscriptCorrections and only return the `id`
     * const transcriptCorrectionWithIdOnly = await prisma.transcriptCorrection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TranscriptCorrectionCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        TranscriptCorrectionCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a TranscriptCorrection.
     * @param {TranscriptCorrectionDeleteArgs} args - Arguments to delete one TranscriptCorrection.
     * @example
     * // Delete one TranscriptCorrection
     * const TranscriptCorrection = await prisma.transcriptCorrection.delete({
     *   where: {
     *     // ... filter to delete one TranscriptCorrection
     *   }
     * })
     *
     */
    delete<T extends TranscriptCorrectionDeleteArgs>(
      args: SelectSubset<T, TranscriptCorrectionDeleteArgs<ExtArgs>>,
    ): Prisma__TranscriptCorrectionClient<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TranscriptCorrection.
     * @param {TranscriptCorrectionUpdateArgs} args - Arguments to update one TranscriptCorrection.
     * @example
     * // Update one TranscriptCorrection
     * const transcriptCorrection = await prisma.transcriptCorrection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TranscriptCorrectionUpdateArgs>(
      args: SelectSubset<T, TranscriptCorrectionUpdateArgs<ExtArgs>>,
    ): Prisma__TranscriptCorrectionClient<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TranscriptCorrections.
     * @param {TranscriptCorrectionDeleteManyArgs} args - Arguments to filter TranscriptCorrections to delete.
     * @example
     * // Delete a few TranscriptCorrections
     * const { count } = await prisma.transcriptCorrection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TranscriptCorrectionDeleteManyArgs>(
      args?: SelectSubset<T, TranscriptCorrectionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TranscriptCorrections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCorrectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptCorrections
     * const transcriptCorrection = await prisma.transcriptCorrection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TranscriptCorrectionUpdateManyArgs>(
      args: SelectSubset<T, TranscriptCorrectionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TranscriptCorrections and returns the data updated in the database.
     * @param {TranscriptCorrectionUpdateManyAndReturnArgs} args - Arguments to update many TranscriptCorrections.
     * @example
     * // Update many TranscriptCorrections
     * const transcriptCorrection = await prisma.transcriptCorrection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more TranscriptCorrections and only return the `id`
     * const transcriptCorrectionWithIdOnly = await prisma.transcriptCorrection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TranscriptCorrectionUpdateManyAndReturnArgs>(
      args: SelectSubset<
        T,
        TranscriptCorrectionUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one TranscriptCorrection.
     * @param {TranscriptCorrectionUpsertArgs} args - Arguments to update or create a TranscriptCorrection.
     * @example
     * // Update or create a TranscriptCorrection
     * const transcriptCorrection = await prisma.transcriptCorrection.upsert({
     *   create: {
     *     // ... data to create a TranscriptCorrection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptCorrection we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptCorrectionUpsertArgs>(
      args: SelectSubset<T, TranscriptCorrectionUpsertArgs<ExtArgs>>,
    ): Prisma__TranscriptCorrectionClient<
      $Result.GetResult<
        Prisma.$TranscriptCorrectionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TranscriptCorrections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCorrectionCountArgs} args - Arguments to filter TranscriptCorrections to count.
     * @example
     * // Count the number of TranscriptCorrections
     * const count = await prisma.transcriptCorrection.count({
     *   where: {
     *     // ... the filter for the TranscriptCorrections we want to count
     *   }
     * })
     **/
    count<T extends TranscriptCorrectionCountArgs>(
      args?: Subset<T, TranscriptCorrectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              TranscriptCorrectionCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TranscriptCorrection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCorrectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TranscriptCorrectionAggregateArgs>(
      args: Subset<T, TranscriptCorrectionAggregateArgs>,
    ): Prisma.PrismaPromise<GetTranscriptCorrectionAggregateType<T>>;

    /**
     * Group by TranscriptCorrection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCorrectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TranscriptCorrectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptCorrectionGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptCorrectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TranscriptCorrectionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTranscriptCorrectionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TranscriptCorrection model
     */
    readonly fields: TranscriptCorrectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptCorrection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptCorrectionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    segment<T extends TranscriptSegmentDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TranscriptSegmentDefaultArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      | $Result.GetResult<
          Prisma.$TranscriptSegmentPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TranscriptCorrection model
   */
  interface TranscriptCorrectionFieldRefs {
    readonly id: FieldRef<'TranscriptCorrection', 'String'>;
    readonly segmentId: FieldRef<'TranscriptCorrection', 'String'>;
    readonly originalText: FieldRef<'TranscriptCorrection', 'String'>;
    readonly correctedText: FieldRef<'TranscriptCorrection', 'String'>;
    readonly correctedBy: FieldRef<'TranscriptCorrection', 'String'>;
    readonly createdAt: FieldRef<'TranscriptCorrection', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * TranscriptCorrection findUnique
   */
  export type TranscriptCorrectionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptCorrection to fetch.
     */
    where: TranscriptCorrectionWhereUniqueInput;
  };

  /**
   * TranscriptCorrection findUniqueOrThrow
   */
  export type TranscriptCorrectionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptCorrection to fetch.
     */
    where: TranscriptCorrectionWhereUniqueInput;
  };

  /**
   * TranscriptCorrection findFirst
   */
  export type TranscriptCorrectionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptCorrection to fetch.
     */
    where?: TranscriptCorrectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TranscriptCorrections to fetch.
     */
    orderBy?:
      | TranscriptCorrectionOrderByWithRelationInput
      | TranscriptCorrectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TranscriptCorrections.
     */
    cursor?: TranscriptCorrectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TranscriptCorrections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TranscriptCorrections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TranscriptCorrections.
     */
    distinct?:
      | TranscriptCorrectionScalarFieldEnum
      | TranscriptCorrectionScalarFieldEnum[];
  };

  /**
   * TranscriptCorrection findFirstOrThrow
   */
  export type TranscriptCorrectionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptCorrection to fetch.
     */
    where?: TranscriptCorrectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TranscriptCorrections to fetch.
     */
    orderBy?:
      | TranscriptCorrectionOrderByWithRelationInput
      | TranscriptCorrectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TranscriptCorrections.
     */
    cursor?: TranscriptCorrectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TranscriptCorrections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TranscriptCorrections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TranscriptCorrections.
     */
    distinct?:
      | TranscriptCorrectionScalarFieldEnum
      | TranscriptCorrectionScalarFieldEnum[];
  };

  /**
   * TranscriptCorrection findMany
   */
  export type TranscriptCorrectionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    /**
     * Filter, which TranscriptCorrections to fetch.
     */
    where?: TranscriptCorrectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TranscriptCorrections to fetch.
     */
    orderBy?:
      | TranscriptCorrectionOrderByWithRelationInput
      | TranscriptCorrectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TranscriptCorrections.
     */
    cursor?: TranscriptCorrectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TranscriptCorrections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TranscriptCorrections.
     */
    skip?: number;
    distinct?:
      | TranscriptCorrectionScalarFieldEnum
      | TranscriptCorrectionScalarFieldEnum[];
  };

  /**
   * TranscriptCorrection create
   */
  export type TranscriptCorrectionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    /**
     * The data needed to create a TranscriptCorrection.
     */
    data: XOR<
      TranscriptCorrectionCreateInput,
      TranscriptCorrectionUncheckedCreateInput
    >;
  };

  /**
   * TranscriptCorrection createMany
   */
  export type TranscriptCorrectionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TranscriptCorrections.
     */
    data:
      | TranscriptCorrectionCreateManyInput
      | TranscriptCorrectionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TranscriptCorrection createManyAndReturn
   */
  export type TranscriptCorrectionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * The data used to create many TranscriptCorrections.
     */
    data:
      | TranscriptCorrectionCreateManyInput
      | TranscriptCorrectionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TranscriptCorrection update
   */
  export type TranscriptCorrectionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    /**
     * The data needed to update a TranscriptCorrection.
     */
    data: XOR<
      TranscriptCorrectionUpdateInput,
      TranscriptCorrectionUncheckedUpdateInput
    >;
    /**
     * Choose, which TranscriptCorrection to update.
     */
    where: TranscriptCorrectionWhereUniqueInput;
  };

  /**
   * TranscriptCorrection updateMany
   */
  export type TranscriptCorrectionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TranscriptCorrections.
     */
    data: XOR<
      TranscriptCorrectionUpdateManyMutationInput,
      TranscriptCorrectionUncheckedUpdateManyInput
    >;
    /**
     * Filter which TranscriptCorrections to update
     */
    where?: TranscriptCorrectionWhereInput;
    /**
     * Limit how many TranscriptCorrections to update.
     */
    limit?: number;
  };

  /**
   * TranscriptCorrection updateManyAndReturn
   */
  export type TranscriptCorrectionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * The data used to update TranscriptCorrections.
     */
    data: XOR<
      TranscriptCorrectionUpdateManyMutationInput,
      TranscriptCorrectionUncheckedUpdateManyInput
    >;
    /**
     * Filter which TranscriptCorrections to update
     */
    where?: TranscriptCorrectionWhereInput;
    /**
     * Limit how many TranscriptCorrections to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TranscriptCorrection upsert
   */
  export type TranscriptCorrectionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    /**
     * The filter to search for the TranscriptCorrection to update in case it exists.
     */
    where: TranscriptCorrectionWhereUniqueInput;
    /**
     * In case the TranscriptCorrection found by the `where` argument doesn't exist, create a new TranscriptCorrection with this data.
     */
    create: XOR<
      TranscriptCorrectionCreateInput,
      TranscriptCorrectionUncheckedCreateInput
    >;
    /**
     * In case the TranscriptCorrection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      TranscriptCorrectionUpdateInput,
      TranscriptCorrectionUncheckedUpdateInput
    >;
  };

  /**
   * TranscriptCorrection delete
   */
  export type TranscriptCorrectionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
    /**
     * Filter which TranscriptCorrection to delete.
     */
    where: TranscriptCorrectionWhereUniqueInput;
  };

  /**
   * TranscriptCorrection deleteMany
   */
  export type TranscriptCorrectionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TranscriptCorrections to delete
     */
    where?: TranscriptCorrectionWhereInput;
    /**
     * Limit how many TranscriptCorrections to delete.
     */
    limit?: number;
  };

  /**
   * TranscriptCorrection without action
   */
  export type TranscriptCorrectionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptCorrection
     */
    select?: TranscriptCorrectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptCorrection
     */
    omit?: TranscriptCorrectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptCorrectionInclude<ExtArgs> | null;
  };

  /**
   * Model SegmentEdit
   */

  export type AggregateSegmentEdit = {
    _count: SegmentEditCountAggregateOutputType | null;
    _min: SegmentEditMinAggregateOutputType | null;
    _max: SegmentEditMaxAggregateOutputType | null;
  };

  export type SegmentEditMinAggregateOutputType = {
    id: string | null;
    segmentId: string | null;
    previousText: string | null;
    newText: string | null;
    editedBy: string | null;
    editReason: string | null;
    createdAt: Date | null;
  };

  export type SegmentEditMaxAggregateOutputType = {
    id: string | null;
    segmentId: string | null;
    previousText: string | null;
    newText: string | null;
    editedBy: string | null;
    editReason: string | null;
    createdAt: Date | null;
  };

  export type SegmentEditCountAggregateOutputType = {
    id: number;
    segmentId: number;
    previousText: number;
    newText: number;
    editedBy: number;
    editReason: number;
    createdAt: number;
    _all: number;
  };

  export type SegmentEditMinAggregateInputType = {
    id?: true;
    segmentId?: true;
    previousText?: true;
    newText?: true;
    editedBy?: true;
    editReason?: true;
    createdAt?: true;
  };

  export type SegmentEditMaxAggregateInputType = {
    id?: true;
    segmentId?: true;
    previousText?: true;
    newText?: true;
    editedBy?: true;
    editReason?: true;
    createdAt?: true;
  };

  export type SegmentEditCountAggregateInputType = {
    id?: true;
    segmentId?: true;
    previousText?: true;
    newText?: true;
    editedBy?: true;
    editReason?: true;
    createdAt?: true;
    _all?: true;
  };

  export type SegmentEditAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SegmentEdit to aggregate.
     */
    where?: SegmentEditWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SegmentEdits to fetch.
     */
    orderBy?:
      | SegmentEditOrderByWithRelationInput
      | SegmentEditOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SegmentEditWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SegmentEdits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SegmentEdits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SegmentEdits
     **/
    _count?: true | SegmentEditCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SegmentEditMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SegmentEditMaxAggregateInputType;
  };

  export type GetSegmentEditAggregateType<T extends SegmentEditAggregateArgs> =
    {
      [P in keyof T & keyof AggregateSegmentEdit]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateSegmentEdit[P]>
        : GetScalarType<T[P], AggregateSegmentEdit[P]>;
    };

  export type SegmentEditGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SegmentEditWhereInput;
    orderBy?:
      | SegmentEditOrderByWithAggregationInput
      | SegmentEditOrderByWithAggregationInput[];
    by: SegmentEditScalarFieldEnum[] | SegmentEditScalarFieldEnum;
    having?: SegmentEditScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SegmentEditCountAggregateInputType | true;
    _min?: SegmentEditMinAggregateInputType;
    _max?: SegmentEditMaxAggregateInputType;
  };

  export type SegmentEditGroupByOutputType = {
    id: string;
    segmentId: string;
    previousText: string;
    newText: string;
    editedBy: string;
    editReason: string | null;
    createdAt: Date;
    _count: SegmentEditCountAggregateOutputType | null;
    _min: SegmentEditMinAggregateOutputType | null;
    _max: SegmentEditMaxAggregateOutputType | null;
  };

  type GetSegmentEditGroupByPayload<T extends SegmentEditGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SegmentEditGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof SegmentEditGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SegmentEditGroupByOutputType[P]>
            : GetScalarType<T[P], SegmentEditGroupByOutputType[P]>;
        }
      >
    >;

  export type SegmentEditSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      segmentId?: boolean;
      previousText?: boolean;
      newText?: boolean;
      editedBy?: boolean;
      editReason?: boolean;
      createdAt?: boolean;
      segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['segmentEdit']
  >;

  export type SegmentEditSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      segmentId?: boolean;
      previousText?: boolean;
      newText?: boolean;
      editedBy?: boolean;
      editReason?: boolean;
      createdAt?: boolean;
      segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['segmentEdit']
  >;

  export type SegmentEditSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      segmentId?: boolean;
      previousText?: boolean;
      newText?: boolean;
      editedBy?: boolean;
      editReason?: boolean;
      createdAt?: boolean;
      segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['segmentEdit']
  >;

  export type SegmentEditSelectScalar = {
    id?: boolean;
    segmentId?: boolean;
    previousText?: boolean;
    newText?: boolean;
    editedBy?: boolean;
    editReason?: boolean;
    createdAt?: boolean;
  };

  export type SegmentEditOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'segmentId'
    | 'previousText'
    | 'newText'
    | 'editedBy'
    | 'editReason'
    | 'createdAt',
    ExtArgs['result']['segmentEdit']
  >;
  export type SegmentEditInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
  };
  export type SegmentEditIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
  };
  export type SegmentEditIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    segment?: boolean | TranscriptSegmentDefaultArgs<ExtArgs>;
  };

  export type $SegmentEditPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'SegmentEdit';
    objects: {
      segment: Prisma.$TranscriptSegmentPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        segmentId: string;
        previousText: string;
        newText: string;
        editedBy: string;
        editReason: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['segmentEdit']
    >;
    composites: {};
  };

  type SegmentEditGetPayload<
    S extends boolean | null | undefined | SegmentEditDefaultArgs,
  > = $Result.GetResult<Prisma.$SegmentEditPayload, S>;

  type SegmentEditCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    SegmentEditFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: SegmentEditCountAggregateInputType | true;
  };

  export interface SegmentEditDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['SegmentEdit'];
      meta: { name: 'SegmentEdit' };
    };
    /**
     * Find zero or one SegmentEdit that matches the filter.
     * @param {SegmentEditFindUniqueArgs} args - Arguments to find a SegmentEdit
     * @example
     * // Get one SegmentEdit
     * const segmentEdit = await prisma.segmentEdit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SegmentEditFindUniqueArgs>(
      args: SelectSubset<T, SegmentEditFindUniqueArgs<ExtArgs>>,
    ): Prisma__SegmentEditClient<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one SegmentEdit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SegmentEditFindUniqueOrThrowArgs} args - Arguments to find a SegmentEdit
     * @example
     * // Get one SegmentEdit
     * const segmentEdit = await prisma.segmentEdit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SegmentEditFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SegmentEditFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SegmentEditClient<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SegmentEdit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentEditFindFirstArgs} args - Arguments to find a SegmentEdit
     * @example
     * // Get one SegmentEdit
     * const segmentEdit = await prisma.segmentEdit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SegmentEditFindFirstArgs>(
      args?: SelectSubset<T, SegmentEditFindFirstArgs<ExtArgs>>,
    ): Prisma__SegmentEditClient<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SegmentEdit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentEditFindFirstOrThrowArgs} args - Arguments to find a SegmentEdit
     * @example
     * // Get one SegmentEdit
     * const segmentEdit = await prisma.segmentEdit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SegmentEditFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SegmentEditFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SegmentEditClient<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more SegmentEdits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentEditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SegmentEdits
     * const segmentEdits = await prisma.segmentEdit.findMany()
     *
     * // Get first 10 SegmentEdits
     * const segmentEdits = await prisma.segmentEdit.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const segmentEditWithIdOnly = await prisma.segmentEdit.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SegmentEditFindManyArgs>(
      args?: SelectSubset<T, SegmentEditFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a SegmentEdit.
     * @param {SegmentEditCreateArgs} args - Arguments to create a SegmentEdit.
     * @example
     * // Create one SegmentEdit
     * const SegmentEdit = await prisma.segmentEdit.create({
     *   data: {
     *     // ... data to create a SegmentEdit
     *   }
     * })
     *
     */
    create<T extends SegmentEditCreateArgs>(
      args: SelectSubset<T, SegmentEditCreateArgs<ExtArgs>>,
    ): Prisma__SegmentEditClient<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many SegmentEdits.
     * @param {SegmentEditCreateManyArgs} args - Arguments to create many SegmentEdits.
     * @example
     * // Create many SegmentEdits
     * const segmentEdit = await prisma.segmentEdit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SegmentEditCreateManyArgs>(
      args?: SelectSubset<T, SegmentEditCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many SegmentEdits and returns the data saved in the database.
     * @param {SegmentEditCreateManyAndReturnArgs} args - Arguments to create many SegmentEdits.
     * @example
     * // Create many SegmentEdits
     * const segmentEdit = await prisma.segmentEdit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SegmentEdits and only return the `id`
     * const segmentEditWithIdOnly = await prisma.segmentEdit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SegmentEditCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SegmentEditCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a SegmentEdit.
     * @param {SegmentEditDeleteArgs} args - Arguments to delete one SegmentEdit.
     * @example
     * // Delete one SegmentEdit
     * const SegmentEdit = await prisma.segmentEdit.delete({
     *   where: {
     *     // ... filter to delete one SegmentEdit
     *   }
     * })
     *
     */
    delete<T extends SegmentEditDeleteArgs>(
      args: SelectSubset<T, SegmentEditDeleteArgs<ExtArgs>>,
    ): Prisma__SegmentEditClient<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one SegmentEdit.
     * @param {SegmentEditUpdateArgs} args - Arguments to update one SegmentEdit.
     * @example
     * // Update one SegmentEdit
     * const segmentEdit = await prisma.segmentEdit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SegmentEditUpdateArgs>(
      args: SelectSubset<T, SegmentEditUpdateArgs<ExtArgs>>,
    ): Prisma__SegmentEditClient<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more SegmentEdits.
     * @param {SegmentEditDeleteManyArgs} args - Arguments to filter SegmentEdits to delete.
     * @example
     * // Delete a few SegmentEdits
     * const { count } = await prisma.segmentEdit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SegmentEditDeleteManyArgs>(
      args?: SelectSubset<T, SegmentEditDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SegmentEdits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentEditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SegmentEdits
     * const segmentEdit = await prisma.segmentEdit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SegmentEditUpdateManyArgs>(
      args: SelectSubset<T, SegmentEditUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SegmentEdits and returns the data updated in the database.
     * @param {SegmentEditUpdateManyAndReturnArgs} args - Arguments to update many SegmentEdits.
     * @example
     * // Update many SegmentEdits
     * const segmentEdit = await prisma.segmentEdit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SegmentEdits and only return the `id`
     * const segmentEditWithIdOnly = await prisma.segmentEdit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SegmentEditUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SegmentEditUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one SegmentEdit.
     * @param {SegmentEditUpsertArgs} args - Arguments to update or create a SegmentEdit.
     * @example
     * // Update or create a SegmentEdit
     * const segmentEdit = await prisma.segmentEdit.upsert({
     *   create: {
     *     // ... data to create a SegmentEdit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SegmentEdit we want to update
     *   }
     * })
     */
    upsert<T extends SegmentEditUpsertArgs>(
      args: SelectSubset<T, SegmentEditUpsertArgs<ExtArgs>>,
    ): Prisma__SegmentEditClient<
      $Result.GetResult<
        Prisma.$SegmentEditPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of SegmentEdits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentEditCountArgs} args - Arguments to filter SegmentEdits to count.
     * @example
     * // Count the number of SegmentEdits
     * const count = await prisma.segmentEdit.count({
     *   where: {
     *     // ... the filter for the SegmentEdits we want to count
     *   }
     * })
     **/
    count<T extends SegmentEditCountArgs>(
      args?: Subset<T, SegmentEditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SegmentEditCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SegmentEdit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentEditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SegmentEditAggregateArgs>(
      args: Subset<T, SegmentEditAggregateArgs>,
    ): Prisma.PrismaPromise<GetSegmentEditAggregateType<T>>;

    /**
     * Group by SegmentEdit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentEditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SegmentEditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SegmentEditGroupByArgs['orderBy'] }
        : { orderBy?: SegmentEditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SegmentEditGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetSegmentEditGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SegmentEdit model
     */
    readonly fields: SegmentEditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SegmentEdit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SegmentEditClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    segment<T extends TranscriptSegmentDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TranscriptSegmentDefaultArgs<ExtArgs>>,
    ): Prisma__TranscriptSegmentClient<
      | $Result.GetResult<
          Prisma.$TranscriptSegmentPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SegmentEdit model
   */
  interface SegmentEditFieldRefs {
    readonly id: FieldRef<'SegmentEdit', 'String'>;
    readonly segmentId: FieldRef<'SegmentEdit', 'String'>;
    readonly previousText: FieldRef<'SegmentEdit', 'String'>;
    readonly newText: FieldRef<'SegmentEdit', 'String'>;
    readonly editedBy: FieldRef<'SegmentEdit', 'String'>;
    readonly editReason: FieldRef<'SegmentEdit', 'String'>;
    readonly createdAt: FieldRef<'SegmentEdit', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * SegmentEdit findUnique
   */
  export type SegmentEditFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    /**
     * Filter, which SegmentEdit to fetch.
     */
    where: SegmentEditWhereUniqueInput;
  };

  /**
   * SegmentEdit findUniqueOrThrow
   */
  export type SegmentEditFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    /**
     * Filter, which SegmentEdit to fetch.
     */
    where: SegmentEditWhereUniqueInput;
  };

  /**
   * SegmentEdit findFirst
   */
  export type SegmentEditFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    /**
     * Filter, which SegmentEdit to fetch.
     */
    where?: SegmentEditWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SegmentEdits to fetch.
     */
    orderBy?:
      | SegmentEditOrderByWithRelationInput
      | SegmentEditOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SegmentEdits.
     */
    cursor?: SegmentEditWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SegmentEdits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SegmentEdits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SegmentEdits.
     */
    distinct?: SegmentEditScalarFieldEnum | SegmentEditScalarFieldEnum[];
  };

  /**
   * SegmentEdit findFirstOrThrow
   */
  export type SegmentEditFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    /**
     * Filter, which SegmentEdit to fetch.
     */
    where?: SegmentEditWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SegmentEdits to fetch.
     */
    orderBy?:
      | SegmentEditOrderByWithRelationInput
      | SegmentEditOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SegmentEdits.
     */
    cursor?: SegmentEditWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SegmentEdits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SegmentEdits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SegmentEdits.
     */
    distinct?: SegmentEditScalarFieldEnum | SegmentEditScalarFieldEnum[];
  };

  /**
   * SegmentEdit findMany
   */
  export type SegmentEditFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    /**
     * Filter, which SegmentEdits to fetch.
     */
    where?: SegmentEditWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SegmentEdits to fetch.
     */
    orderBy?:
      | SegmentEditOrderByWithRelationInput
      | SegmentEditOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SegmentEdits.
     */
    cursor?: SegmentEditWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SegmentEdits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SegmentEdits.
     */
    skip?: number;
    distinct?: SegmentEditScalarFieldEnum | SegmentEditScalarFieldEnum[];
  };

  /**
   * SegmentEdit create
   */
  export type SegmentEditCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    /**
     * The data needed to create a SegmentEdit.
     */
    data: XOR<SegmentEditCreateInput, SegmentEditUncheckedCreateInput>;
  };

  /**
   * SegmentEdit createMany
   */
  export type SegmentEditCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SegmentEdits.
     */
    data: SegmentEditCreateManyInput | SegmentEditCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SegmentEdit createManyAndReturn
   */
  export type SegmentEditCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * The data used to create many SegmentEdits.
     */
    data: SegmentEditCreateManyInput | SegmentEditCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * SegmentEdit update
   */
  export type SegmentEditUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    /**
     * The data needed to update a SegmentEdit.
     */
    data: XOR<SegmentEditUpdateInput, SegmentEditUncheckedUpdateInput>;
    /**
     * Choose, which SegmentEdit to update.
     */
    where: SegmentEditWhereUniqueInput;
  };

  /**
   * SegmentEdit updateMany
   */
  export type SegmentEditUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SegmentEdits.
     */
    data: XOR<
      SegmentEditUpdateManyMutationInput,
      SegmentEditUncheckedUpdateManyInput
    >;
    /**
     * Filter which SegmentEdits to update
     */
    where?: SegmentEditWhereInput;
    /**
     * Limit how many SegmentEdits to update.
     */
    limit?: number;
  };

  /**
   * SegmentEdit updateManyAndReturn
   */
  export type SegmentEditUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * The data used to update SegmentEdits.
     */
    data: XOR<
      SegmentEditUpdateManyMutationInput,
      SegmentEditUncheckedUpdateManyInput
    >;
    /**
     * Filter which SegmentEdits to update
     */
    where?: SegmentEditWhereInput;
    /**
     * Limit how many SegmentEdits to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * SegmentEdit upsert
   */
  export type SegmentEditUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    /**
     * The filter to search for the SegmentEdit to update in case it exists.
     */
    where: SegmentEditWhereUniqueInput;
    /**
     * In case the SegmentEdit found by the `where` argument doesn't exist, create a new SegmentEdit with this data.
     */
    create: XOR<SegmentEditCreateInput, SegmentEditUncheckedCreateInput>;
    /**
     * In case the SegmentEdit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SegmentEditUpdateInput, SegmentEditUncheckedUpdateInput>;
  };

  /**
   * SegmentEdit delete
   */
  export type SegmentEditDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
    /**
     * Filter which SegmentEdit to delete.
     */
    where: SegmentEditWhereUniqueInput;
  };

  /**
   * SegmentEdit deleteMany
   */
  export type SegmentEditDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SegmentEdits to delete
     */
    where?: SegmentEditWhereInput;
    /**
     * Limit how many SegmentEdits to delete.
     */
    limit?: number;
  };

  /**
   * SegmentEdit without action
   */
  export type SegmentEditDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SegmentEdit
     */
    select?: SegmentEditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SegmentEdit
     */
    omit?: SegmentEditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentEditInclude<ExtArgs> | null;
  };

  /**
   * Model Speaker
   */

  export type AggregateSpeaker = {
    _count: SpeakerCountAggregateOutputType | null;
    _avg: SpeakerAvgAggregateOutputType | null;
    _sum: SpeakerSumAggregateOutputType | null;
    _min: SpeakerMinAggregateOutputType | null;
    _max: SpeakerMaxAggregateOutputType | null;
  };

  export type SpeakerAvgAggregateOutputType = {
    nameConfidence: number | null;
  };

  export type SpeakerSumAggregateOutputType = {
    nameConfidence: number | null;
  };

  export type SpeakerMinAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    name: string | null;
    isUnknown: boolean | null;
    isConfirmed: boolean | null;
    nameConfidence: number | null;
  };

  export type SpeakerMaxAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    name: string | null;
    isUnknown: boolean | null;
    isConfirmed: boolean | null;
    nameConfidence: number | null;
  };

  export type SpeakerCountAggregateOutputType = {
    id: number;
    meetingId: number;
    name: number;
    isUnknown: number;
    isConfirmed: number;
    nameConfidence: number;
    _all: number;
  };

  export type SpeakerAvgAggregateInputType = {
    nameConfidence?: true;
  };

  export type SpeakerSumAggregateInputType = {
    nameConfidence?: true;
  };

  export type SpeakerMinAggregateInputType = {
    id?: true;
    meetingId?: true;
    name?: true;
    isUnknown?: true;
    isConfirmed?: true;
    nameConfidence?: true;
  };

  export type SpeakerMaxAggregateInputType = {
    id?: true;
    meetingId?: true;
    name?: true;
    isUnknown?: true;
    isConfirmed?: true;
    nameConfidence?: true;
  };

  export type SpeakerCountAggregateInputType = {
    id?: true;
    meetingId?: true;
    name?: true;
    isUnknown?: true;
    isConfirmed?: true;
    nameConfidence?: true;
    _all?: true;
  };

  export type SpeakerAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Speaker to aggregate.
     */
    where?: SpeakerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Speakers to fetch.
     */
    orderBy?:
      | SpeakerOrderByWithRelationInput
      | SpeakerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SpeakerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Speakers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Speakers
     **/
    _count?: true | SpeakerCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SpeakerAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SpeakerSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SpeakerMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SpeakerMaxAggregateInputType;
  };

  export type GetSpeakerAggregateType<T extends SpeakerAggregateArgs> = {
    [P in keyof T & keyof AggregateSpeaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeaker[P]>
      : GetScalarType<T[P], AggregateSpeaker[P]>;
  };

  export type SpeakerGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SpeakerWhereInput;
    orderBy?:
      | SpeakerOrderByWithAggregationInput
      | SpeakerOrderByWithAggregationInput[];
    by: SpeakerScalarFieldEnum[] | SpeakerScalarFieldEnum;
    having?: SpeakerScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SpeakerCountAggregateInputType | true;
    _avg?: SpeakerAvgAggregateInputType;
    _sum?: SpeakerSumAggregateInputType;
    _min?: SpeakerMinAggregateInputType;
    _max?: SpeakerMaxAggregateInputType;
  };

  export type SpeakerGroupByOutputType = {
    id: string;
    meetingId: string;
    name: string;
    isUnknown: boolean;
    isConfirmed: boolean;
    nameConfidence: number;
    _count: SpeakerCountAggregateOutputType | null;
    _avg: SpeakerAvgAggregateOutputType | null;
    _sum: SpeakerSumAggregateOutputType | null;
    _min: SpeakerMinAggregateOutputType | null;
    _max: SpeakerMaxAggregateOutputType | null;
  };

  type GetSpeakerGroupByPayload<T extends SpeakerGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SpeakerGroupByOutputType, T['by']> & {
          [P in keyof T & keyof SpeakerGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakerGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakerGroupByOutputType[P]>;
        }
      >
    >;

  export type SpeakerSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      name?: boolean;
      isUnknown?: boolean;
      isConfirmed?: boolean;
      nameConfidence?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      segments?: boolean | Speaker$segmentsArgs<ExtArgs>;
      _count?: boolean | SpeakerCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['speaker']
  >;

  export type SpeakerSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      name?: boolean;
      isUnknown?: boolean;
      isConfirmed?: boolean;
      nameConfidence?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['speaker']
  >;

  export type SpeakerSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      name?: boolean;
      isUnknown?: boolean;
      isConfirmed?: boolean;
      nameConfidence?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['speaker']
  >;

  export type SpeakerSelectScalar = {
    id?: boolean;
    meetingId?: boolean;
    name?: boolean;
    isUnknown?: boolean;
    isConfirmed?: boolean;
    nameConfidence?: boolean;
  };

  export type SpeakerOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'meetingId'
    | 'name'
    | 'isUnknown'
    | 'isConfirmed'
    | 'nameConfidence',
    ExtArgs['result']['speaker']
  >;
  export type SpeakerInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    segments?: boolean | Speaker$segmentsArgs<ExtArgs>;
    _count?: boolean | SpeakerCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type SpeakerIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
  };
  export type SpeakerIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
  };

  export type $SpeakerPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Speaker';
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>;
      segments: Prisma.$TranscriptSegmentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        meetingId: string;
        name: string;
        isUnknown: boolean;
        isConfirmed: boolean;
        nameConfidence: number;
      },
      ExtArgs['result']['speaker']
    >;
    composites: {};
  };

  type SpeakerGetPayload<
    S extends boolean | null | undefined | SpeakerDefaultArgs,
  > = $Result.GetResult<Prisma.$SpeakerPayload, S>;

  type SpeakerCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SpeakerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SpeakerCountAggregateInputType | true;
  };

  export interface SpeakerDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Speaker'];
      meta: { name: 'Speaker' };
    };
    /**
     * Find zero or one Speaker that matches the filter.
     * @param {SpeakerFindUniqueArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakerFindUniqueArgs>(
      args: SelectSubset<T, SpeakerFindUniqueArgs<ExtArgs>>,
    ): Prisma__SpeakerClient<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Speaker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeakerFindUniqueOrThrowArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakerFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SpeakerFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SpeakerClient<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Speaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindFirstArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakerFindFirstArgs>(
      args?: SelectSubset<T, SpeakerFindFirstArgs<ExtArgs>>,
    ): Prisma__SpeakerClient<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Speaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindFirstOrThrowArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SpeakerFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SpeakerClient<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Speakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Speakers
     * const speakers = await prisma.speaker.findMany()
     *
     * // Get first 10 Speakers
     * const speakers = await prisma.speaker.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const speakerWithIdOnly = await prisma.speaker.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SpeakerFindManyArgs>(
      args?: SelectSubset<T, SpeakerFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Speaker.
     * @param {SpeakerCreateArgs} args - Arguments to create a Speaker.
     * @example
     * // Create one Speaker
     * const Speaker = await prisma.speaker.create({
     *   data: {
     *     // ... data to create a Speaker
     *   }
     * })
     *
     */
    create<T extends SpeakerCreateArgs>(
      args: SelectSubset<T, SpeakerCreateArgs<ExtArgs>>,
    ): Prisma__SpeakerClient<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Speakers.
     * @param {SpeakerCreateManyArgs} args - Arguments to create many Speakers.
     * @example
     * // Create many Speakers
     * const speaker = await prisma.speaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SpeakerCreateManyArgs>(
      args?: SelectSubset<T, SpeakerCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Speakers and returns the data saved in the database.
     * @param {SpeakerCreateManyAndReturnArgs} args - Arguments to create many Speakers.
     * @example
     * // Create many Speakers
     * const speaker = await prisma.speaker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Speakers and only return the `id`
     * const speakerWithIdOnly = await prisma.speaker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SpeakerCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SpeakerCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Speaker.
     * @param {SpeakerDeleteArgs} args - Arguments to delete one Speaker.
     * @example
     * // Delete one Speaker
     * const Speaker = await prisma.speaker.delete({
     *   where: {
     *     // ... filter to delete one Speaker
     *   }
     * })
     *
     */
    delete<T extends SpeakerDeleteArgs>(
      args: SelectSubset<T, SpeakerDeleteArgs<ExtArgs>>,
    ): Prisma__SpeakerClient<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Speaker.
     * @param {SpeakerUpdateArgs} args - Arguments to update one Speaker.
     * @example
     * // Update one Speaker
     * const speaker = await prisma.speaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SpeakerUpdateArgs>(
      args: SelectSubset<T, SpeakerUpdateArgs<ExtArgs>>,
    ): Prisma__SpeakerClient<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Speakers.
     * @param {SpeakerDeleteManyArgs} args - Arguments to filter Speakers to delete.
     * @example
     * // Delete a few Speakers
     * const { count } = await prisma.speaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SpeakerDeleteManyArgs>(
      args?: SelectSubset<T, SpeakerDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Speakers
     * const speaker = await prisma.speaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SpeakerUpdateManyArgs>(
      args: SelectSubset<T, SpeakerUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Speakers and returns the data updated in the database.
     * @param {SpeakerUpdateManyAndReturnArgs} args - Arguments to update many Speakers.
     * @example
     * // Update many Speakers
     * const speaker = await prisma.speaker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Speakers and only return the `id`
     * const speakerWithIdOnly = await prisma.speaker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SpeakerUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SpeakerUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Speaker.
     * @param {SpeakerUpsertArgs} args - Arguments to update or create a Speaker.
     * @example
     * // Update or create a Speaker
     * const speaker = await prisma.speaker.upsert({
     *   create: {
     *     // ... data to create a Speaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Speaker we want to update
     *   }
     * })
     */
    upsert<T extends SpeakerUpsertArgs>(
      args: SelectSubset<T, SpeakerUpsertArgs<ExtArgs>>,
    ): Prisma__SpeakerClient<
      $Result.GetResult<
        Prisma.$SpeakerPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCountArgs} args - Arguments to filter Speakers to count.
     * @example
     * // Count the number of Speakers
     * const count = await prisma.speaker.count({
     *   where: {
     *     // ... the filter for the Speakers we want to count
     *   }
     * })
     **/
    count<T extends SpeakerCountArgs>(
      args?: Subset<T, SpeakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakerCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SpeakerAggregateArgs>(
      args: Subset<T, SpeakerAggregateArgs>,
    ): Prisma.PrismaPromise<GetSpeakerAggregateType<T>>;

    /**
     * Group by Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SpeakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakerGroupByArgs['orderBy'] }
        : { orderBy?: SpeakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SpeakerGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetSpeakerGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Speaker model
     */
    readonly fields: SpeakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Speaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakerClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MeetingDefaultArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      | $Result.GetResult<
          Prisma.$MeetingPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    segments<T extends Speaker$segmentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Speaker$segmentsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TranscriptSegmentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Speaker model
   */
  interface SpeakerFieldRefs {
    readonly id: FieldRef<'Speaker', 'String'>;
    readonly meetingId: FieldRef<'Speaker', 'String'>;
    readonly name: FieldRef<'Speaker', 'String'>;
    readonly isUnknown: FieldRef<'Speaker', 'Boolean'>;
    readonly isConfirmed: FieldRef<'Speaker', 'Boolean'>;
    readonly nameConfidence: FieldRef<'Speaker', 'Float'>;
  }

  // Custom InputTypes
  /**
   * Speaker findUnique
   */
  export type SpeakerFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    /**
     * Filter, which Speaker to fetch.
     */
    where: SpeakerWhereUniqueInput;
  };

  /**
   * Speaker findUniqueOrThrow
   */
  export type SpeakerFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    /**
     * Filter, which Speaker to fetch.
     */
    where: SpeakerWhereUniqueInput;
  };

  /**
   * Speaker findFirst
   */
  export type SpeakerFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    /**
     * Filter, which Speaker to fetch.
     */
    where?: SpeakerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Speakers to fetch.
     */
    orderBy?:
      | SpeakerOrderByWithRelationInput
      | SpeakerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Speakers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[];
  };

  /**
   * Speaker findFirstOrThrow
   */
  export type SpeakerFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    /**
     * Filter, which Speaker to fetch.
     */
    where?: SpeakerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Speakers to fetch.
     */
    orderBy?:
      | SpeakerOrderByWithRelationInput
      | SpeakerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Speakers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[];
  };

  /**
   * Speaker findMany
   */
  export type SpeakerFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    /**
     * Filter, which Speakers to fetch.
     */
    where?: SpeakerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Speakers to fetch.
     */
    orderBy?:
      | SpeakerOrderByWithRelationInput
      | SpeakerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Speakers.
     */
    cursor?: SpeakerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Speakers.
     */
    skip?: number;
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[];
  };

  /**
   * Speaker create
   */
  export type SpeakerCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    /**
     * The data needed to create a Speaker.
     */
    data: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>;
  };

  /**
   * Speaker createMany
   */
  export type SpeakerCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Speakers.
     */
    data: SpeakerCreateManyInput | SpeakerCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Speaker createManyAndReturn
   */
  export type SpeakerCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * The data used to create many Speakers.
     */
    data: SpeakerCreateManyInput | SpeakerCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Speaker update
   */
  export type SpeakerUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    /**
     * The data needed to update a Speaker.
     */
    data: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>;
    /**
     * Choose, which Speaker to update.
     */
    where: SpeakerWhereUniqueInput;
  };

  /**
   * Speaker updateMany
   */
  export type SpeakerUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Speakers.
     */
    data: XOR<SpeakerUpdateManyMutationInput, SpeakerUncheckedUpdateManyInput>;
    /**
     * Filter which Speakers to update
     */
    where?: SpeakerWhereInput;
    /**
     * Limit how many Speakers to update.
     */
    limit?: number;
  };

  /**
   * Speaker updateManyAndReturn
   */
  export type SpeakerUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * The data used to update Speakers.
     */
    data: XOR<SpeakerUpdateManyMutationInput, SpeakerUncheckedUpdateManyInput>;
    /**
     * Filter which Speakers to update
     */
    where?: SpeakerWhereInput;
    /**
     * Limit how many Speakers to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Speaker upsert
   */
  export type SpeakerUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    /**
     * The filter to search for the Speaker to update in case it exists.
     */
    where: SpeakerWhereUniqueInput;
    /**
     * In case the Speaker found by the `where` argument doesn't exist, create a new Speaker with this data.
     */
    create: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>;
    /**
     * In case the Speaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>;
  };

  /**
   * Speaker delete
   */
  export type SpeakerDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
    /**
     * Filter which Speaker to delete.
     */
    where: SpeakerWhereUniqueInput;
  };

  /**
   * Speaker deleteMany
   */
  export type SpeakerDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Speakers to delete
     */
    where?: SpeakerWhereInput;
    /**
     * Limit how many Speakers to delete.
     */
    limit?: number;
  };

  /**
   * Speaker.segments
   */
  export type Speaker$segmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null;
    where?: TranscriptSegmentWhereInput;
    orderBy?:
      | TranscriptSegmentOrderByWithRelationInput
      | TranscriptSegmentOrderByWithRelationInput[];
    cursor?: TranscriptSegmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | TranscriptSegmentScalarFieldEnum
      | TranscriptSegmentScalarFieldEnum[];
  };

  /**
   * Speaker without action
   */
  export type SpeakerDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null;
  };

  /**
   * Model Minutes
   */

  export type AggregateMinutes = {
    _count: MinutesCountAggregateOutputType | null;
    _min: MinutesMinAggregateOutputType | null;
    _max: MinutesMaxAggregateOutputType | null;
  };

  export type MinutesMinAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    content: string | null;
    status: $Enums.MinutesStatus | null;
    reviewerId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MinutesMaxAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    content: string | null;
    status: $Enums.MinutesStatus | null;
    reviewerId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MinutesCountAggregateOutputType = {
    id: number;
    meetingId: number;
    content: number;
    status: number;
    reviewerId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type MinutesMinAggregateInputType = {
    id?: true;
    meetingId?: true;
    content?: true;
    status?: true;
    reviewerId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MinutesMaxAggregateInputType = {
    id?: true;
    meetingId?: true;
    content?: true;
    status?: true;
    reviewerId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MinutesCountAggregateInputType = {
    id?: true;
    meetingId?: true;
    content?: true;
    status?: true;
    reviewerId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type MinutesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Minutes to aggregate.
     */
    where?: MinutesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Minutes to fetch.
     */
    orderBy?:
      | MinutesOrderByWithRelationInput
      | MinutesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MinutesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Minutes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Minutes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Minutes
     **/
    _count?: true | MinutesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MinutesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MinutesMaxAggregateInputType;
  };

  export type GetMinutesAggregateType<T extends MinutesAggregateArgs> = {
    [P in keyof T & keyof AggregateMinutes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinutes[P]>
      : GetScalarType<T[P], AggregateMinutes[P]>;
  };

  export type MinutesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MinutesWhereInput;
    orderBy?:
      | MinutesOrderByWithAggregationInput
      | MinutesOrderByWithAggregationInput[];
    by: MinutesScalarFieldEnum[] | MinutesScalarFieldEnum;
    having?: MinutesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MinutesCountAggregateInputType | true;
    _min?: MinutesMinAggregateInputType;
    _max?: MinutesMaxAggregateInputType;
  };

  export type MinutesGroupByOutputType = {
    id: string;
    meetingId: string;
    content: string;
    status: $Enums.MinutesStatus;
    reviewerId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: MinutesCountAggregateOutputType | null;
    _min: MinutesMinAggregateOutputType | null;
    _max: MinutesMaxAggregateOutputType | null;
  };

  type GetMinutesGroupByPayload<T extends MinutesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MinutesGroupByOutputType, T['by']> & {
          [P in keyof T & keyof MinutesGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinutesGroupByOutputType[P]>
            : GetScalarType<T[P], MinutesGroupByOutputType[P]>;
        }
      >
    >;

  export type MinutesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      content?: boolean;
      status?: boolean;
      reviewerId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      reviewer?: boolean | Minutes$reviewerArgs<ExtArgs>;
      versions?: boolean | Minutes$versionsArgs<ExtArgs>;
      _count?: boolean | MinutesCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['minutes']
  >;

  export type MinutesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      content?: boolean;
      status?: boolean;
      reviewerId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      reviewer?: boolean | Minutes$reviewerArgs<ExtArgs>;
    },
    ExtArgs['result']['minutes']
  >;

  export type MinutesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      content?: boolean;
      status?: boolean;
      reviewerId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      reviewer?: boolean | Minutes$reviewerArgs<ExtArgs>;
    },
    ExtArgs['result']['minutes']
  >;

  export type MinutesSelectScalar = {
    id?: boolean;
    meetingId?: boolean;
    content?: boolean;
    status?: boolean;
    reviewerId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type MinutesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'meetingId'
    | 'content'
    | 'status'
    | 'reviewerId'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['minutes']
  >;
  export type MinutesInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    reviewer?: boolean | Minutes$reviewerArgs<ExtArgs>;
    versions?: boolean | Minutes$versionsArgs<ExtArgs>;
    _count?: boolean | MinutesCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type MinutesIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    reviewer?: boolean | Minutes$reviewerArgs<ExtArgs>;
  };
  export type MinutesIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    reviewer?: boolean | Minutes$reviewerArgs<ExtArgs>;
  };

  export type $MinutesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Minutes';
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>;
      reviewer: Prisma.$UserPayload<ExtArgs> | null;
      versions: Prisma.$MinutesVersionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        meetingId: string;
        content: string;
        status: $Enums.MinutesStatus;
        reviewerId: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['minutes']
    >;
    composites: {};
  };

  type MinutesGetPayload<
    S extends boolean | null | undefined | MinutesDefaultArgs,
  > = $Result.GetResult<Prisma.$MinutesPayload, S>;

  type MinutesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<MinutesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MinutesCountAggregateInputType | true;
  };

  export interface MinutesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Minutes'];
      meta: { name: 'Minutes' };
    };
    /**
     * Find zero or one Minutes that matches the filter.
     * @param {MinutesFindUniqueArgs} args - Arguments to find a Minutes
     * @example
     * // Get one Minutes
     * const minutes = await prisma.minutes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MinutesFindUniqueArgs>(
      args: SelectSubset<T, MinutesFindUniqueArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Minutes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MinutesFindUniqueOrThrowArgs} args - Arguments to find a Minutes
     * @example
     * // Get one Minutes
     * const minutes = await prisma.minutes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MinutesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MinutesFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Minutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesFindFirstArgs} args - Arguments to find a Minutes
     * @example
     * // Get one Minutes
     * const minutes = await prisma.minutes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MinutesFindFirstArgs>(
      args?: SelectSubset<T, MinutesFindFirstArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Minutes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesFindFirstOrThrowArgs} args - Arguments to find a Minutes
     * @example
     * // Get one Minutes
     * const minutes = await prisma.minutes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MinutesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MinutesFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Minutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Minutes
     * const minutes = await prisma.minutes.findMany()
     *
     * // Get first 10 Minutes
     * const minutes = await prisma.minutes.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const minutesWithIdOnly = await prisma.minutes.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MinutesFindManyArgs>(
      args?: SelectSubset<T, MinutesFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Minutes.
     * @param {MinutesCreateArgs} args - Arguments to create a Minutes.
     * @example
     * // Create one Minutes
     * const Minutes = await prisma.minutes.create({
     *   data: {
     *     // ... data to create a Minutes
     *   }
     * })
     *
     */
    create<T extends MinutesCreateArgs>(
      args: SelectSubset<T, MinutesCreateArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Minutes.
     * @param {MinutesCreateManyArgs} args - Arguments to create many Minutes.
     * @example
     * // Create many Minutes
     * const minutes = await prisma.minutes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MinutesCreateManyArgs>(
      args?: SelectSubset<T, MinutesCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Minutes and returns the data saved in the database.
     * @param {MinutesCreateManyAndReturnArgs} args - Arguments to create many Minutes.
     * @example
     * // Create many Minutes
     * const minutes = await prisma.minutes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Minutes and only return the `id`
     * const minutesWithIdOnly = await prisma.minutes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MinutesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MinutesCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Minutes.
     * @param {MinutesDeleteArgs} args - Arguments to delete one Minutes.
     * @example
     * // Delete one Minutes
     * const Minutes = await prisma.minutes.delete({
     *   where: {
     *     // ... filter to delete one Minutes
     *   }
     * })
     *
     */
    delete<T extends MinutesDeleteArgs>(
      args: SelectSubset<T, MinutesDeleteArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Minutes.
     * @param {MinutesUpdateArgs} args - Arguments to update one Minutes.
     * @example
     * // Update one Minutes
     * const minutes = await prisma.minutes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MinutesUpdateArgs>(
      args: SelectSubset<T, MinutesUpdateArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Minutes.
     * @param {MinutesDeleteManyArgs} args - Arguments to filter Minutes to delete.
     * @example
     * // Delete a few Minutes
     * const { count } = await prisma.minutes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MinutesDeleteManyArgs>(
      args?: SelectSubset<T, MinutesDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Minutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Minutes
     * const minutes = await prisma.minutes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MinutesUpdateManyArgs>(
      args: SelectSubset<T, MinutesUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Minutes and returns the data updated in the database.
     * @param {MinutesUpdateManyAndReturnArgs} args - Arguments to update many Minutes.
     * @example
     * // Update many Minutes
     * const minutes = await prisma.minutes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Minutes and only return the `id`
     * const minutesWithIdOnly = await prisma.minutes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MinutesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MinutesUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Minutes.
     * @param {MinutesUpsertArgs} args - Arguments to update or create a Minutes.
     * @example
     * // Update or create a Minutes
     * const minutes = await prisma.minutes.upsert({
     *   create: {
     *     // ... data to create a Minutes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Minutes we want to update
     *   }
     * })
     */
    upsert<T extends MinutesUpsertArgs>(
      args: SelectSubset<T, MinutesUpsertArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      $Result.GetResult<
        Prisma.$MinutesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Minutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesCountArgs} args - Arguments to filter Minutes to count.
     * @example
     * // Count the number of Minutes
     * const count = await prisma.minutes.count({
     *   where: {
     *     // ... the filter for the Minutes we want to count
     *   }
     * })
     **/
    count<T extends MinutesCountArgs>(
      args?: Subset<T, MinutesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinutesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Minutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MinutesAggregateArgs>(
      args: Subset<T, MinutesAggregateArgs>,
    ): Prisma.PrismaPromise<GetMinutesAggregateType<T>>;

    /**
     * Group by Minutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MinutesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MinutesGroupByArgs['orderBy'] }
        : { orderBy?: MinutesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MinutesGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetMinutesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Minutes model
     */
    readonly fields: MinutesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Minutes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MinutesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MeetingDefaultArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      | $Result.GetResult<
          Prisma.$MeetingPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    reviewer<T extends Minutes$reviewerArgs<ExtArgs> = {}>(
      args?: Subset<T, Minutes$reviewerArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    versions<T extends Minutes$versionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Minutes$versionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MinutesVersionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Minutes model
   */
  interface MinutesFieldRefs {
    readonly id: FieldRef<'Minutes', 'String'>;
    readonly meetingId: FieldRef<'Minutes', 'String'>;
    readonly content: FieldRef<'Minutes', 'String'>;
    readonly status: FieldRef<'Minutes', 'MinutesStatus'>;
    readonly reviewerId: FieldRef<'Minutes', 'String'>;
    readonly createdAt: FieldRef<'Minutes', 'DateTime'>;
    readonly updatedAt: FieldRef<'Minutes', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Minutes findUnique
   */
  export type MinutesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    /**
     * Filter, which Minutes to fetch.
     */
    where: MinutesWhereUniqueInput;
  };

  /**
   * Minutes findUniqueOrThrow
   */
  export type MinutesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    /**
     * Filter, which Minutes to fetch.
     */
    where: MinutesWhereUniqueInput;
  };

  /**
   * Minutes findFirst
   */
  export type MinutesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    /**
     * Filter, which Minutes to fetch.
     */
    where?: MinutesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Minutes to fetch.
     */
    orderBy?:
      | MinutesOrderByWithRelationInput
      | MinutesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Minutes.
     */
    cursor?: MinutesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Minutes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Minutes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Minutes.
     */
    distinct?: MinutesScalarFieldEnum | MinutesScalarFieldEnum[];
  };

  /**
   * Minutes findFirstOrThrow
   */
  export type MinutesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    /**
     * Filter, which Minutes to fetch.
     */
    where?: MinutesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Minutes to fetch.
     */
    orderBy?:
      | MinutesOrderByWithRelationInput
      | MinutesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Minutes.
     */
    cursor?: MinutesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Minutes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Minutes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Minutes.
     */
    distinct?: MinutesScalarFieldEnum | MinutesScalarFieldEnum[];
  };

  /**
   * Minutes findMany
   */
  export type MinutesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    /**
     * Filter, which Minutes to fetch.
     */
    where?: MinutesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Minutes to fetch.
     */
    orderBy?:
      | MinutesOrderByWithRelationInput
      | MinutesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Minutes.
     */
    cursor?: MinutesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Minutes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Minutes.
     */
    skip?: number;
    distinct?: MinutesScalarFieldEnum | MinutesScalarFieldEnum[];
  };

  /**
   * Minutes create
   */
  export type MinutesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    /**
     * The data needed to create a Minutes.
     */
    data: XOR<MinutesCreateInput, MinutesUncheckedCreateInput>;
  };

  /**
   * Minutes createMany
   */
  export type MinutesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Minutes.
     */
    data: MinutesCreateManyInput | MinutesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Minutes createManyAndReturn
   */
  export type MinutesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * The data used to create many Minutes.
     */
    data: MinutesCreateManyInput | MinutesCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Minutes update
   */
  export type MinutesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    /**
     * The data needed to update a Minutes.
     */
    data: XOR<MinutesUpdateInput, MinutesUncheckedUpdateInput>;
    /**
     * Choose, which Minutes to update.
     */
    where: MinutesWhereUniqueInput;
  };

  /**
   * Minutes updateMany
   */
  export type MinutesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Minutes.
     */
    data: XOR<MinutesUpdateManyMutationInput, MinutesUncheckedUpdateManyInput>;
    /**
     * Filter which Minutes to update
     */
    where?: MinutesWhereInput;
    /**
     * Limit how many Minutes to update.
     */
    limit?: number;
  };

  /**
   * Minutes updateManyAndReturn
   */
  export type MinutesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * The data used to update Minutes.
     */
    data: XOR<MinutesUpdateManyMutationInput, MinutesUncheckedUpdateManyInput>;
    /**
     * Filter which Minutes to update
     */
    where?: MinutesWhereInput;
    /**
     * Limit how many Minutes to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Minutes upsert
   */
  export type MinutesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    /**
     * The filter to search for the Minutes to update in case it exists.
     */
    where: MinutesWhereUniqueInput;
    /**
     * In case the Minutes found by the `where` argument doesn't exist, create a new Minutes with this data.
     */
    create: XOR<MinutesCreateInput, MinutesUncheckedCreateInput>;
    /**
     * In case the Minutes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MinutesUpdateInput, MinutesUncheckedUpdateInput>;
  };

  /**
   * Minutes delete
   */
  export type MinutesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
    /**
     * Filter which Minutes to delete.
     */
    where: MinutesWhereUniqueInput;
  };

  /**
   * Minutes deleteMany
   */
  export type MinutesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Minutes to delete
     */
    where?: MinutesWhereInput;
    /**
     * Limit how many Minutes to delete.
     */
    limit?: number;
  };

  /**
   * Minutes.reviewer
   */
  export type Minutes$reviewerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Minutes.versions
   */
  export type Minutes$versionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    where?: MinutesVersionWhereInput;
    orderBy?:
      | MinutesVersionOrderByWithRelationInput
      | MinutesVersionOrderByWithRelationInput[];
    cursor?: MinutesVersionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MinutesVersionScalarFieldEnum | MinutesVersionScalarFieldEnum[];
  };

  /**
   * Minutes without action
   */
  export type MinutesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Minutes
     */
    select?: MinutesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Minutes
     */
    omit?: MinutesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesInclude<ExtArgs> | null;
  };

  /**
   * Model MinutesVersion
   */

  export type AggregateMinutesVersion = {
    _count: MinutesVersionCountAggregateOutputType | null;
    _avg: MinutesVersionAvgAggregateOutputType | null;
    _sum: MinutesVersionSumAggregateOutputType | null;
    _min: MinutesVersionMinAggregateOutputType | null;
    _max: MinutesVersionMaxAggregateOutputType | null;
  };

  export type MinutesVersionAvgAggregateOutputType = {
    version: number | null;
  };

  export type MinutesVersionSumAggregateOutputType = {
    version: number | null;
  };

  export type MinutesVersionMinAggregateOutputType = {
    id: string | null;
    minutesId: string | null;
    content: string | null;
    version: number | null;
    createdAt: Date | null;
  };

  export type MinutesVersionMaxAggregateOutputType = {
    id: string | null;
    minutesId: string | null;
    content: string | null;
    version: number | null;
    createdAt: Date | null;
  };

  export type MinutesVersionCountAggregateOutputType = {
    id: number;
    minutesId: number;
    content: number;
    version: number;
    createdAt: number;
    _all: number;
  };

  export type MinutesVersionAvgAggregateInputType = {
    version?: true;
  };

  export type MinutesVersionSumAggregateInputType = {
    version?: true;
  };

  export type MinutesVersionMinAggregateInputType = {
    id?: true;
    minutesId?: true;
    content?: true;
    version?: true;
    createdAt?: true;
  };

  export type MinutesVersionMaxAggregateInputType = {
    id?: true;
    minutesId?: true;
    content?: true;
    version?: true;
    createdAt?: true;
  };

  export type MinutesVersionCountAggregateInputType = {
    id?: true;
    minutesId?: true;
    content?: true;
    version?: true;
    createdAt?: true;
    _all?: true;
  };

  export type MinutesVersionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MinutesVersion to aggregate.
     */
    where?: MinutesVersionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MinutesVersions to fetch.
     */
    orderBy?:
      | MinutesVersionOrderByWithRelationInput
      | MinutesVersionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MinutesVersionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MinutesVersions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MinutesVersions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned MinutesVersions
     **/
    _count?: true | MinutesVersionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MinutesVersionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MinutesVersionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MinutesVersionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MinutesVersionMaxAggregateInputType;
  };

  export type GetMinutesVersionAggregateType<
    T extends MinutesVersionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateMinutesVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinutesVersion[P]>
      : GetScalarType<T[P], AggregateMinutesVersion[P]>;
  };

  export type MinutesVersionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MinutesVersionWhereInput;
    orderBy?:
      | MinutesVersionOrderByWithAggregationInput
      | MinutesVersionOrderByWithAggregationInput[];
    by: MinutesVersionScalarFieldEnum[] | MinutesVersionScalarFieldEnum;
    having?: MinutesVersionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MinutesVersionCountAggregateInputType | true;
    _avg?: MinutesVersionAvgAggregateInputType;
    _sum?: MinutesVersionSumAggregateInputType;
    _min?: MinutesVersionMinAggregateInputType;
    _max?: MinutesVersionMaxAggregateInputType;
  };

  export type MinutesVersionGroupByOutputType = {
    id: string;
    minutesId: string;
    content: string;
    version: number;
    createdAt: Date;
    _count: MinutesVersionCountAggregateOutputType | null;
    _avg: MinutesVersionAvgAggregateOutputType | null;
    _sum: MinutesVersionSumAggregateOutputType | null;
    _min: MinutesVersionMinAggregateOutputType | null;
    _max: MinutesVersionMaxAggregateOutputType | null;
  };

  type GetMinutesVersionGroupByPayload<T extends MinutesVersionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MinutesVersionGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof MinutesVersionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinutesVersionGroupByOutputType[P]>
            : GetScalarType<T[P], MinutesVersionGroupByOutputType[P]>;
        }
      >
    >;

  export type MinutesVersionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      minutesId?: boolean;
      content?: boolean;
      version?: boolean;
      createdAt?: boolean;
      minutes?: boolean | MinutesDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['minutesVersion']
  >;

  export type MinutesVersionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      minutesId?: boolean;
      content?: boolean;
      version?: boolean;
      createdAt?: boolean;
      minutes?: boolean | MinutesDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['minutesVersion']
  >;

  export type MinutesVersionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      minutesId?: boolean;
      content?: boolean;
      version?: boolean;
      createdAt?: boolean;
      minutes?: boolean | MinutesDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['minutesVersion']
  >;

  export type MinutesVersionSelectScalar = {
    id?: boolean;
    minutesId?: boolean;
    content?: boolean;
    version?: boolean;
    createdAt?: boolean;
  };

  export type MinutesVersionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'minutesId' | 'content' | 'version' | 'createdAt',
    ExtArgs['result']['minutesVersion']
  >;
  export type MinutesVersionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    minutes?: boolean | MinutesDefaultArgs<ExtArgs>;
  };
  export type MinutesVersionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    minutes?: boolean | MinutesDefaultArgs<ExtArgs>;
  };
  export type MinutesVersionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    minutes?: boolean | MinutesDefaultArgs<ExtArgs>;
  };

  export type $MinutesVersionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'MinutesVersion';
    objects: {
      minutes: Prisma.$MinutesPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        minutesId: string;
        content: string;
        version: number;
        createdAt: Date;
      },
      ExtArgs['result']['minutesVersion']
    >;
    composites: {};
  };

  type MinutesVersionGetPayload<
    S extends boolean | null | undefined | MinutesVersionDefaultArgs,
  > = $Result.GetResult<Prisma.$MinutesVersionPayload, S>;

  type MinutesVersionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    MinutesVersionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: MinutesVersionCountAggregateInputType | true;
  };

  export interface MinutesVersionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['MinutesVersion'];
      meta: { name: 'MinutesVersion' };
    };
    /**
     * Find zero or one MinutesVersion that matches the filter.
     * @param {MinutesVersionFindUniqueArgs} args - Arguments to find a MinutesVersion
     * @example
     * // Get one MinutesVersion
     * const minutesVersion = await prisma.minutesVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MinutesVersionFindUniqueArgs>(
      args: SelectSubset<T, MinutesVersionFindUniqueArgs<ExtArgs>>,
    ): Prisma__MinutesVersionClient<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one MinutesVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MinutesVersionFindUniqueOrThrowArgs} args - Arguments to find a MinutesVersion
     * @example
     * // Get one MinutesVersion
     * const minutesVersion = await prisma.minutesVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MinutesVersionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MinutesVersionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__MinutesVersionClient<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MinutesVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesVersionFindFirstArgs} args - Arguments to find a MinutesVersion
     * @example
     * // Get one MinutesVersion
     * const minutesVersion = await prisma.minutesVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MinutesVersionFindFirstArgs>(
      args?: SelectSubset<T, MinutesVersionFindFirstArgs<ExtArgs>>,
    ): Prisma__MinutesVersionClient<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MinutesVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesVersionFindFirstOrThrowArgs} args - Arguments to find a MinutesVersion
     * @example
     * // Get one MinutesVersion
     * const minutesVersion = await prisma.minutesVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MinutesVersionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MinutesVersionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__MinutesVersionClient<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more MinutesVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MinutesVersions
     * const minutesVersions = await prisma.minutesVersion.findMany()
     *
     * // Get first 10 MinutesVersions
     * const minutesVersions = await prisma.minutesVersion.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const minutesVersionWithIdOnly = await prisma.minutesVersion.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MinutesVersionFindManyArgs>(
      args?: SelectSubset<T, MinutesVersionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a MinutesVersion.
     * @param {MinutesVersionCreateArgs} args - Arguments to create a MinutesVersion.
     * @example
     * // Create one MinutesVersion
     * const MinutesVersion = await prisma.minutesVersion.create({
     *   data: {
     *     // ... data to create a MinutesVersion
     *   }
     * })
     *
     */
    create<T extends MinutesVersionCreateArgs>(
      args: SelectSubset<T, MinutesVersionCreateArgs<ExtArgs>>,
    ): Prisma__MinutesVersionClient<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many MinutesVersions.
     * @param {MinutesVersionCreateManyArgs} args - Arguments to create many MinutesVersions.
     * @example
     * // Create many MinutesVersions
     * const minutesVersion = await prisma.minutesVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MinutesVersionCreateManyArgs>(
      args?: SelectSubset<T, MinutesVersionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many MinutesVersions and returns the data saved in the database.
     * @param {MinutesVersionCreateManyAndReturnArgs} args - Arguments to create many MinutesVersions.
     * @example
     * // Create many MinutesVersions
     * const minutesVersion = await prisma.minutesVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many MinutesVersions and only return the `id`
     * const minutesVersionWithIdOnly = await prisma.minutesVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MinutesVersionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MinutesVersionCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a MinutesVersion.
     * @param {MinutesVersionDeleteArgs} args - Arguments to delete one MinutesVersion.
     * @example
     * // Delete one MinutesVersion
     * const MinutesVersion = await prisma.minutesVersion.delete({
     *   where: {
     *     // ... filter to delete one MinutesVersion
     *   }
     * })
     *
     */
    delete<T extends MinutesVersionDeleteArgs>(
      args: SelectSubset<T, MinutesVersionDeleteArgs<ExtArgs>>,
    ): Prisma__MinutesVersionClient<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one MinutesVersion.
     * @param {MinutesVersionUpdateArgs} args - Arguments to update one MinutesVersion.
     * @example
     * // Update one MinutesVersion
     * const minutesVersion = await prisma.minutesVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MinutesVersionUpdateArgs>(
      args: SelectSubset<T, MinutesVersionUpdateArgs<ExtArgs>>,
    ): Prisma__MinutesVersionClient<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more MinutesVersions.
     * @param {MinutesVersionDeleteManyArgs} args - Arguments to filter MinutesVersions to delete.
     * @example
     * // Delete a few MinutesVersions
     * const { count } = await prisma.minutesVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MinutesVersionDeleteManyArgs>(
      args?: SelectSubset<T, MinutesVersionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MinutesVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MinutesVersions
     * const minutesVersion = await prisma.minutesVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MinutesVersionUpdateManyArgs>(
      args: SelectSubset<T, MinutesVersionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MinutesVersions and returns the data updated in the database.
     * @param {MinutesVersionUpdateManyAndReturnArgs} args - Arguments to update many MinutesVersions.
     * @example
     * // Update many MinutesVersions
     * const minutesVersion = await prisma.minutesVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more MinutesVersions and only return the `id`
     * const minutesVersionWithIdOnly = await prisma.minutesVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MinutesVersionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MinutesVersionUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one MinutesVersion.
     * @param {MinutesVersionUpsertArgs} args - Arguments to update or create a MinutesVersion.
     * @example
     * // Update or create a MinutesVersion
     * const minutesVersion = await prisma.minutesVersion.upsert({
     *   create: {
     *     // ... data to create a MinutesVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MinutesVersion we want to update
     *   }
     * })
     */
    upsert<T extends MinutesVersionUpsertArgs>(
      args: SelectSubset<T, MinutesVersionUpsertArgs<ExtArgs>>,
    ): Prisma__MinutesVersionClient<
      $Result.GetResult<
        Prisma.$MinutesVersionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of MinutesVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesVersionCountArgs} args - Arguments to filter MinutesVersions to count.
     * @example
     * // Count the number of MinutesVersions
     * const count = await prisma.minutesVersion.count({
     *   where: {
     *     // ... the filter for the MinutesVersions we want to count
     *   }
     * })
     **/
    count<T extends MinutesVersionCountArgs>(
      args?: Subset<T, MinutesVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinutesVersionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a MinutesVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MinutesVersionAggregateArgs>(
      args: Subset<T, MinutesVersionAggregateArgs>,
    ): Prisma.PrismaPromise<GetMinutesVersionAggregateType<T>>;

    /**
     * Group by MinutesVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinutesVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MinutesVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MinutesVersionGroupByArgs['orderBy'] }
        : { orderBy?: MinutesVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MinutesVersionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetMinutesVersionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the MinutesVersion model
     */
    readonly fields: MinutesVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MinutesVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MinutesVersionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    minutes<T extends MinutesDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MinutesDefaultArgs<ExtArgs>>,
    ): Prisma__MinutesClient<
      | $Result.GetResult<
          Prisma.$MinutesPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the MinutesVersion model
   */
  interface MinutesVersionFieldRefs {
    readonly id: FieldRef<'MinutesVersion', 'String'>;
    readonly minutesId: FieldRef<'MinutesVersion', 'String'>;
    readonly content: FieldRef<'MinutesVersion', 'String'>;
    readonly version: FieldRef<'MinutesVersion', 'Int'>;
    readonly createdAt: FieldRef<'MinutesVersion', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * MinutesVersion findUnique
   */
  export type MinutesVersionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesVersion to fetch.
     */
    where: MinutesVersionWhereUniqueInput;
  };

  /**
   * MinutesVersion findUniqueOrThrow
   */
  export type MinutesVersionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesVersion to fetch.
     */
    where: MinutesVersionWhereUniqueInput;
  };

  /**
   * MinutesVersion findFirst
   */
  export type MinutesVersionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesVersion to fetch.
     */
    where?: MinutesVersionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MinutesVersions to fetch.
     */
    orderBy?:
      | MinutesVersionOrderByWithRelationInput
      | MinutesVersionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MinutesVersions.
     */
    cursor?: MinutesVersionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MinutesVersions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MinutesVersions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MinutesVersions.
     */
    distinct?: MinutesVersionScalarFieldEnum | MinutesVersionScalarFieldEnum[];
  };

  /**
   * MinutesVersion findFirstOrThrow
   */
  export type MinutesVersionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesVersion to fetch.
     */
    where?: MinutesVersionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MinutesVersions to fetch.
     */
    orderBy?:
      | MinutesVersionOrderByWithRelationInput
      | MinutesVersionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MinutesVersions.
     */
    cursor?: MinutesVersionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MinutesVersions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MinutesVersions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MinutesVersions.
     */
    distinct?: MinutesVersionScalarFieldEnum | MinutesVersionScalarFieldEnum[];
  };

  /**
   * MinutesVersion findMany
   */
  export type MinutesVersionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    /**
     * Filter, which MinutesVersions to fetch.
     */
    where?: MinutesVersionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MinutesVersions to fetch.
     */
    orderBy?:
      | MinutesVersionOrderByWithRelationInput
      | MinutesVersionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing MinutesVersions.
     */
    cursor?: MinutesVersionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MinutesVersions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MinutesVersions.
     */
    skip?: number;
    distinct?: MinutesVersionScalarFieldEnum | MinutesVersionScalarFieldEnum[];
  };

  /**
   * MinutesVersion create
   */
  export type MinutesVersionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    /**
     * The data needed to create a MinutesVersion.
     */
    data: XOR<MinutesVersionCreateInput, MinutesVersionUncheckedCreateInput>;
  };

  /**
   * MinutesVersion createMany
   */
  export type MinutesVersionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many MinutesVersions.
     */
    data: MinutesVersionCreateManyInput | MinutesVersionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * MinutesVersion createManyAndReturn
   */
  export type MinutesVersionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * The data used to create many MinutesVersions.
     */
    data: MinutesVersionCreateManyInput | MinutesVersionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MinutesVersion update
   */
  export type MinutesVersionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    /**
     * The data needed to update a MinutesVersion.
     */
    data: XOR<MinutesVersionUpdateInput, MinutesVersionUncheckedUpdateInput>;
    /**
     * Choose, which MinutesVersion to update.
     */
    where: MinutesVersionWhereUniqueInput;
  };

  /**
   * MinutesVersion updateMany
   */
  export type MinutesVersionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update MinutesVersions.
     */
    data: XOR<
      MinutesVersionUpdateManyMutationInput,
      MinutesVersionUncheckedUpdateManyInput
    >;
    /**
     * Filter which MinutesVersions to update
     */
    where?: MinutesVersionWhereInput;
    /**
     * Limit how many MinutesVersions to update.
     */
    limit?: number;
  };

  /**
   * MinutesVersion updateManyAndReturn
   */
  export type MinutesVersionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * The data used to update MinutesVersions.
     */
    data: XOR<
      MinutesVersionUpdateManyMutationInput,
      MinutesVersionUncheckedUpdateManyInput
    >;
    /**
     * Filter which MinutesVersions to update
     */
    where?: MinutesVersionWhereInput;
    /**
     * Limit how many MinutesVersions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MinutesVersion upsert
   */
  export type MinutesVersionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    /**
     * The filter to search for the MinutesVersion to update in case it exists.
     */
    where: MinutesVersionWhereUniqueInput;
    /**
     * In case the MinutesVersion found by the `where` argument doesn't exist, create a new MinutesVersion with this data.
     */
    create: XOR<MinutesVersionCreateInput, MinutesVersionUncheckedCreateInput>;
    /**
     * In case the MinutesVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MinutesVersionUpdateInput, MinutesVersionUncheckedUpdateInput>;
  };

  /**
   * MinutesVersion delete
   */
  export type MinutesVersionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
    /**
     * Filter which MinutesVersion to delete.
     */
    where: MinutesVersionWhereUniqueInput;
  };

  /**
   * MinutesVersion deleteMany
   */
  export type MinutesVersionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MinutesVersions to delete
     */
    where?: MinutesVersionWhereInput;
    /**
     * Limit how many MinutesVersions to delete.
     */
    limit?: number;
  };

  /**
   * MinutesVersion without action
   */
  export type MinutesVersionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MinutesVersion
     */
    select?: MinutesVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MinutesVersion
     */
    omit?: MinutesVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinutesVersionInclude<ExtArgs> | null;
  };

  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null;
    _min: NotificationPreferenceMinAggregateOutputType | null;
    _max: NotificationPreferenceMaxAggregateOutputType | null;
  };

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    email: boolean | null;
    push: boolean | null;
    deviceToken: string | null;
  };

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    email: boolean | null;
    push: boolean | null;
    deviceToken: string | null;
  };

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number;
    userId: number;
    email: number;
    push: number;
    deviceToken: number;
    _all: number;
  };

  export type NotificationPreferenceMinAggregateInputType = {
    id?: true;
    userId?: true;
    email?: true;
    push?: true;
    deviceToken?: true;
  };

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true;
    userId?: true;
    email?: true;
    push?: true;
    deviceToken?: true;
  };

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true;
    userId?: true;
    email?: true;
    push?: true;
    deviceToken?: true;
    _all?: true;
  };

  export type NotificationPreferenceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?:
      | NotificationPreferenceOrderByWithRelationInput
      | NotificationPreferenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationPreferences
     **/
    _count?: true | NotificationPreferenceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationPreferenceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationPreferenceMaxAggregateInputType;
  };

  export type GetNotificationPreferenceAggregateType<
    T extends NotificationPreferenceAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateNotificationPreference]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>;
  };

  export type NotificationPreferenceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationPreferenceWhereInput;
    orderBy?:
      | NotificationPreferenceOrderByWithAggregationInput
      | NotificationPreferenceOrderByWithAggregationInput[];
    by:
      | NotificationPreferenceScalarFieldEnum[]
      | NotificationPreferenceScalarFieldEnum;
    having?: NotificationPreferenceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationPreferenceCountAggregateInputType | true;
    _min?: NotificationPreferenceMinAggregateInputType;
    _max?: NotificationPreferenceMaxAggregateInputType;
  };

  export type NotificationPreferenceGroupByOutputType = {
    id: string;
    userId: string;
    email: boolean;
    push: boolean;
    deviceToken: string | null;
    _count: NotificationPreferenceCountAggregateOutputType | null;
    _min: NotificationPreferenceMinAggregateOutputType | null;
    _max: NotificationPreferenceMaxAggregateOutputType | null;
  };

  type GetNotificationPreferenceGroupByPayload<
    T extends NotificationPreferenceGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof NotificationPreferenceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
          : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>;
      }
    >
  >;

  export type NotificationPreferenceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      email?: boolean;
      push?: boolean;
      deviceToken?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationPreference']
  >;

  export type NotificationPreferenceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      email?: boolean;
      push?: boolean;
      deviceToken?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationPreference']
  >;

  export type NotificationPreferenceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      email?: boolean;
      push?: boolean;
      deviceToken?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationPreference']
  >;

  export type NotificationPreferenceSelectScalar = {
    id?: boolean;
    userId?: boolean;
    email?: boolean;
    push?: boolean;
    deviceToken?: boolean;
  };

  export type NotificationPreferenceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'userId' | 'email' | 'push' | 'deviceToken',
    ExtArgs['result']['notificationPreference']
  >;
  export type NotificationPreferenceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationPreferenceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationPreferenceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $NotificationPreferencePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationPreference';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        email: boolean;
        push: boolean;
        deviceToken: string | null;
      },
      ExtArgs['result']['notificationPreference']
    >;
    composites: {};
  };

  type NotificationPreferenceGetPayload<
    S extends boolean | null | undefined | NotificationPreferenceDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>;

  type NotificationPreferenceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    NotificationPreferenceFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: NotificationPreferenceCountAggregateInputType | true;
  };

  export interface NotificationPreferenceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'];
      meta: { name: 'NotificationPreference' };
    };
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(
      args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
      >,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(
      args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
      >,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     *
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(
      args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     *
     */
    create<T extends NotificationPreferenceCreateArgs>(
      args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(
      args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends NotificationPreferenceCreateManyAndReturnArgs,
    >(
      args?: SelectSubset<
        T,
        NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     *
     */
    delete<T extends NotificationPreferenceDeleteArgs>(
      args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationPreferenceUpdateArgs>(
      args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(
      args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(
      args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends NotificationPreferenceUpdateManyAndReturnArgs,
    >(
      args: SelectSubset<
        T,
        NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(
      args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
     **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              NotificationPreferenceCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(
      args: Subset<T, NotificationPreferenceAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>;

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        NotificationPreferenceGroupByArgs,
        OrderByArg
      > &
        InputErrors,
    ): {} extends InputErrors
      ? GetNotificationPreferenceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationPreference model
     */
    readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<'NotificationPreference', 'String'>;
    readonly userId: FieldRef<'NotificationPreference', 'String'>;
    readonly email: FieldRef<'NotificationPreference', 'Boolean'>;
    readonly push: FieldRef<'NotificationPreference', 'Boolean'>;
    readonly deviceToken: FieldRef<'NotificationPreference', 'String'>;
  }

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput;
  };

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput;
  };

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?:
      | NotificationPreferenceOrderByWithRelationInput
      | NotificationPreferenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?:
      | NotificationPreferenceScalarFieldEnum
      | NotificationPreferenceScalarFieldEnum[];
  };

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?:
      | NotificationPreferenceOrderByWithRelationInput
      | NotificationPreferenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?:
      | NotificationPreferenceScalarFieldEnum
      | NotificationPreferenceScalarFieldEnum[];
  };

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?:
      | NotificationPreferenceOrderByWithRelationInput
      | NotificationPreferenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number;
    distinct?:
      | NotificationPreferenceScalarFieldEnum
      | NotificationPreferenceScalarFieldEnum[];
  };

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<
      NotificationPreferenceCreateInput,
      NotificationPreferenceUncheckedCreateInput
    >;
  };

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data:
      | NotificationPreferenceCreateManyInput
      | NotificationPreferenceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationPreferences.
     */
    data:
      | NotificationPreferenceCreateManyInput
      | NotificationPreferenceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<
      NotificationPreferenceUpdateInput,
      NotificationPreferenceUncheckedUpdateInput
    >;
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput;
  };

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<
      NotificationPreferenceUpdateManyMutationInput,
      NotificationPreferenceUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number;
  };

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<
      NotificationPreferenceUpdateManyMutationInput,
      NotificationPreferenceUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput;
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<
      NotificationPreferenceCreateInput,
      NotificationPreferenceUncheckedCreateInput
    >;
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      NotificationPreferenceUpdateInput,
      NotificationPreferenceUncheckedUpdateInput
    >;
  };

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput;
  };

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number;
  };

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
  };

  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null;
    _min: TagMinAggregateOutputType | null;
    _max: TagMaxAggregateOutputType | null;
  };

  export type TagMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    name: string | null;
    color: string | null;
    createdAt: Date | null;
  };

  export type TagMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    name: string | null;
    color: string | null;
    createdAt: Date | null;
  };

  export type TagCountAggregateOutputType = {
    id: number;
    userId: number;
    organizationId: number;
    name: number;
    color: number;
    createdAt: number;
    _all: number;
  };

  export type TagMinAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    name?: true;
    color?: true;
    createdAt?: true;
  };

  export type TagMaxAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    name?: true;
    color?: true;
    createdAt?: true;
  };

  export type TagCountAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    name?: true;
    color?: true;
    createdAt?: true;
    _all?: true;
  };

  export type TagAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Tags
     **/
    _count?: true | TagCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TagMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TagMaxAggregateInputType;
  };

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
    [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>;
  };

  export type TagGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TagWhereInput;
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[];
    by: TagScalarFieldEnum[] | TagScalarFieldEnum;
    having?: TagScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TagCountAggregateInputType | true;
    _min?: TagMinAggregateInputType;
    _max?: TagMaxAggregateInputType;
  };

  export type TagGroupByOutputType = {
    id: string;
    userId: string;
    organizationId: string | null;
    name: string;
    color: string;
    createdAt: Date;
    _count: TagCountAggregateOutputType | null;
    _min: TagMinAggregateOutputType | null;
    _max: TagMaxAggregateOutputType | null;
  };

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TagGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TagGroupByOutputType[P]>
          : GetScalarType<T[P], TagGroupByOutputType[P]>;
      }
    >
  >;

  export type TagSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      name?: boolean;
      color?: boolean;
      createdAt?: boolean;
      meetings?: boolean | Tag$meetingsArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | Tag$organizationArgs<ExtArgs>;
      _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['tag']
  >;

  export type TagSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      name?: boolean;
      color?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | Tag$organizationArgs<ExtArgs>;
    },
    ExtArgs['result']['tag']
  >;

  export type TagSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      name?: boolean;
      color?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | Tag$organizationArgs<ExtArgs>;
    },
    ExtArgs['result']['tag']
  >;

  export type TagSelectScalar = {
    id?: boolean;
    userId?: boolean;
    organizationId?: boolean;
    name?: boolean;
    color?: boolean;
    createdAt?: boolean;
  };

  export type TagOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'userId' | 'organizationId' | 'name' | 'color' | 'createdAt',
    ExtArgs['result']['tag']
  >;
  export type TagInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meetings?: boolean | Tag$meetingsArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | Tag$organizationArgs<ExtArgs>;
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type TagIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | Tag$organizationArgs<ExtArgs>;
  };
  export type TagIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | Tag$organizationArgs<ExtArgs>;
  };

  export type $TagPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Tag';
    objects: {
      meetings: Prisma.$MeetingTagPayload<ExtArgs>[];
      user: Prisma.$UserPayload<ExtArgs>;
      organization: Prisma.$OrganizationPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        organizationId: string | null;
        name: string;
        color: string;
        createdAt: Date;
      },
      ExtArgs['result']['tag']
    >;
    composites: {};
  };

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> =
    $Result.GetResult<Prisma.$TagPayload, S>;

  type TagCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TagCountAggregateInputType | true;
  };

  export interface TagDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Tag'];
      meta: { name: 'Tag' };
    };
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(
      args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(
      args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     *
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TagFindManyArgs>(
      args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     *
     */
    create<T extends TagCreateArgs>(
      args: SelectSubset<T, TagCreateArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TagCreateManyArgs>(
      args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     *
     */
    delete<T extends TagDeleteArgs>(
      args: SelectSubset<T, TagDeleteArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TagUpdateArgs>(
      args: SelectSubset<T, TagUpdateArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TagDeleteManyArgs>(
      args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TagUpdateManyArgs>(
      args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(
      args: SelectSubset<T, TagUpsertArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
     **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TagAggregateArgs>(
      args: Subset<T, TagAggregateArgs>,
    ): Prisma.PrismaPromise<GetTagAggregateType<T>>;

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetTagGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Tag model
     */
    readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    meetings<T extends Tag$meetingsArgs<ExtArgs> = {}>(
      args?: Subset<T, Tag$meetingsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MeetingTagPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends Tag$organizationArgs<ExtArgs> = {}>(
      args?: Subset<T, Tag$organizationArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<'Tag', 'String'>;
    readonly userId: FieldRef<'Tag', 'String'>;
    readonly organizationId: FieldRef<'Tag', 'String'>;
    readonly name: FieldRef<'Tag', 'String'>;
    readonly color: FieldRef<'Tag', 'String'>;
    readonly createdAt: FieldRef<'Tag', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput;
  };

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput;
  };

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[];
  };

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[];
  };

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tags.
     */
    skip?: number;
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[];
  };

  /**
   * Tag create
   */
  export type TagCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>;
  };

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Tag update
   */
  export type TagUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>;
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput;
  };

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>;
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput;
    /**
     * Limit how many Tags to update.
     */
    limit?: number;
  };

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>;
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput;
    /**
     * Limit how many Tags to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput;
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>;
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>;
  };

  /**
   * Tag delete
   */
  export type TagDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput;
  };

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput;
    /**
     * Limit how many Tags to delete.
     */
    limit?: number;
  };

  /**
   * Tag.meetings
   */
  export type Tag$meetingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    where?: MeetingTagWhereInput;
    orderBy?:
      | MeetingTagOrderByWithRelationInput
      | MeetingTagOrderByWithRelationInput[];
    cursor?: MeetingTagWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MeetingTagScalarFieldEnum | MeetingTagScalarFieldEnum[];
  };

  /**
   * Tag.organization
   */
  export type Tag$organizationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    where?: OrganizationWhereInput;
  };

  /**
   * Tag without action
   */
  export type TagDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
  };

  /**
   * Model MeetingTag
   */

  export type AggregateMeetingTag = {
    _count: MeetingTagCountAggregateOutputType | null;
    _min: MeetingTagMinAggregateOutputType | null;
    _max: MeetingTagMaxAggregateOutputType | null;
  };

  export type MeetingTagMinAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    tagId: string | null;
    createdAt: Date | null;
  };

  export type MeetingTagMaxAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    tagId: string | null;
    createdAt: Date | null;
  };

  export type MeetingTagCountAggregateOutputType = {
    id: number;
    meetingId: number;
    tagId: number;
    createdAt: number;
    _all: number;
  };

  export type MeetingTagMinAggregateInputType = {
    id?: true;
    meetingId?: true;
    tagId?: true;
    createdAt?: true;
  };

  export type MeetingTagMaxAggregateInputType = {
    id?: true;
    meetingId?: true;
    tagId?: true;
    createdAt?: true;
  };

  export type MeetingTagCountAggregateInputType = {
    id?: true;
    meetingId?: true;
    tagId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type MeetingTagAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MeetingTag to aggregate.
     */
    where?: MeetingTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MeetingTags to fetch.
     */
    orderBy?:
      | MeetingTagOrderByWithRelationInput
      | MeetingTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MeetingTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MeetingTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MeetingTags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned MeetingTags
     **/
    _count?: true | MeetingTagCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MeetingTagMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MeetingTagMaxAggregateInputType;
  };

  export type GetMeetingTagAggregateType<T extends MeetingTagAggregateArgs> = {
    [P in keyof T & keyof AggregateMeetingTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetingTag[P]>
      : GetScalarType<T[P], AggregateMeetingTag[P]>;
  };

  export type MeetingTagGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MeetingTagWhereInput;
    orderBy?:
      | MeetingTagOrderByWithAggregationInput
      | MeetingTagOrderByWithAggregationInput[];
    by: MeetingTagScalarFieldEnum[] | MeetingTagScalarFieldEnum;
    having?: MeetingTagScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MeetingTagCountAggregateInputType | true;
    _min?: MeetingTagMinAggregateInputType;
    _max?: MeetingTagMaxAggregateInputType;
  };

  export type MeetingTagGroupByOutputType = {
    id: string;
    meetingId: string;
    tagId: string;
    createdAt: Date;
    _count: MeetingTagCountAggregateOutputType | null;
    _min: MeetingTagMinAggregateOutputType | null;
    _max: MeetingTagMaxAggregateOutputType | null;
  };

  type GetMeetingTagGroupByPayload<T extends MeetingTagGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MeetingTagGroupByOutputType, T['by']> & {
          [P in keyof T & keyof MeetingTagGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingTagGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingTagGroupByOutputType[P]>;
        }
      >
    >;

  export type MeetingTagSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      tagId?: boolean;
      createdAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      tag?: boolean | TagDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['meetingTag']
  >;

  export type MeetingTagSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      tagId?: boolean;
      createdAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      tag?: boolean | TagDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['meetingTag']
  >;

  export type MeetingTagSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      tagId?: boolean;
      createdAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
      tag?: boolean | TagDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['meetingTag']
  >;

  export type MeetingTagSelectScalar = {
    id?: boolean;
    meetingId?: boolean;
    tagId?: boolean;
    createdAt?: boolean;
  };

  export type MeetingTagOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'meetingId' | 'tagId' | 'createdAt',
    ExtArgs['result']['meetingTag']
  >;
  export type MeetingTagInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    tag?: boolean | TagDefaultArgs<ExtArgs>;
  };
  export type MeetingTagIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    tag?: boolean | TagDefaultArgs<ExtArgs>;
  };
  export type MeetingTagIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    tag?: boolean | TagDefaultArgs<ExtArgs>;
  };

  export type $MeetingTagPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'MeetingTag';
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>;
      tag: Prisma.$TagPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        meetingId: string;
        tagId: string;
        createdAt: Date;
      },
      ExtArgs['result']['meetingTag']
    >;
    composites: {};
  };

  type MeetingTagGetPayload<
    S extends boolean | null | undefined | MeetingTagDefaultArgs,
  > = $Result.GetResult<Prisma.$MeetingTagPayload, S>;

  type MeetingTagCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    MeetingTagFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: MeetingTagCountAggregateInputType | true;
  };

  export interface MeetingTagDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['MeetingTag'];
      meta: { name: 'MeetingTag' };
    };
    /**
     * Find zero or one MeetingTag that matches the filter.
     * @param {MeetingTagFindUniqueArgs} args - Arguments to find a MeetingTag
     * @example
     * // Get one MeetingTag
     * const meetingTag = await prisma.meetingTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingTagFindUniqueArgs>(
      args: SelectSubset<T, MeetingTagFindUniqueArgs<ExtArgs>>,
    ): Prisma__MeetingTagClient<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one MeetingTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingTagFindUniqueOrThrowArgs} args - Arguments to find a MeetingTag
     * @example
     * // Get one MeetingTag
     * const meetingTag = await prisma.meetingTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingTagFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MeetingTagFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__MeetingTagClient<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MeetingTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingTagFindFirstArgs} args - Arguments to find a MeetingTag
     * @example
     * // Get one MeetingTag
     * const meetingTag = await prisma.meetingTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingTagFindFirstArgs>(
      args?: SelectSubset<T, MeetingTagFindFirstArgs<ExtArgs>>,
    ): Prisma__MeetingTagClient<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MeetingTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingTagFindFirstOrThrowArgs} args - Arguments to find a MeetingTag
     * @example
     * // Get one MeetingTag
     * const meetingTag = await prisma.meetingTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MeetingTagFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__MeetingTagClient<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more MeetingTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeetingTags
     * const meetingTags = await prisma.meetingTag.findMany()
     *
     * // Get first 10 MeetingTags
     * const meetingTags = await prisma.meetingTag.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const meetingTagWithIdOnly = await prisma.meetingTag.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MeetingTagFindManyArgs>(
      args?: SelectSubset<T, MeetingTagFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a MeetingTag.
     * @param {MeetingTagCreateArgs} args - Arguments to create a MeetingTag.
     * @example
     * // Create one MeetingTag
     * const MeetingTag = await prisma.meetingTag.create({
     *   data: {
     *     // ... data to create a MeetingTag
     *   }
     * })
     *
     */
    create<T extends MeetingTagCreateArgs>(
      args: SelectSubset<T, MeetingTagCreateArgs<ExtArgs>>,
    ): Prisma__MeetingTagClient<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many MeetingTags.
     * @param {MeetingTagCreateManyArgs} args - Arguments to create many MeetingTags.
     * @example
     * // Create many MeetingTags
     * const meetingTag = await prisma.meetingTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MeetingTagCreateManyArgs>(
      args?: SelectSubset<T, MeetingTagCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many MeetingTags and returns the data saved in the database.
     * @param {MeetingTagCreateManyAndReturnArgs} args - Arguments to create many MeetingTags.
     * @example
     * // Create many MeetingTags
     * const meetingTag = await prisma.meetingTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many MeetingTags and only return the `id`
     * const meetingTagWithIdOnly = await prisma.meetingTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MeetingTagCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MeetingTagCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a MeetingTag.
     * @param {MeetingTagDeleteArgs} args - Arguments to delete one MeetingTag.
     * @example
     * // Delete one MeetingTag
     * const MeetingTag = await prisma.meetingTag.delete({
     *   where: {
     *     // ... filter to delete one MeetingTag
     *   }
     * })
     *
     */
    delete<T extends MeetingTagDeleteArgs>(
      args: SelectSubset<T, MeetingTagDeleteArgs<ExtArgs>>,
    ): Prisma__MeetingTagClient<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one MeetingTag.
     * @param {MeetingTagUpdateArgs} args - Arguments to update one MeetingTag.
     * @example
     * // Update one MeetingTag
     * const meetingTag = await prisma.meetingTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MeetingTagUpdateArgs>(
      args: SelectSubset<T, MeetingTagUpdateArgs<ExtArgs>>,
    ): Prisma__MeetingTagClient<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more MeetingTags.
     * @param {MeetingTagDeleteManyArgs} args - Arguments to filter MeetingTags to delete.
     * @example
     * // Delete a few MeetingTags
     * const { count } = await prisma.meetingTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MeetingTagDeleteManyArgs>(
      args?: SelectSubset<T, MeetingTagDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MeetingTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeetingTags
     * const meetingTag = await prisma.meetingTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MeetingTagUpdateManyArgs>(
      args: SelectSubset<T, MeetingTagUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MeetingTags and returns the data updated in the database.
     * @param {MeetingTagUpdateManyAndReturnArgs} args - Arguments to update many MeetingTags.
     * @example
     * // Update many MeetingTags
     * const meetingTag = await prisma.meetingTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more MeetingTags and only return the `id`
     * const meetingTagWithIdOnly = await prisma.meetingTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MeetingTagUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MeetingTagUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one MeetingTag.
     * @param {MeetingTagUpsertArgs} args - Arguments to update or create a MeetingTag.
     * @example
     * // Update or create a MeetingTag
     * const meetingTag = await prisma.meetingTag.upsert({
     *   create: {
     *     // ... data to create a MeetingTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeetingTag we want to update
     *   }
     * })
     */
    upsert<T extends MeetingTagUpsertArgs>(
      args: SelectSubset<T, MeetingTagUpsertArgs<ExtArgs>>,
    ): Prisma__MeetingTagClient<
      $Result.GetResult<
        Prisma.$MeetingTagPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of MeetingTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingTagCountArgs} args - Arguments to filter MeetingTags to count.
     * @example
     * // Count the number of MeetingTags
     * const count = await prisma.meetingTag.count({
     *   where: {
     *     // ... the filter for the MeetingTags we want to count
     *   }
     * })
     **/
    count<T extends MeetingTagCountArgs>(
      args?: Subset<T, MeetingTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingTagCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a MeetingTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MeetingTagAggregateArgs>(
      args: Subset<T, MeetingTagAggregateArgs>,
    ): Prisma.PrismaPromise<GetMeetingTagAggregateType<T>>;

    /**
     * Group by MeetingTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MeetingTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingTagGroupByArgs['orderBy'] }
        : { orderBy?: MeetingTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MeetingTagGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetMeetingTagGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the MeetingTag model
     */
    readonly fields: MeetingTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeetingTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingTagClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MeetingDefaultArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      | $Result.GetResult<
          Prisma.$MeetingPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TagDefaultArgs<ExtArgs>>,
    ): Prisma__TagClient<
      | $Result.GetResult<
          Prisma.$TagPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the MeetingTag model
   */
  interface MeetingTagFieldRefs {
    readonly id: FieldRef<'MeetingTag', 'String'>;
    readonly meetingId: FieldRef<'MeetingTag', 'String'>;
    readonly tagId: FieldRef<'MeetingTag', 'String'>;
    readonly createdAt: FieldRef<'MeetingTag', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * MeetingTag findUnique
   */
  export type MeetingTagFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    /**
     * Filter, which MeetingTag to fetch.
     */
    where: MeetingTagWhereUniqueInput;
  };

  /**
   * MeetingTag findUniqueOrThrow
   */
  export type MeetingTagFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    /**
     * Filter, which MeetingTag to fetch.
     */
    where: MeetingTagWhereUniqueInput;
  };

  /**
   * MeetingTag findFirst
   */
  export type MeetingTagFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    /**
     * Filter, which MeetingTag to fetch.
     */
    where?: MeetingTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MeetingTags to fetch.
     */
    orderBy?:
      | MeetingTagOrderByWithRelationInput
      | MeetingTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MeetingTags.
     */
    cursor?: MeetingTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MeetingTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MeetingTags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MeetingTags.
     */
    distinct?: MeetingTagScalarFieldEnum | MeetingTagScalarFieldEnum[];
  };

  /**
   * MeetingTag findFirstOrThrow
   */
  export type MeetingTagFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    /**
     * Filter, which MeetingTag to fetch.
     */
    where?: MeetingTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MeetingTags to fetch.
     */
    orderBy?:
      | MeetingTagOrderByWithRelationInput
      | MeetingTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MeetingTags.
     */
    cursor?: MeetingTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MeetingTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MeetingTags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MeetingTags.
     */
    distinct?: MeetingTagScalarFieldEnum | MeetingTagScalarFieldEnum[];
  };

  /**
   * MeetingTag findMany
   */
  export type MeetingTagFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    /**
     * Filter, which MeetingTags to fetch.
     */
    where?: MeetingTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MeetingTags to fetch.
     */
    orderBy?:
      | MeetingTagOrderByWithRelationInput
      | MeetingTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing MeetingTags.
     */
    cursor?: MeetingTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MeetingTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MeetingTags.
     */
    skip?: number;
    distinct?: MeetingTagScalarFieldEnum | MeetingTagScalarFieldEnum[];
  };

  /**
   * MeetingTag create
   */
  export type MeetingTagCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    /**
     * The data needed to create a MeetingTag.
     */
    data: XOR<MeetingTagCreateInput, MeetingTagUncheckedCreateInput>;
  };

  /**
   * MeetingTag createMany
   */
  export type MeetingTagCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many MeetingTags.
     */
    data: MeetingTagCreateManyInput | MeetingTagCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * MeetingTag createManyAndReturn
   */
  export type MeetingTagCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * The data used to create many MeetingTags.
     */
    data: MeetingTagCreateManyInput | MeetingTagCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MeetingTag update
   */
  export type MeetingTagUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    /**
     * The data needed to update a MeetingTag.
     */
    data: XOR<MeetingTagUpdateInput, MeetingTagUncheckedUpdateInput>;
    /**
     * Choose, which MeetingTag to update.
     */
    where: MeetingTagWhereUniqueInput;
  };

  /**
   * MeetingTag updateMany
   */
  export type MeetingTagUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update MeetingTags.
     */
    data: XOR<
      MeetingTagUpdateManyMutationInput,
      MeetingTagUncheckedUpdateManyInput
    >;
    /**
     * Filter which MeetingTags to update
     */
    where?: MeetingTagWhereInput;
    /**
     * Limit how many MeetingTags to update.
     */
    limit?: number;
  };

  /**
   * MeetingTag updateManyAndReturn
   */
  export type MeetingTagUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * The data used to update MeetingTags.
     */
    data: XOR<
      MeetingTagUpdateManyMutationInput,
      MeetingTagUncheckedUpdateManyInput
    >;
    /**
     * Filter which MeetingTags to update
     */
    where?: MeetingTagWhereInput;
    /**
     * Limit how many MeetingTags to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MeetingTag upsert
   */
  export type MeetingTagUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    /**
     * The filter to search for the MeetingTag to update in case it exists.
     */
    where: MeetingTagWhereUniqueInput;
    /**
     * In case the MeetingTag found by the `where` argument doesn't exist, create a new MeetingTag with this data.
     */
    create: XOR<MeetingTagCreateInput, MeetingTagUncheckedCreateInput>;
    /**
     * In case the MeetingTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingTagUpdateInput, MeetingTagUncheckedUpdateInput>;
  };

  /**
   * MeetingTag delete
   */
  export type MeetingTagDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
    /**
     * Filter which MeetingTag to delete.
     */
    where: MeetingTagWhereUniqueInput;
  };

  /**
   * MeetingTag deleteMany
   */
  export type MeetingTagDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MeetingTags to delete
     */
    where?: MeetingTagWhereInput;
    /**
     * Limit how many MeetingTags to delete.
     */
    limit?: number;
  };

  /**
   * MeetingTag without action
   */
  export type MeetingTagDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MeetingTag
     */
    select?: MeetingTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MeetingTag
     */
    omit?: MeetingTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingTagInclude<ExtArgs> | null;
  };

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  export type NotificationMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: $Enums.NotificationType | null;
    title: string | null;
    message: string | null;
    read: boolean | null;
    meetingId: string | null;
    createdAt: Date | null;
  };

  export type NotificationMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: $Enums.NotificationType | null;
    title: string | null;
    message: string | null;
    read: boolean | null;
    meetingId: string | null;
    createdAt: Date | null;
  };

  export type NotificationCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    title: number;
    message: number;
    read: number;
    meetingId: number;
    createdAt: number;
    _all: number;
  };

  export type NotificationMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    title?: true;
    message?: true;
    read?: true;
    meetingId?: true;
    createdAt?: true;
  };

  export type NotificationMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    title?: true;
    message?: true;
    read?: true;
    meetingId?: true;
    createdAt?: true;
  };

  export type NotificationCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    title?: true;
    message?: true;
    read?: true;
    meetingId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type NotificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationMaxAggregateInputType;
  };

  export type GetNotificationAggregateType<
    T extends NotificationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>;
  };

  export type NotificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
    orderBy?:
      | NotificationOrderByWithAggregationInput
      | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
  };

  export type NotificationGroupByOutputType = {
    id: string;
    userId: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    read: boolean;
    meetingId: string | null;
    createdAt: Date;
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof NotificationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      title?: boolean;
      message?: boolean;
      read?: boolean;
      meetingId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      title?: boolean;
      message?: boolean;
      read?: boolean;
      meetingId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      title?: boolean;
      message?: boolean;
      read?: boolean;
      meetingId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    title?: boolean;
    message?: boolean;
    read?: boolean;
    meetingId?: boolean;
    createdAt?: boolean;
  };

  export type NotificationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'type'
    | 'title'
    | 'message'
    | 'read'
    | 'meetingId'
    | 'createdAt',
    ExtArgs['result']['notification']
  >;
  export type NotificationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $NotificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Notification';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        type: $Enums.NotificationType;
        title: string;
        message: string;
        read: boolean;
        meetingId: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['notification']
    >;
    composites: {};
  };

  type NotificationGetPayload<
    S extends boolean | null | undefined | NotificationDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationPayload, S>;

  type NotificationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    NotificationFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: NotificationCountAggregateInputType | true;
  };

  export interface NotificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notification'];
      meta: { name: 'Notification' };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAggregateArgs>(
      args: Subset<T, NotificationAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationAggregateType<T>>;

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetNotificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<'Notification', 'String'>;
    readonly userId: FieldRef<'Notification', 'String'>;
    readonly type: FieldRef<'Notification', 'NotificationType'>;
    readonly title: FieldRef<'Notification', 'String'>;
    readonly message: FieldRef<'Notification', 'String'>;
    readonly read: FieldRef<'Notification', 'Boolean'>;
    readonly meetingId: FieldRef<'Notification', 'String'>;
    readonly createdAt: FieldRef<'Notification', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification create
   */
  export type NotificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
  };

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to update Notifications.
     */
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
  };

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
  };

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
  };

  /**
   * Model ShareLink
   */

  export type AggregateShareLink = {
    _count: ShareLinkCountAggregateOutputType | null;
    _min: ShareLinkMinAggregateOutputType | null;
    _max: ShareLinkMaxAggregateOutputType | null;
  };

  export type ShareLinkMinAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    token: string | null;
    expiresAt: Date | null;
    shareType: $Enums.ShareType | null;
    createdAt: Date | null;
  };

  export type ShareLinkMaxAggregateOutputType = {
    id: string | null;
    meetingId: string | null;
    token: string | null;
    expiresAt: Date | null;
    shareType: $Enums.ShareType | null;
    createdAt: Date | null;
  };

  export type ShareLinkCountAggregateOutputType = {
    id: number;
    meetingId: number;
    token: number;
    expiresAt: number;
    shareType: number;
    createdAt: number;
    _all: number;
  };

  export type ShareLinkMinAggregateInputType = {
    id?: true;
    meetingId?: true;
    token?: true;
    expiresAt?: true;
    shareType?: true;
    createdAt?: true;
  };

  export type ShareLinkMaxAggregateInputType = {
    id?: true;
    meetingId?: true;
    token?: true;
    expiresAt?: true;
    shareType?: true;
    createdAt?: true;
  };

  export type ShareLinkCountAggregateInputType = {
    id?: true;
    meetingId?: true;
    token?: true;
    expiresAt?: true;
    shareType?: true;
    createdAt?: true;
    _all?: true;
  };

  export type ShareLinkAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ShareLink to aggregate.
     */
    where?: ShareLinkWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?:
      | ShareLinkOrderByWithRelationInput
      | ShareLinkOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ShareLinkWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ShareLinks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ShareLinks
     **/
    _count?: true | ShareLinkCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ShareLinkMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ShareLinkMaxAggregateInputType;
  };

  export type GetShareLinkAggregateType<T extends ShareLinkAggregateArgs> = {
    [P in keyof T & keyof AggregateShareLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareLink[P]>
      : GetScalarType<T[P], AggregateShareLink[P]>;
  };

  export type ShareLinkGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ShareLinkWhereInput;
    orderBy?:
      | ShareLinkOrderByWithAggregationInput
      | ShareLinkOrderByWithAggregationInput[];
    by: ShareLinkScalarFieldEnum[] | ShareLinkScalarFieldEnum;
    having?: ShareLinkScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ShareLinkCountAggregateInputType | true;
    _min?: ShareLinkMinAggregateInputType;
    _max?: ShareLinkMaxAggregateInputType;
  };

  export type ShareLinkGroupByOutputType = {
    id: string;
    meetingId: string;
    token: string;
    expiresAt: Date | null;
    shareType: $Enums.ShareType;
    createdAt: Date;
    _count: ShareLinkCountAggregateOutputType | null;
    _min: ShareLinkMinAggregateOutputType | null;
    _max: ShareLinkMaxAggregateOutputType | null;
  };

  type GetShareLinkGroupByPayload<T extends ShareLinkGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ShareLinkGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ShareLinkGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ShareLinkGroupByOutputType[P]>;
        }
      >
    >;

  export type ShareLinkSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      token?: boolean;
      expiresAt?: boolean;
      shareType?: boolean;
      createdAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['shareLink']
  >;

  export type ShareLinkSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      token?: boolean;
      expiresAt?: boolean;
      shareType?: boolean;
      createdAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['shareLink']
  >;

  export type ShareLinkSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      meetingId?: boolean;
      token?: boolean;
      expiresAt?: boolean;
      shareType?: boolean;
      createdAt?: boolean;
      meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['shareLink']
  >;

  export type ShareLinkSelectScalar = {
    id?: boolean;
    meetingId?: boolean;
    token?: boolean;
    expiresAt?: boolean;
    shareType?: boolean;
    createdAt?: boolean;
  };

  export type ShareLinkOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'meetingId' | 'token' | 'expiresAt' | 'shareType' | 'createdAt',
    ExtArgs['result']['shareLink']
  >;
  export type ShareLinkInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
  };
  export type ShareLinkIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
  };
  export type ShareLinkIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>;
  };

  export type $ShareLinkPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ShareLink';
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        meetingId: string;
        token: string;
        expiresAt: Date | null;
        shareType: $Enums.ShareType;
        createdAt: Date;
      },
      ExtArgs['result']['shareLink']
    >;
    composites: {};
  };

  type ShareLinkGetPayload<
    S extends boolean | null | undefined | ShareLinkDefaultArgs,
  > = $Result.GetResult<Prisma.$ShareLinkPayload, S>;

  type ShareLinkCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ShareLinkFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ShareLinkCountAggregateInputType | true;
  };

  export interface ShareLinkDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ShareLink'];
      meta: { name: 'ShareLink' };
    };
    /**
     * Find zero or one ShareLink that matches the filter.
     * @param {ShareLinkFindUniqueArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareLinkFindUniqueArgs>(
      args: SelectSubset<T, ShareLinkFindUniqueArgs<ExtArgs>>,
    ): Prisma__ShareLinkClient<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ShareLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShareLinkFindUniqueOrThrowArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareLinkFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ShareLinkFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ShareLinkClient<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ShareLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindFirstArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareLinkFindFirstArgs>(
      args?: SelectSubset<T, ShareLinkFindFirstArgs<ExtArgs>>,
    ): Prisma__ShareLinkClient<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ShareLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindFirstOrThrowArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareLinkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ShareLinkFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ShareLinkClient<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ShareLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShareLinks
     * const shareLinks = await prisma.shareLink.findMany()
     *
     * // Get first 10 ShareLinks
     * const shareLinks = await prisma.shareLink.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ShareLinkFindManyArgs>(
      args?: SelectSubset<T, ShareLinkFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ShareLink.
     * @param {ShareLinkCreateArgs} args - Arguments to create a ShareLink.
     * @example
     * // Create one ShareLink
     * const ShareLink = await prisma.shareLink.create({
     *   data: {
     *     // ... data to create a ShareLink
     *   }
     * })
     *
     */
    create<T extends ShareLinkCreateArgs>(
      args: SelectSubset<T, ShareLinkCreateArgs<ExtArgs>>,
    ): Prisma__ShareLinkClient<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ShareLinks.
     * @param {ShareLinkCreateManyArgs} args - Arguments to create many ShareLinks.
     * @example
     * // Create many ShareLinks
     * const shareLink = await prisma.shareLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ShareLinkCreateManyArgs>(
      args?: SelectSubset<T, ShareLinkCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ShareLinks and returns the data saved in the database.
     * @param {ShareLinkCreateManyAndReturnArgs} args - Arguments to create many ShareLinks.
     * @example
     * // Create many ShareLinks
     * const shareLink = await prisma.shareLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ShareLinks and only return the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ShareLinkCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ShareLinkCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ShareLink.
     * @param {ShareLinkDeleteArgs} args - Arguments to delete one ShareLink.
     * @example
     * // Delete one ShareLink
     * const ShareLink = await prisma.shareLink.delete({
     *   where: {
     *     // ... filter to delete one ShareLink
     *   }
     * })
     *
     */
    delete<T extends ShareLinkDeleteArgs>(
      args: SelectSubset<T, ShareLinkDeleteArgs<ExtArgs>>,
    ): Prisma__ShareLinkClient<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ShareLink.
     * @param {ShareLinkUpdateArgs} args - Arguments to update one ShareLink.
     * @example
     * // Update one ShareLink
     * const shareLink = await prisma.shareLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ShareLinkUpdateArgs>(
      args: SelectSubset<T, ShareLinkUpdateArgs<ExtArgs>>,
    ): Prisma__ShareLinkClient<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ShareLinks.
     * @param {ShareLinkDeleteManyArgs} args - Arguments to filter ShareLinks to delete.
     * @example
     * // Delete a few ShareLinks
     * const { count } = await prisma.shareLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ShareLinkDeleteManyArgs>(
      args?: SelectSubset<T, ShareLinkDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShareLinks
     * const shareLink = await prisma.shareLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ShareLinkUpdateManyArgs>(
      args: SelectSubset<T, ShareLinkUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ShareLinks and returns the data updated in the database.
     * @param {ShareLinkUpdateManyAndReturnArgs} args - Arguments to update many ShareLinks.
     * @example
     * // Update many ShareLinks
     * const shareLink = await prisma.shareLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ShareLinks and only return the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ShareLinkUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ShareLinkUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ShareLink.
     * @param {ShareLinkUpsertArgs} args - Arguments to update or create a ShareLink.
     * @example
     * // Update or create a ShareLink
     * const shareLink = await prisma.shareLink.upsert({
     *   create: {
     *     // ... data to create a ShareLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShareLink we want to update
     *   }
     * })
     */
    upsert<T extends ShareLinkUpsertArgs>(
      args: SelectSubset<T, ShareLinkUpsertArgs<ExtArgs>>,
    ): Prisma__ShareLinkClient<
      $Result.GetResult<
        Prisma.$ShareLinkPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkCountArgs} args - Arguments to filter ShareLinks to count.
     * @example
     * // Count the number of ShareLinks
     * const count = await prisma.shareLink.count({
     *   where: {
     *     // ... the filter for the ShareLinks we want to count
     *   }
     * })
     **/
    count<T extends ShareLinkCountArgs>(
      args?: Subset<T, ShareLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareLinkCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ShareLinkAggregateArgs>(
      args: Subset<T, ShareLinkAggregateArgs>,
    ): Prisma.PrismaPromise<GetShareLinkAggregateType<T>>;

    /**
     * Group by ShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ShareLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareLinkGroupByArgs['orderBy'] }
        : { orderBy?: ShareLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ShareLinkGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetShareLinkGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ShareLink model
     */
    readonly fields: ShareLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShareLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareLinkClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MeetingDefaultArgs<ExtArgs>>,
    ): Prisma__MeetingClient<
      | $Result.GetResult<
          Prisma.$MeetingPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ShareLink model
   */
  interface ShareLinkFieldRefs {
    readonly id: FieldRef<'ShareLink', 'String'>;
    readonly meetingId: FieldRef<'ShareLink', 'String'>;
    readonly token: FieldRef<'ShareLink', 'String'>;
    readonly expiresAt: FieldRef<'ShareLink', 'DateTime'>;
    readonly shareType: FieldRef<'ShareLink', 'ShareType'>;
    readonly createdAt: FieldRef<'ShareLink', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ShareLink findUnique
   */
  export type ShareLinkFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    /**
     * Filter, which ShareLink to fetch.
     */
    where: ShareLinkWhereUniqueInput;
  };

  /**
   * ShareLink findUniqueOrThrow
   */
  export type ShareLinkFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    /**
     * Filter, which ShareLink to fetch.
     */
    where: ShareLinkWhereUniqueInput;
  };

  /**
   * ShareLink findFirst
   */
  export type ShareLinkFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    /**
     * Filter, which ShareLink to fetch.
     */
    where?: ShareLinkWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?:
      | ShareLinkOrderByWithRelationInput
      | ShareLinkOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ShareLinks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ShareLinks.
     */
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[];
  };

  /**
   * ShareLink findFirstOrThrow
   */
  export type ShareLinkFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    /**
     * Filter, which ShareLink to fetch.
     */
    where?: ShareLinkWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?:
      | ShareLinkOrderByWithRelationInput
      | ShareLinkOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ShareLinks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ShareLinks.
     */
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[];
  };

  /**
   * ShareLink findMany
   */
  export type ShareLinkFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    /**
     * Filter, which ShareLinks to fetch.
     */
    where?: ShareLinkWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?:
      | ShareLinkOrderByWithRelationInput
      | ShareLinkOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ShareLinks.
     */
    skip?: number;
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[];
  };

  /**
   * ShareLink create
   */
  export type ShareLinkCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    /**
     * The data needed to create a ShareLink.
     */
    data: XOR<ShareLinkCreateInput, ShareLinkUncheckedCreateInput>;
  };

  /**
   * ShareLink createMany
   */
  export type ShareLinkCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ShareLinks.
     */
    data: ShareLinkCreateManyInput | ShareLinkCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ShareLink createManyAndReturn
   */
  export type ShareLinkCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * The data used to create many ShareLinks.
     */
    data: ShareLinkCreateManyInput | ShareLinkCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ShareLink update
   */
  export type ShareLinkUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    /**
     * The data needed to update a ShareLink.
     */
    data: XOR<ShareLinkUpdateInput, ShareLinkUncheckedUpdateInput>;
    /**
     * Choose, which ShareLink to update.
     */
    where: ShareLinkWhereUniqueInput;
  };

  /**
   * ShareLink updateMany
   */
  export type ShareLinkUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ShareLinks.
     */
    data: XOR<
      ShareLinkUpdateManyMutationInput,
      ShareLinkUncheckedUpdateManyInput
    >;
    /**
     * Filter which ShareLinks to update
     */
    where?: ShareLinkWhereInput;
    /**
     * Limit how many ShareLinks to update.
     */
    limit?: number;
  };

  /**
   * ShareLink updateManyAndReturn
   */
  export type ShareLinkUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * The data used to update ShareLinks.
     */
    data: XOR<
      ShareLinkUpdateManyMutationInput,
      ShareLinkUncheckedUpdateManyInput
    >;
    /**
     * Filter which ShareLinks to update
     */
    where?: ShareLinkWhereInput;
    /**
     * Limit how many ShareLinks to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ShareLink upsert
   */
  export type ShareLinkUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    /**
     * The filter to search for the ShareLink to update in case it exists.
     */
    where: ShareLinkWhereUniqueInput;
    /**
     * In case the ShareLink found by the `where` argument doesn't exist, create a new ShareLink with this data.
     */
    create: XOR<ShareLinkCreateInput, ShareLinkUncheckedCreateInput>;
    /**
     * In case the ShareLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareLinkUpdateInput, ShareLinkUncheckedUpdateInput>;
  };

  /**
   * ShareLink delete
   */
  export type ShareLinkDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
    /**
     * Filter which ShareLink to delete.
     */
    where: ShareLinkWhereUniqueInput;
  };

  /**
   * ShareLink deleteMany
   */
  export type ShareLinkDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ShareLinks to delete
     */
    where?: ShareLinkWhereInput;
    /**
     * Limit how many ShareLinks to delete.
     */
    limit?: number;
  };

  /**
   * ShareLink without action
   */
  export type ShareLinkDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null;
  };

  /**
   * Model CalendarConnection
   */

  export type AggregateCalendarConnection = {
    _count: CalendarConnectionCountAggregateOutputType | null;
    _min: CalendarConnectionMinAggregateOutputType | null;
    _max: CalendarConnectionMaxAggregateOutputType | null;
  };

  export type CalendarConnectionMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    provider: $Enums.CalendarProvider | null;
    accessToken: string | null;
    refreshToken: string | null;
    expiresAt: Date | null;
    lastSyncAt: Date | null;
    status: $Enums.ConnectionStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CalendarConnectionMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    provider: $Enums.CalendarProvider | null;
    accessToken: string | null;
    refreshToken: string | null;
    expiresAt: Date | null;
    lastSyncAt: Date | null;
    status: $Enums.ConnectionStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CalendarConnectionCountAggregateOutputType = {
    id: number;
    userId: number;
    provider: number;
    accessToken: number;
    refreshToken: number;
    expiresAt: number;
    lastSyncAt: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type CalendarConnectionMinAggregateInputType = {
    id?: true;
    userId?: true;
    provider?: true;
    accessToken?: true;
    refreshToken?: true;
    expiresAt?: true;
    lastSyncAt?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CalendarConnectionMaxAggregateInputType = {
    id?: true;
    userId?: true;
    provider?: true;
    accessToken?: true;
    refreshToken?: true;
    expiresAt?: true;
    lastSyncAt?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CalendarConnectionCountAggregateInputType = {
    id?: true;
    userId?: true;
    provider?: true;
    accessToken?: true;
    refreshToken?: true;
    expiresAt?: true;
    lastSyncAt?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type CalendarConnectionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CalendarConnection to aggregate.
     */
    where?: CalendarConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CalendarConnections to fetch.
     */
    orderBy?:
      | CalendarConnectionOrderByWithRelationInput
      | CalendarConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CalendarConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CalendarConnections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CalendarConnections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CalendarConnections
     **/
    _count?: true | CalendarConnectionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CalendarConnectionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CalendarConnectionMaxAggregateInputType;
  };

  export type GetCalendarConnectionAggregateType<
    T extends CalendarConnectionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateCalendarConnection]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarConnection[P]>
      : GetScalarType<T[P], AggregateCalendarConnection[P]>;
  };

  export type CalendarConnectionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CalendarConnectionWhereInput;
    orderBy?:
      | CalendarConnectionOrderByWithAggregationInput
      | CalendarConnectionOrderByWithAggregationInput[];
    by: CalendarConnectionScalarFieldEnum[] | CalendarConnectionScalarFieldEnum;
    having?: CalendarConnectionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CalendarConnectionCountAggregateInputType | true;
    _min?: CalendarConnectionMinAggregateInputType;
    _max?: CalendarConnectionMaxAggregateInputType;
  };

  export type CalendarConnectionGroupByOutputType = {
    id: string;
    userId: string;
    provider: $Enums.CalendarProvider;
    accessToken: string;
    refreshToken: string;
    expiresAt: Date;
    lastSyncAt: Date | null;
    status: $Enums.ConnectionStatus;
    createdAt: Date;
    updatedAt: Date;
    _count: CalendarConnectionCountAggregateOutputType | null;
    _min: CalendarConnectionMinAggregateOutputType | null;
    _max: CalendarConnectionMaxAggregateOutputType | null;
  };

  type GetCalendarConnectionGroupByPayload<
    T extends CalendarConnectionGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarConnectionGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof CalendarConnectionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CalendarConnectionGroupByOutputType[P]>
          : GetScalarType<T[P], CalendarConnectionGroupByOutputType[P]>;
      }
    >
  >;

  export type CalendarConnectionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      provider?: boolean;
      accessToken?: boolean;
      refreshToken?: boolean;
      expiresAt?: boolean;
      lastSyncAt?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      meetings?: boolean | CalendarConnection$meetingsArgs<ExtArgs>;
      _count?: boolean | CalendarConnectionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['calendarConnection']
  >;

  export type CalendarConnectionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      provider?: boolean;
      accessToken?: boolean;
      refreshToken?: boolean;
      expiresAt?: boolean;
      lastSyncAt?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['calendarConnection']
  >;

  export type CalendarConnectionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      provider?: boolean;
      accessToken?: boolean;
      refreshToken?: boolean;
      expiresAt?: boolean;
      lastSyncAt?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['calendarConnection']
  >;

  export type CalendarConnectionSelectScalar = {
    id?: boolean;
    userId?: boolean;
    provider?: boolean;
    accessToken?: boolean;
    refreshToken?: boolean;
    expiresAt?: boolean;
    lastSyncAt?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type CalendarConnectionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'provider'
    | 'accessToken'
    | 'refreshToken'
    | 'expiresAt'
    | 'lastSyncAt'
    | 'status'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['calendarConnection']
  >;
  export type CalendarConnectionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    meetings?: boolean | CalendarConnection$meetingsArgs<ExtArgs>;
    _count?: boolean | CalendarConnectionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CalendarConnectionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type CalendarConnectionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $CalendarConnectionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'CalendarConnection';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      meetings: Prisma.$MeetingPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        provider: $Enums.CalendarProvider;
        accessToken: string;
        refreshToken: string;
        expiresAt: Date;
        lastSyncAt: Date | null;
        status: $Enums.ConnectionStatus;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['calendarConnection']
    >;
    composites: {};
  };

  type CalendarConnectionGetPayload<
    S extends boolean | null | undefined | CalendarConnectionDefaultArgs,
  > = $Result.GetResult<Prisma.$CalendarConnectionPayload, S>;

  type CalendarConnectionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    CalendarConnectionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CalendarConnectionCountAggregateInputType | true;
  };

  export interface CalendarConnectionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['CalendarConnection'];
      meta: { name: 'CalendarConnection' };
    };
    /**
     * Find zero or one CalendarConnection that matches the filter.
     * @param {CalendarConnectionFindUniqueArgs} args - Arguments to find a CalendarConnection
     * @example
     * // Get one CalendarConnection
     * const calendarConnection = await prisma.calendarConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarConnectionFindUniqueArgs>(
      args: SelectSubset<T, CalendarConnectionFindUniqueArgs<ExtArgs>>,
    ): Prisma__CalendarConnectionClient<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CalendarConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarConnectionFindUniqueOrThrowArgs} args - Arguments to find a CalendarConnection
     * @example
     * // Get one CalendarConnection
     * const calendarConnection = await prisma.calendarConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarConnectionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CalendarConnectionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CalendarConnectionClient<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CalendarConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarConnectionFindFirstArgs} args - Arguments to find a CalendarConnection
     * @example
     * // Get one CalendarConnection
     * const calendarConnection = await prisma.calendarConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarConnectionFindFirstArgs>(
      args?: SelectSubset<T, CalendarConnectionFindFirstArgs<ExtArgs>>,
    ): Prisma__CalendarConnectionClient<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CalendarConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarConnectionFindFirstOrThrowArgs} args - Arguments to find a CalendarConnection
     * @example
     * // Get one CalendarConnection
     * const calendarConnection = await prisma.calendarConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarConnectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CalendarConnectionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CalendarConnectionClient<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CalendarConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarConnections
     * const calendarConnections = await prisma.calendarConnection.findMany()
     *
     * // Get first 10 CalendarConnections
     * const calendarConnections = await prisma.calendarConnection.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const calendarConnectionWithIdOnly = await prisma.calendarConnection.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CalendarConnectionFindManyArgs>(
      args?: SelectSubset<T, CalendarConnectionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a CalendarConnection.
     * @param {CalendarConnectionCreateArgs} args - Arguments to create a CalendarConnection.
     * @example
     * // Create one CalendarConnection
     * const CalendarConnection = await prisma.calendarConnection.create({
     *   data: {
     *     // ... data to create a CalendarConnection
     *   }
     * })
     *
     */
    create<T extends CalendarConnectionCreateArgs>(
      args: SelectSubset<T, CalendarConnectionCreateArgs<ExtArgs>>,
    ): Prisma__CalendarConnectionClient<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CalendarConnections.
     * @param {CalendarConnectionCreateManyArgs} args - Arguments to create many CalendarConnections.
     * @example
     * // Create many CalendarConnections
     * const calendarConnection = await prisma.calendarConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CalendarConnectionCreateManyArgs>(
      args?: SelectSubset<T, CalendarConnectionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many CalendarConnections and returns the data saved in the database.
     * @param {CalendarConnectionCreateManyAndReturnArgs} args - Arguments to create many CalendarConnections.
     * @example
     * // Create many CalendarConnections
     * const calendarConnection = await prisma.calendarConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CalendarConnections and only return the `id`
     * const calendarConnectionWithIdOnly = await prisma.calendarConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CalendarConnectionCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        CalendarConnectionCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a CalendarConnection.
     * @param {CalendarConnectionDeleteArgs} args - Arguments to delete one CalendarConnection.
     * @example
     * // Delete one CalendarConnection
     * const CalendarConnection = await prisma.calendarConnection.delete({
     *   where: {
     *     // ... filter to delete one CalendarConnection
     *   }
     * })
     *
     */
    delete<T extends CalendarConnectionDeleteArgs>(
      args: SelectSubset<T, CalendarConnectionDeleteArgs<ExtArgs>>,
    ): Prisma__CalendarConnectionClient<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CalendarConnection.
     * @param {CalendarConnectionUpdateArgs} args - Arguments to update one CalendarConnection.
     * @example
     * // Update one CalendarConnection
     * const calendarConnection = await prisma.calendarConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CalendarConnectionUpdateArgs>(
      args: SelectSubset<T, CalendarConnectionUpdateArgs<ExtArgs>>,
    ): Prisma__CalendarConnectionClient<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CalendarConnections.
     * @param {CalendarConnectionDeleteManyArgs} args - Arguments to filter CalendarConnections to delete.
     * @example
     * // Delete a few CalendarConnections
     * const { count } = await prisma.calendarConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CalendarConnectionDeleteManyArgs>(
      args?: SelectSubset<T, CalendarConnectionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CalendarConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarConnections
     * const calendarConnection = await prisma.calendarConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CalendarConnectionUpdateManyArgs>(
      args: SelectSubset<T, CalendarConnectionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CalendarConnections and returns the data updated in the database.
     * @param {CalendarConnectionUpdateManyAndReturnArgs} args - Arguments to update many CalendarConnections.
     * @example
     * // Update many CalendarConnections
     * const calendarConnection = await prisma.calendarConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CalendarConnections and only return the `id`
     * const calendarConnectionWithIdOnly = await prisma.calendarConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CalendarConnectionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CalendarConnectionUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one CalendarConnection.
     * @param {CalendarConnectionUpsertArgs} args - Arguments to update or create a CalendarConnection.
     * @example
     * // Update or create a CalendarConnection
     * const calendarConnection = await prisma.calendarConnection.upsert({
     *   create: {
     *     // ... data to create a CalendarConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarConnection we want to update
     *   }
     * })
     */
    upsert<T extends CalendarConnectionUpsertArgs>(
      args: SelectSubset<T, CalendarConnectionUpsertArgs<ExtArgs>>,
    ): Prisma__CalendarConnectionClient<
      $Result.GetResult<
        Prisma.$CalendarConnectionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of CalendarConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarConnectionCountArgs} args - Arguments to filter CalendarConnections to count.
     * @example
     * // Count the number of CalendarConnections
     * const count = await prisma.calendarConnection.count({
     *   where: {
     *     // ... the filter for the CalendarConnections we want to count
     *   }
     * })
     **/
    count<T extends CalendarConnectionCountArgs>(
      args?: Subset<T, CalendarConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              CalendarConnectionCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CalendarConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CalendarConnectionAggregateArgs>(
      args: Subset<T, CalendarConnectionAggregateArgs>,
    ): Prisma.PrismaPromise<GetCalendarConnectionAggregateType<T>>;

    /**
     * Group by CalendarConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CalendarConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarConnectionGroupByArgs['orderBy'] }
        : { orderBy?: CalendarConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CalendarConnectionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetCalendarConnectionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CalendarConnection model
     */
    readonly fields: CalendarConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarConnectionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    meetings<T extends CalendarConnection$meetingsArgs<ExtArgs> = {}>(
      args?: Subset<T, CalendarConnection$meetingsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MeetingPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CalendarConnection model
   */
  interface CalendarConnectionFieldRefs {
    readonly id: FieldRef<'CalendarConnection', 'String'>;
    readonly userId: FieldRef<'CalendarConnection', 'String'>;
    readonly provider: FieldRef<'CalendarConnection', 'CalendarProvider'>;
    readonly accessToken: FieldRef<'CalendarConnection', 'String'>;
    readonly refreshToken: FieldRef<'CalendarConnection', 'String'>;
    readonly expiresAt: FieldRef<'CalendarConnection', 'DateTime'>;
    readonly lastSyncAt: FieldRef<'CalendarConnection', 'DateTime'>;
    readonly status: FieldRef<'CalendarConnection', 'ConnectionStatus'>;
    readonly createdAt: FieldRef<'CalendarConnection', 'DateTime'>;
    readonly updatedAt: FieldRef<'CalendarConnection', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * CalendarConnection findUnique
   */
  export type CalendarConnectionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which CalendarConnection to fetch.
     */
    where: CalendarConnectionWhereUniqueInput;
  };

  /**
   * CalendarConnection findUniqueOrThrow
   */
  export type CalendarConnectionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which CalendarConnection to fetch.
     */
    where: CalendarConnectionWhereUniqueInput;
  };

  /**
   * CalendarConnection findFirst
   */
  export type CalendarConnectionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which CalendarConnection to fetch.
     */
    where?: CalendarConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CalendarConnections to fetch.
     */
    orderBy?:
      | CalendarConnectionOrderByWithRelationInput
      | CalendarConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CalendarConnections.
     */
    cursor?: CalendarConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CalendarConnections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CalendarConnections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CalendarConnections.
     */
    distinct?:
      | CalendarConnectionScalarFieldEnum
      | CalendarConnectionScalarFieldEnum[];
  };

  /**
   * CalendarConnection findFirstOrThrow
   */
  export type CalendarConnectionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which CalendarConnection to fetch.
     */
    where?: CalendarConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CalendarConnections to fetch.
     */
    orderBy?:
      | CalendarConnectionOrderByWithRelationInput
      | CalendarConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CalendarConnections.
     */
    cursor?: CalendarConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CalendarConnections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CalendarConnections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CalendarConnections.
     */
    distinct?:
      | CalendarConnectionScalarFieldEnum
      | CalendarConnectionScalarFieldEnum[];
  };

  /**
   * CalendarConnection findMany
   */
  export type CalendarConnectionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which CalendarConnections to fetch.
     */
    where?: CalendarConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CalendarConnections to fetch.
     */
    orderBy?:
      | CalendarConnectionOrderByWithRelationInput
      | CalendarConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CalendarConnections.
     */
    cursor?: CalendarConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CalendarConnections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CalendarConnections.
     */
    skip?: number;
    distinct?:
      | CalendarConnectionScalarFieldEnum
      | CalendarConnectionScalarFieldEnum[];
  };

  /**
   * CalendarConnection create
   */
  export type CalendarConnectionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    /**
     * The data needed to create a CalendarConnection.
     */
    data: XOR<
      CalendarConnectionCreateInput,
      CalendarConnectionUncheckedCreateInput
    >;
  };

  /**
   * CalendarConnection createMany
   */
  export type CalendarConnectionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many CalendarConnections.
     */
    data:
      | CalendarConnectionCreateManyInput
      | CalendarConnectionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CalendarConnection createManyAndReturn
   */
  export type CalendarConnectionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * The data used to create many CalendarConnections.
     */
    data:
      | CalendarConnectionCreateManyInput
      | CalendarConnectionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * CalendarConnection update
   */
  export type CalendarConnectionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    /**
     * The data needed to update a CalendarConnection.
     */
    data: XOR<
      CalendarConnectionUpdateInput,
      CalendarConnectionUncheckedUpdateInput
    >;
    /**
     * Choose, which CalendarConnection to update.
     */
    where: CalendarConnectionWhereUniqueInput;
  };

  /**
   * CalendarConnection updateMany
   */
  export type CalendarConnectionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update CalendarConnections.
     */
    data: XOR<
      CalendarConnectionUpdateManyMutationInput,
      CalendarConnectionUncheckedUpdateManyInput
    >;
    /**
     * Filter which CalendarConnections to update
     */
    where?: CalendarConnectionWhereInput;
    /**
     * Limit how many CalendarConnections to update.
     */
    limit?: number;
  };

  /**
   * CalendarConnection updateManyAndReturn
   */
  export type CalendarConnectionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * The data used to update CalendarConnections.
     */
    data: XOR<
      CalendarConnectionUpdateManyMutationInput,
      CalendarConnectionUncheckedUpdateManyInput
    >;
    /**
     * Filter which CalendarConnections to update
     */
    where?: CalendarConnectionWhereInput;
    /**
     * Limit how many CalendarConnections to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * CalendarConnection upsert
   */
  export type CalendarConnectionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    /**
     * The filter to search for the CalendarConnection to update in case it exists.
     */
    where: CalendarConnectionWhereUniqueInput;
    /**
     * In case the CalendarConnection found by the `where` argument doesn't exist, create a new CalendarConnection with this data.
     */
    create: XOR<
      CalendarConnectionCreateInput,
      CalendarConnectionUncheckedCreateInput
    >;
    /**
     * In case the CalendarConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      CalendarConnectionUpdateInput,
      CalendarConnectionUncheckedUpdateInput
    >;
  };

  /**
   * CalendarConnection delete
   */
  export type CalendarConnectionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
    /**
     * Filter which CalendarConnection to delete.
     */
    where: CalendarConnectionWhereUniqueInput;
  };

  /**
   * CalendarConnection deleteMany
   */
  export type CalendarConnectionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CalendarConnections to delete
     */
    where?: CalendarConnectionWhereInput;
    /**
     * Limit how many CalendarConnections to delete.
     */
    limit?: number;
  };

  /**
   * CalendarConnection.meetings
   */
  export type CalendarConnection$meetingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null;
    where?: MeetingWhereInput;
    orderBy?:
      | MeetingOrderByWithRelationInput
      | MeetingOrderByWithRelationInput[];
    cursor?: MeetingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[];
  };

  /**
   * CalendarConnection without action
   */
  export type CalendarConnectionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CalendarConnection
     */
    select?: CalendarConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CalendarConnection
     */
    omit?: CalendarConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarConnectionInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: 'id';
    email: 'email';
    password: 'password';
    name: 'name';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    role: 'role';
    isActive: 'isActive';
    telegramId: 'telegramId';
    telegramChatId: 'telegramChatId';
    telegramLinkCode: 'telegramLinkCode';
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const OrganizationScalarFieldEnum: {
    id: 'id';
    name: 'name';
    slug: 'slug';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    isPersonal: 'isPersonal';
    autoRedact: 'autoRedact';
    retentionDays: 'retentionDays';
  };

  export type OrganizationScalarFieldEnum =
    (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum];

  export const MembershipScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    organizationId: 'organizationId';
    role: 'role';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type MembershipScalarFieldEnum =
    (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum];

  export const MinutesTemplateScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    organizationId: 'organizationId';
    name: 'name';
    description: 'description';
    format: 'format';
    sections: 'sections';
    isDefault: 'isDefault';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type MinutesTemplateScalarFieldEnum =
    (typeof MinutesTemplateScalarFieldEnum)[keyof typeof MinutesTemplateScalarFieldEnum];

  export const PlanScalarFieldEnum: {
    id: 'id';
    name: 'name';
    maxMinutesPerUpload: 'maxMinutesPerUpload';
    maxUploadsPerWeek: 'maxUploadsPerWeek';
    monthlyMinutesLimit: 'monthlyMinutesLimit';
    price: 'price';
    currency: 'currency';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type PlanScalarFieldEnum =
    (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum];

  export const SubscriptionScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    planId: 'planId';
    active: 'active';
    startsAt: 'startsAt';
    endsAt: 'endsAt';
  };

  export type SubscriptionScalarFieldEnum =
    (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum];

  export const WeeklyUsageScalarFieldEnum: {
    id: 'id';
    subscriptionId: 'subscriptionId';
    weekStartDate: 'weekStartDate';
    uploadCount: 'uploadCount';
    minutesProcessed: 'minutesProcessed';
  };

  export type WeeklyUsageScalarFieldEnum =
    (typeof WeeklyUsageScalarFieldEnum)[keyof typeof WeeklyUsageScalarFieldEnum];

  export const MeetingScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    organizationId: 'organizationId';
    calendarConnectionId: 'calendarConnectionId';
    title: 'title';
    originalFileName: 'originalFileName';
    durationSeconds: 'durationSeconds';
    fileUrl: 'fileUrl';
    status: 'status';
    languageCode: 'languageCode';
    transcriptLang: 'transcriptLang';
    minutesLang: 'minutesLang';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    avgSpeakerConfidence: 'avgSpeakerConfidence';
    inaudibleCount: 'inaudibleCount';
    qualityScore: 'qualityScore';
    lastProcessedAt: 'lastProcessedAt';
  };

  export type MeetingScalarFieldEnum =
    (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum];

  export const KeyMomentScalarFieldEnum: {
    id: 'id';
    meetingId: 'meetingId';
    timestamp: 'timestamp';
    label: 'label';
    description: 'description';
    type: 'type';
    isAutomatic: 'isAutomatic';
    createdBy: 'createdBy';
    createdAt: 'createdAt';
  };

  export type KeyMomentScalarFieldEnum =
    (typeof KeyMomentScalarFieldEnum)[keyof typeof KeyMomentScalarFieldEnum];

  export const TranscriptSegmentScalarFieldEnum: {
    id: 'id';
    meetingId: 'meetingId';
    speakerId: 'speakerId';
    startTime: 'startTime';
    endTime: 'endTime';
    text: 'text';
    languagesUsed: 'languagesUsed';
    originalText: 'originalText';
  };

  export type TranscriptSegmentScalarFieldEnum =
    (typeof TranscriptSegmentScalarFieldEnum)[keyof typeof TranscriptSegmentScalarFieldEnum];

  export const TranscriptCorrectionScalarFieldEnum: {
    id: 'id';
    segmentId: 'segmentId';
    originalText: 'originalText';
    correctedText: 'correctedText';
    correctedBy: 'correctedBy';
    createdAt: 'createdAt';
  };

  export type TranscriptCorrectionScalarFieldEnum =
    (typeof TranscriptCorrectionScalarFieldEnum)[keyof typeof TranscriptCorrectionScalarFieldEnum];

  export const SegmentEditScalarFieldEnum: {
    id: 'id';
    segmentId: 'segmentId';
    previousText: 'previousText';
    newText: 'newText';
    editedBy: 'editedBy';
    editReason: 'editReason';
    createdAt: 'createdAt';
  };

  export type SegmentEditScalarFieldEnum =
    (typeof SegmentEditScalarFieldEnum)[keyof typeof SegmentEditScalarFieldEnum];

  export const SpeakerScalarFieldEnum: {
    id: 'id';
    meetingId: 'meetingId';
    name: 'name';
    isUnknown: 'isUnknown';
    isConfirmed: 'isConfirmed';
    nameConfidence: 'nameConfidence';
  };

  export type SpeakerScalarFieldEnum =
    (typeof SpeakerScalarFieldEnum)[keyof typeof SpeakerScalarFieldEnum];

  export const MinutesScalarFieldEnum: {
    id: 'id';
    meetingId: 'meetingId';
    content: 'content';
    status: 'status';
    reviewerId: 'reviewerId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type MinutesScalarFieldEnum =
    (typeof MinutesScalarFieldEnum)[keyof typeof MinutesScalarFieldEnum];

  export const MinutesVersionScalarFieldEnum: {
    id: 'id';
    minutesId: 'minutesId';
    content: 'content';
    version: 'version';
    createdAt: 'createdAt';
  };

  export type MinutesVersionScalarFieldEnum =
    (typeof MinutesVersionScalarFieldEnum)[keyof typeof MinutesVersionScalarFieldEnum];

  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    email: 'email';
    push: 'push';
    deviceToken: 'deviceToken';
  };

  export type NotificationPreferenceScalarFieldEnum =
    (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum];

  export const TagScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    organizationId: 'organizationId';
    name: 'name';
    color: 'color';
    createdAt: 'createdAt';
  };

  export type TagScalarFieldEnum =
    (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum];

  export const MeetingTagScalarFieldEnum: {
    id: 'id';
    meetingId: 'meetingId';
    tagId: 'tagId';
    createdAt: 'createdAt';
  };

  export type MeetingTagScalarFieldEnum =
    (typeof MeetingTagScalarFieldEnum)[keyof typeof MeetingTagScalarFieldEnum];

  export const NotificationScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    type: 'type';
    title: 'title';
    message: 'message';
    read: 'read';
    meetingId: 'meetingId';
    createdAt: 'createdAt';
  };

  export type NotificationScalarFieldEnum =
    (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

  export const ShareLinkScalarFieldEnum: {
    id: 'id';
    meetingId: 'meetingId';
    token: 'token';
    expiresAt: 'expiresAt';
    shareType: 'shareType';
    createdAt: 'createdAt';
  };

  export type ShareLinkScalarFieldEnum =
    (typeof ShareLinkScalarFieldEnum)[keyof typeof ShareLinkScalarFieldEnum];

  export const CalendarConnectionScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    provider: 'provider';
    accessToken: 'accessToken';
    refreshToken: 'refreshToken';
    expiresAt: 'expiresAt';
    lastSyncAt: 'lastSyncAt';
    status: 'status';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type CalendarConnectionScalarFieldEnum =
    (typeof CalendarConnectionScalarFieldEnum)[keyof typeof CalendarConnectionScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Role'
  >;

  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Role[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
  >;

  /**
   * Reference to a field of type 'MemberRole'
   */
  export type EnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'MemberRole'
  >;

  /**
   * Reference to a field of type 'MemberRole[]'
   */
  export type ListEnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'MemberRole[]'
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Json'
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal'
  >;

  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal[]'
  >;

  /**
   * Reference to a field of type 'MeetingStatus'
   */
  export type EnumMeetingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'MeetingStatus'
  >;

  /**
   * Reference to a field of type 'MeetingStatus[]'
   */
  export type ListEnumMeetingStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'MeetingStatus[]'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
  >;

  /**
   * Reference to a field of type 'MomentType'
   */
  export type EnumMomentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'MomentType'
  >;

  /**
   * Reference to a field of type 'MomentType[]'
   */
  export type ListEnumMomentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'MomentType[]'
  >;

  /**
   * Reference to a field of type 'MinutesStatus'
   */
  export type EnumMinutesStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'MinutesStatus'
  >;

  /**
   * Reference to a field of type 'MinutesStatus[]'
   */
  export type ListEnumMinutesStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'MinutesStatus[]'>;

  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'NotificationType'>;

  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'NotificationType[]'>;

  /**
   * Reference to a field of type 'ShareType'
   */
  export type EnumShareTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ShareType'
  >;

  /**
   * Reference to a field of type 'ShareType[]'
   */
  export type ListEnumShareTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ShareType[]'
  >;

  /**
   * Reference to a field of type 'CalendarProvider'
   */
  export type EnumCalendarProviderFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'CalendarProvider'>;

  /**
   * Reference to a field of type 'CalendarProvider[]'
   */
  export type ListEnumCalendarProviderFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'CalendarProvider[]'>;

  /**
   * Reference to a field of type 'ConnectionStatus'
   */
  export type EnumConnectionStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'ConnectionStatus'>;

  /**
   * Reference to a field of type 'ConnectionStatus[]'
   */
  export type ListEnumConnectionStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'ConnectionStatus[]'>;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    password?: StringNullableFilter<'User'> | string | null;
    name?: StringNullableFilter<'User'> | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    role?: EnumRoleFilter<'User'> | $Enums.Role;
    isActive?: BoolFilter<'User'> | boolean;
    telegramId?: StringNullableFilter<'User'> | string | null;
    telegramChatId?: StringNullableFilter<'User'> | string | null;
    telegramLinkCode?: StringNullableFilter<'User'> | string | null;
    meetings?: MeetingListRelationFilter;
    templates?: MinutesTemplateListRelationFilter;
    notifications?: NotificationListRelationFilter;
    notificationSettings?: XOR<
      NotificationPreferenceNullableScalarRelationFilter,
      NotificationPreferenceWhereInput
    > | null;
    subscription?: XOR<
      SubscriptionNullableScalarRelationFilter,
      SubscriptionWhereInput
    > | null;
    tags?: TagListRelationFilter;
    memberships?: MembershipListRelationFilter;
    reviewedMinutes?: MinutesListRelationFilter;
    calendarConnections?: CalendarConnectionListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    role?: SortOrder;
    isActive?: SortOrder;
    telegramId?: SortOrderInput | SortOrder;
    telegramChatId?: SortOrderInput | SortOrder;
    telegramLinkCode?: SortOrderInput | SortOrder;
    meetings?: MeetingOrderByRelationAggregateInput;
    templates?: MinutesTemplateOrderByRelationAggregateInput;
    notifications?: NotificationOrderByRelationAggregateInput;
    notificationSettings?: NotificationPreferenceOrderByWithRelationInput;
    subscription?: SubscriptionOrderByWithRelationInput;
    tags?: TagOrderByRelationAggregateInput;
    memberships?: MembershipOrderByRelationAggregateInput;
    reviewedMinutes?: MinutesOrderByRelationAggregateInput;
    calendarConnections?: CalendarConnectionOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      telegramId?: string;
      telegramChatId?: string;
      telegramLinkCode?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      password?: StringNullableFilter<'User'> | string | null;
      name?: StringNullableFilter<'User'> | string | null;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      role?: EnumRoleFilter<'User'> | $Enums.Role;
      isActive?: BoolFilter<'User'> | boolean;
      meetings?: MeetingListRelationFilter;
      templates?: MinutesTemplateListRelationFilter;
      notifications?: NotificationListRelationFilter;
      notificationSettings?: XOR<
        NotificationPreferenceNullableScalarRelationFilter,
        NotificationPreferenceWhereInput
      > | null;
      subscription?: XOR<
        SubscriptionNullableScalarRelationFilter,
        SubscriptionWhereInput
      > | null;
      tags?: TagListRelationFilter;
      memberships?: MembershipListRelationFilter;
      reviewedMinutes?: MinutesListRelationFilter;
      calendarConnections?: CalendarConnectionListRelationFilter;
    },
    'id' | 'email' | 'telegramId' | 'telegramChatId' | 'telegramLinkCode'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    role?: SortOrder;
    isActive?: SortOrder;
    telegramId?: SortOrderInput | SortOrder;
    telegramChatId?: SortOrderInput | SortOrder;
    telegramLinkCode?: SortOrderInput | SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    email?: StringWithAggregatesFilter<'User'> | string;
    password?: StringNullableWithAggregatesFilter<'User'> | string | null;
    name?: StringNullableWithAggregatesFilter<'User'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    role?: EnumRoleWithAggregatesFilter<'User'> | $Enums.Role;
    isActive?: BoolWithAggregatesFilter<'User'> | boolean;
    telegramId?: StringNullableWithAggregatesFilter<'User'> | string | null;
    telegramChatId?: StringNullableWithAggregatesFilter<'User'> | string | null;
    telegramLinkCode?:
      | StringNullableWithAggregatesFilter<'User'>
      | string
      | null;
  };

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[];
    OR?: OrganizationWhereInput[];
    NOT?: OrganizationWhereInput | OrganizationWhereInput[];
    id?: StringFilter<'Organization'> | string;
    name?: StringFilter<'Organization'> | string;
    slug?: StringFilter<'Organization'> | string;
    createdAt?: DateTimeFilter<'Organization'> | Date | string;
    updatedAt?: DateTimeFilter<'Organization'> | Date | string;
    isPersonal?: BoolFilter<'Organization'> | boolean;
    autoRedact?: BoolFilter<'Organization'> | boolean;
    retentionDays?: IntNullableFilter<'Organization'> | number | null;
    members?: MembershipListRelationFilter;
    meetings?: MeetingListRelationFilter;
    templates?: MinutesTemplateListRelationFilter;
    tags?: TagListRelationFilter;
  };

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isPersonal?: SortOrder;
    autoRedact?: SortOrder;
    retentionDays?: SortOrderInput | SortOrder;
    members?: MembershipOrderByRelationAggregateInput;
    meetings?: MeetingOrderByRelationAggregateInput;
    templates?: MinutesTemplateOrderByRelationAggregateInput;
    tags?: TagOrderByRelationAggregateInput;
  };

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: OrganizationWhereInput | OrganizationWhereInput[];
      OR?: OrganizationWhereInput[];
      NOT?: OrganizationWhereInput | OrganizationWhereInput[];
      name?: StringFilter<'Organization'> | string;
      createdAt?: DateTimeFilter<'Organization'> | Date | string;
      updatedAt?: DateTimeFilter<'Organization'> | Date | string;
      isPersonal?: BoolFilter<'Organization'> | boolean;
      autoRedact?: BoolFilter<'Organization'> | boolean;
      retentionDays?: IntNullableFilter<'Organization'> | number | null;
      members?: MembershipListRelationFilter;
      meetings?: MeetingListRelationFilter;
      templates?: MinutesTemplateListRelationFilter;
      tags?: TagListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isPersonal?: SortOrder;
    autoRedact?: SortOrder;
    retentionDays?: SortOrderInput | SortOrder;
    _count?: OrganizationCountOrderByAggregateInput;
    _avg?: OrganizationAvgOrderByAggregateInput;
    _max?: OrganizationMaxOrderByAggregateInput;
    _min?: OrganizationMinOrderByAggregateInput;
    _sum?: OrganizationSumOrderByAggregateInput;
  };

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?:
      | OrganizationScalarWhereWithAggregatesInput
      | OrganizationScalarWhereWithAggregatesInput[];
    OR?: OrganizationScalarWhereWithAggregatesInput[];
    NOT?:
      | OrganizationScalarWhereWithAggregatesInput
      | OrganizationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Organization'> | string;
    name?: StringWithAggregatesFilter<'Organization'> | string;
    slug?: StringWithAggregatesFilter<'Organization'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Organization'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Organization'> | Date | string;
    isPersonal?: BoolWithAggregatesFilter<'Organization'> | boolean;
    autoRedact?: BoolWithAggregatesFilter<'Organization'> | boolean;
    retentionDays?:
      | IntNullableWithAggregatesFilter<'Organization'>
      | number
      | null;
  };

  export type MembershipWhereInput = {
    AND?: MembershipWhereInput | MembershipWhereInput[];
    OR?: MembershipWhereInput[];
    NOT?: MembershipWhereInput | MembershipWhereInput[];
    id?: StringFilter<'Membership'> | string;
    userId?: StringFilter<'Membership'> | string;
    organizationId?: StringFilter<'Membership'> | string;
    role?: EnumMemberRoleFilter<'Membership'> | $Enums.MemberRole;
    createdAt?: DateTimeFilter<'Membership'> | Date | string;
    updatedAt?: DateTimeFilter<'Membership'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    organization?: XOR<
      OrganizationScalarRelationFilter,
      OrganizationWhereInput
    >;
  };

  export type MembershipOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type MembershipWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_organizationId?: MembershipUserIdOrganizationIdCompoundUniqueInput;
      AND?: MembershipWhereInput | MembershipWhereInput[];
      OR?: MembershipWhereInput[];
      NOT?: MembershipWhereInput | MembershipWhereInput[];
      userId?: StringFilter<'Membership'> | string;
      organizationId?: StringFilter<'Membership'> | string;
      role?: EnumMemberRoleFilter<'Membership'> | $Enums.MemberRole;
      createdAt?: DateTimeFilter<'Membership'> | Date | string;
      updatedAt?: DateTimeFilter<'Membership'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      organization?: XOR<
        OrganizationScalarRelationFilter,
        OrganizationWhereInput
      >;
    },
    'id' | 'userId_organizationId'
  >;

  export type MembershipOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: MembershipCountOrderByAggregateInput;
    _max?: MembershipMaxOrderByAggregateInput;
    _min?: MembershipMinOrderByAggregateInput;
  };

  export type MembershipScalarWhereWithAggregatesInput = {
    AND?:
      | MembershipScalarWhereWithAggregatesInput
      | MembershipScalarWhereWithAggregatesInput[];
    OR?: MembershipScalarWhereWithAggregatesInput[];
    NOT?:
      | MembershipScalarWhereWithAggregatesInput
      | MembershipScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Membership'> | string;
    userId?: StringWithAggregatesFilter<'Membership'> | string;
    organizationId?: StringWithAggregatesFilter<'Membership'> | string;
    role?: EnumMemberRoleWithAggregatesFilter<'Membership'> | $Enums.MemberRole;
    createdAt?: DateTimeWithAggregatesFilter<'Membership'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Membership'> | Date | string;
  };

  export type MinutesTemplateWhereInput = {
    AND?: MinutesTemplateWhereInput | MinutesTemplateWhereInput[];
    OR?: MinutesTemplateWhereInput[];
    NOT?: MinutesTemplateWhereInput | MinutesTemplateWhereInput[];
    id?: StringFilter<'MinutesTemplate'> | string;
    userId?: StringFilter<'MinutesTemplate'> | string;
    organizationId?: StringNullableFilter<'MinutesTemplate'> | string | null;
    name?: StringFilter<'MinutesTemplate'> | string;
    description?: StringNullableFilter<'MinutesTemplate'> | string | null;
    format?: StringFilter<'MinutesTemplate'> | string;
    sections?: JsonFilter<'MinutesTemplate'>;
    isDefault?: BoolFilter<'MinutesTemplate'> | boolean;
    createdAt?: DateTimeFilter<'MinutesTemplate'> | Date | string;
    updatedAt?: DateTimeFilter<'MinutesTemplate'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    organization?: XOR<
      OrganizationNullableScalarRelationFilter,
      OrganizationWhereInput
    > | null;
  };

  export type MinutesTemplateOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    format?: SortOrder;
    sections?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type MinutesTemplateWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MinutesTemplateWhereInput | MinutesTemplateWhereInput[];
      OR?: MinutesTemplateWhereInput[];
      NOT?: MinutesTemplateWhereInput | MinutesTemplateWhereInput[];
      userId?: StringFilter<'MinutesTemplate'> | string;
      organizationId?: StringNullableFilter<'MinutesTemplate'> | string | null;
      name?: StringFilter<'MinutesTemplate'> | string;
      description?: StringNullableFilter<'MinutesTemplate'> | string | null;
      format?: StringFilter<'MinutesTemplate'> | string;
      sections?: JsonFilter<'MinutesTemplate'>;
      isDefault?: BoolFilter<'MinutesTemplate'> | boolean;
      createdAt?: DateTimeFilter<'MinutesTemplate'> | Date | string;
      updatedAt?: DateTimeFilter<'MinutesTemplate'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      organization?: XOR<
        OrganizationNullableScalarRelationFilter,
        OrganizationWhereInput
      > | null;
    },
    'id'
  >;

  export type MinutesTemplateOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    format?: SortOrder;
    sections?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: MinutesTemplateCountOrderByAggregateInput;
    _max?: MinutesTemplateMaxOrderByAggregateInput;
    _min?: MinutesTemplateMinOrderByAggregateInput;
  };

  export type MinutesTemplateScalarWhereWithAggregatesInput = {
    AND?:
      | MinutesTemplateScalarWhereWithAggregatesInput
      | MinutesTemplateScalarWhereWithAggregatesInput[];
    OR?: MinutesTemplateScalarWhereWithAggregatesInput[];
    NOT?:
      | MinutesTemplateScalarWhereWithAggregatesInput
      | MinutesTemplateScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'MinutesTemplate'> | string;
    userId?: StringWithAggregatesFilter<'MinutesTemplate'> | string;
    organizationId?:
      | StringNullableWithAggregatesFilter<'MinutesTemplate'>
      | string
      | null;
    name?: StringWithAggregatesFilter<'MinutesTemplate'> | string;
    description?:
      | StringNullableWithAggregatesFilter<'MinutesTemplate'>
      | string
      | null;
    format?: StringWithAggregatesFilter<'MinutesTemplate'> | string;
    sections?: JsonWithAggregatesFilter<'MinutesTemplate'>;
    isDefault?: BoolWithAggregatesFilter<'MinutesTemplate'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'MinutesTemplate'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'MinutesTemplate'> | Date | string;
  };

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[];
    OR?: PlanWhereInput[];
    NOT?: PlanWhereInput | PlanWhereInput[];
    id?: StringFilter<'Plan'> | string;
    name?: StringFilter<'Plan'> | string;
    maxMinutesPerUpload?: IntFilter<'Plan'> | number;
    maxUploadsPerWeek?: IntFilter<'Plan'> | number;
    monthlyMinutesLimit?: IntFilter<'Plan'> | number;
    price?: DecimalFilter<'Plan'> | Decimal | DecimalJsLike | number | string;
    currency?: StringFilter<'Plan'> | string;
    createdAt?: DateTimeFilter<'Plan'> | Date | string;
    updatedAt?: DateTimeFilter<'Plan'> | Date | string;
    subscriptions?: SubscriptionListRelationFilter;
  };

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    maxMinutesPerUpload?: SortOrder;
    maxUploadsPerWeek?: SortOrder;
    monthlyMinutesLimit?: SortOrder;
    price?: SortOrder;
    currency?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    subscriptions?: SubscriptionOrderByRelationAggregateInput;
  };

  export type PlanWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: PlanWhereInput | PlanWhereInput[];
      OR?: PlanWhereInput[];
      NOT?: PlanWhereInput | PlanWhereInput[];
      maxMinutesPerUpload?: IntFilter<'Plan'> | number;
      maxUploadsPerWeek?: IntFilter<'Plan'> | number;
      monthlyMinutesLimit?: IntFilter<'Plan'> | number;
      price?: DecimalFilter<'Plan'> | Decimal | DecimalJsLike | number | string;
      currency?: StringFilter<'Plan'> | string;
      createdAt?: DateTimeFilter<'Plan'> | Date | string;
      updatedAt?: DateTimeFilter<'Plan'> | Date | string;
      subscriptions?: SubscriptionListRelationFilter;
    },
    'id' | 'name'
  >;

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    maxMinutesPerUpload?: SortOrder;
    maxUploadsPerWeek?: SortOrder;
    monthlyMinutesLimit?: SortOrder;
    price?: SortOrder;
    currency?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PlanCountOrderByAggregateInput;
    _avg?: PlanAvgOrderByAggregateInput;
    _max?: PlanMaxOrderByAggregateInput;
    _min?: PlanMinOrderByAggregateInput;
    _sum?: PlanSumOrderByAggregateInput;
  };

  export type PlanScalarWhereWithAggregatesInput = {
    AND?:
      | PlanScalarWhereWithAggregatesInput
      | PlanScalarWhereWithAggregatesInput[];
    OR?: PlanScalarWhereWithAggregatesInput[];
    NOT?:
      | PlanScalarWhereWithAggregatesInput
      | PlanScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Plan'> | string;
    name?: StringWithAggregatesFilter<'Plan'> | string;
    maxMinutesPerUpload?: IntWithAggregatesFilter<'Plan'> | number;
    maxUploadsPerWeek?: IntWithAggregatesFilter<'Plan'> | number;
    monthlyMinutesLimit?: IntWithAggregatesFilter<'Plan'> | number;
    price?:
      | DecimalWithAggregatesFilter<'Plan'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: StringWithAggregatesFilter<'Plan'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Plan'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Plan'> | Date | string;
  };

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[];
    OR?: SubscriptionWhereInput[];
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[];
    id?: StringFilter<'Subscription'> | string;
    userId?: StringFilter<'Subscription'> | string;
    planId?: StringFilter<'Subscription'> | string;
    active?: BoolFilter<'Subscription'> | boolean;
    startsAt?: DateTimeFilter<'Subscription'> | Date | string;
    endsAt?: DateTimeNullableFilter<'Subscription'> | Date | string | null;
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    usage?: WeeklyUsageListRelationFilter;
  };

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    planId?: SortOrder;
    active?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrderInput | SortOrder;
    plan?: PlanOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    usage?: WeeklyUsageOrderByRelationAggregateInput;
  };

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: SubscriptionWhereInput | SubscriptionWhereInput[];
      OR?: SubscriptionWhereInput[];
      NOT?: SubscriptionWhereInput | SubscriptionWhereInput[];
      planId?: StringFilter<'Subscription'> | string;
      active?: BoolFilter<'Subscription'> | boolean;
      startsAt?: DateTimeFilter<'Subscription'> | Date | string;
      endsAt?: DateTimeNullableFilter<'Subscription'> | Date | string | null;
      plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      usage?: WeeklyUsageListRelationFilter;
    },
    'id' | 'userId'
  >;

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    planId?: SortOrder;
    active?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrderInput | SortOrder;
    _count?: SubscriptionCountOrderByAggregateInput;
    _max?: SubscriptionMaxOrderByAggregateInput;
    _min?: SubscriptionMinOrderByAggregateInput;
  };

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?:
      | SubscriptionScalarWhereWithAggregatesInput
      | SubscriptionScalarWhereWithAggregatesInput[];
    OR?: SubscriptionScalarWhereWithAggregatesInput[];
    NOT?:
      | SubscriptionScalarWhereWithAggregatesInput
      | SubscriptionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Subscription'> | string;
    userId?: StringWithAggregatesFilter<'Subscription'> | string;
    planId?: StringWithAggregatesFilter<'Subscription'> | string;
    active?: BoolWithAggregatesFilter<'Subscription'> | boolean;
    startsAt?: DateTimeWithAggregatesFilter<'Subscription'> | Date | string;
    endsAt?:
      | DateTimeNullableWithAggregatesFilter<'Subscription'>
      | Date
      | string
      | null;
  };

  export type WeeklyUsageWhereInput = {
    AND?: WeeklyUsageWhereInput | WeeklyUsageWhereInput[];
    OR?: WeeklyUsageWhereInput[];
    NOT?: WeeklyUsageWhereInput | WeeklyUsageWhereInput[];
    id?: StringFilter<'WeeklyUsage'> | string;
    subscriptionId?: StringFilter<'WeeklyUsage'> | string;
    weekStartDate?: DateTimeFilter<'WeeklyUsage'> | Date | string;
    uploadCount?: IntFilter<'WeeklyUsage'> | number;
    minutesProcessed?: IntFilter<'WeeklyUsage'> | number;
    subscription?: XOR<
      SubscriptionScalarRelationFilter,
      SubscriptionWhereInput
    >;
  };

  export type WeeklyUsageOrderByWithRelationInput = {
    id?: SortOrder;
    subscriptionId?: SortOrder;
    weekStartDate?: SortOrder;
    uploadCount?: SortOrder;
    minutesProcessed?: SortOrder;
    subscription?: SubscriptionOrderByWithRelationInput;
  };

  export type WeeklyUsageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      subscriptionId_weekStartDate?: WeeklyUsageSubscriptionIdWeekStartDateCompoundUniqueInput;
      AND?: WeeklyUsageWhereInput | WeeklyUsageWhereInput[];
      OR?: WeeklyUsageWhereInput[];
      NOT?: WeeklyUsageWhereInput | WeeklyUsageWhereInput[];
      subscriptionId?: StringFilter<'WeeklyUsage'> | string;
      weekStartDate?: DateTimeFilter<'WeeklyUsage'> | Date | string;
      uploadCount?: IntFilter<'WeeklyUsage'> | number;
      minutesProcessed?: IntFilter<'WeeklyUsage'> | number;
      subscription?: XOR<
        SubscriptionScalarRelationFilter,
        SubscriptionWhereInput
      >;
    },
    'id' | 'subscriptionId_weekStartDate'
  >;

  export type WeeklyUsageOrderByWithAggregationInput = {
    id?: SortOrder;
    subscriptionId?: SortOrder;
    weekStartDate?: SortOrder;
    uploadCount?: SortOrder;
    minutesProcessed?: SortOrder;
    _count?: WeeklyUsageCountOrderByAggregateInput;
    _avg?: WeeklyUsageAvgOrderByAggregateInput;
    _max?: WeeklyUsageMaxOrderByAggregateInput;
    _min?: WeeklyUsageMinOrderByAggregateInput;
    _sum?: WeeklyUsageSumOrderByAggregateInput;
  };

  export type WeeklyUsageScalarWhereWithAggregatesInput = {
    AND?:
      | WeeklyUsageScalarWhereWithAggregatesInput
      | WeeklyUsageScalarWhereWithAggregatesInput[];
    OR?: WeeklyUsageScalarWhereWithAggregatesInput[];
    NOT?:
      | WeeklyUsageScalarWhereWithAggregatesInput
      | WeeklyUsageScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'WeeklyUsage'> | string;
    subscriptionId?: StringWithAggregatesFilter<'WeeklyUsage'> | string;
    weekStartDate?: DateTimeWithAggregatesFilter<'WeeklyUsage'> | Date | string;
    uploadCount?: IntWithAggregatesFilter<'WeeklyUsage'> | number;
    minutesProcessed?: IntWithAggregatesFilter<'WeeklyUsage'> | number;
  };

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[];
    OR?: MeetingWhereInput[];
    NOT?: MeetingWhereInput | MeetingWhereInput[];
    id?: StringFilter<'Meeting'> | string;
    userId?: StringFilter<'Meeting'> | string;
    organizationId?: StringNullableFilter<'Meeting'> | string | null;
    calendarConnectionId?: StringNullableFilter<'Meeting'> | string | null;
    title?: StringFilter<'Meeting'> | string;
    originalFileName?: StringFilter<'Meeting'> | string;
    durationSeconds?: IntFilter<'Meeting'> | number;
    fileUrl?: StringNullableFilter<'Meeting'> | string | null;
    status?: EnumMeetingStatusFilter<'Meeting'> | $Enums.MeetingStatus;
    languageCode?: StringNullableFilter<'Meeting'> | string | null;
    transcriptLang?: StringNullableFilter<'Meeting'> | string | null;
    minutesLang?: StringNullableFilter<'Meeting'> | string | null;
    createdAt?: DateTimeFilter<'Meeting'> | Date | string;
    updatedAt?: DateTimeFilter<'Meeting'> | Date | string;
    avgSpeakerConfidence?: FloatNullableFilter<'Meeting'> | number | null;
    inaudibleCount?: IntFilter<'Meeting'> | number;
    qualityScore?: FloatNullableFilter<'Meeting'> | number | null;
    lastProcessedAt?: DateTimeNullableFilter<'Meeting'> | Date | string | null;
    keyMoments?: KeyMomentListRelationFilter;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    organization?: XOR<
      OrganizationNullableScalarRelationFilter,
      OrganizationWhereInput
    > | null;
    calendarConnection?: XOR<
      CalendarConnectionNullableScalarRelationFilter,
      CalendarConnectionWhereInput
    > | null;
    tags?: MeetingTagListRelationFilter;
    minutes?: XOR<
      MinutesNullableScalarRelationFilter,
      MinutesWhereInput
    > | null;
    shareLinks?: ShareLinkListRelationFilter;
    speakers?: SpeakerListRelationFilter;
    transcript?: TranscriptSegmentListRelationFilter;
  };

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    calendarConnectionId?: SortOrderInput | SortOrder;
    title?: SortOrder;
    originalFileName?: SortOrder;
    durationSeconds?: SortOrder;
    fileUrl?: SortOrderInput | SortOrder;
    status?: SortOrder;
    languageCode?: SortOrderInput | SortOrder;
    transcriptLang?: SortOrderInput | SortOrder;
    minutesLang?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    avgSpeakerConfidence?: SortOrderInput | SortOrder;
    inaudibleCount?: SortOrder;
    qualityScore?: SortOrderInput | SortOrder;
    lastProcessedAt?: SortOrderInput | SortOrder;
    keyMoments?: KeyMomentOrderByRelationAggregateInput;
    user?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
    calendarConnection?: CalendarConnectionOrderByWithRelationInput;
    tags?: MeetingTagOrderByRelationAggregateInput;
    minutes?: MinutesOrderByWithRelationInput;
    shareLinks?: ShareLinkOrderByRelationAggregateInput;
    speakers?: SpeakerOrderByRelationAggregateInput;
    transcript?: TranscriptSegmentOrderByRelationAggregateInput;
  };

  export type MeetingWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MeetingWhereInput | MeetingWhereInput[];
      OR?: MeetingWhereInput[];
      NOT?: MeetingWhereInput | MeetingWhereInput[];
      userId?: StringFilter<'Meeting'> | string;
      organizationId?: StringNullableFilter<'Meeting'> | string | null;
      calendarConnectionId?: StringNullableFilter<'Meeting'> | string | null;
      title?: StringFilter<'Meeting'> | string;
      originalFileName?: StringFilter<'Meeting'> | string;
      durationSeconds?: IntFilter<'Meeting'> | number;
      fileUrl?: StringNullableFilter<'Meeting'> | string | null;
      status?: EnumMeetingStatusFilter<'Meeting'> | $Enums.MeetingStatus;
      languageCode?: StringNullableFilter<'Meeting'> | string | null;
      transcriptLang?: StringNullableFilter<'Meeting'> | string | null;
      minutesLang?: StringNullableFilter<'Meeting'> | string | null;
      createdAt?: DateTimeFilter<'Meeting'> | Date | string;
      updatedAt?: DateTimeFilter<'Meeting'> | Date | string;
      avgSpeakerConfidence?: FloatNullableFilter<'Meeting'> | number | null;
      inaudibleCount?: IntFilter<'Meeting'> | number;
      qualityScore?: FloatNullableFilter<'Meeting'> | number | null;
      lastProcessedAt?:
        | DateTimeNullableFilter<'Meeting'>
        | Date
        | string
        | null;
      keyMoments?: KeyMomentListRelationFilter;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      organization?: XOR<
        OrganizationNullableScalarRelationFilter,
        OrganizationWhereInput
      > | null;
      calendarConnection?: XOR<
        CalendarConnectionNullableScalarRelationFilter,
        CalendarConnectionWhereInput
      > | null;
      tags?: MeetingTagListRelationFilter;
      minutes?: XOR<
        MinutesNullableScalarRelationFilter,
        MinutesWhereInput
      > | null;
      shareLinks?: ShareLinkListRelationFilter;
      speakers?: SpeakerListRelationFilter;
      transcript?: TranscriptSegmentListRelationFilter;
    },
    'id'
  >;

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    calendarConnectionId?: SortOrderInput | SortOrder;
    title?: SortOrder;
    originalFileName?: SortOrder;
    durationSeconds?: SortOrder;
    fileUrl?: SortOrderInput | SortOrder;
    status?: SortOrder;
    languageCode?: SortOrderInput | SortOrder;
    transcriptLang?: SortOrderInput | SortOrder;
    minutesLang?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    avgSpeakerConfidence?: SortOrderInput | SortOrder;
    inaudibleCount?: SortOrder;
    qualityScore?: SortOrderInput | SortOrder;
    lastProcessedAt?: SortOrderInput | SortOrder;
    _count?: MeetingCountOrderByAggregateInput;
    _avg?: MeetingAvgOrderByAggregateInput;
    _max?: MeetingMaxOrderByAggregateInput;
    _min?: MeetingMinOrderByAggregateInput;
    _sum?: MeetingSumOrderByAggregateInput;
  };

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?:
      | MeetingScalarWhereWithAggregatesInput
      | MeetingScalarWhereWithAggregatesInput[];
    OR?: MeetingScalarWhereWithAggregatesInput[];
    NOT?:
      | MeetingScalarWhereWithAggregatesInput
      | MeetingScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Meeting'> | string;
    userId?: StringWithAggregatesFilter<'Meeting'> | string;
    organizationId?:
      | StringNullableWithAggregatesFilter<'Meeting'>
      | string
      | null;
    calendarConnectionId?:
      | StringNullableWithAggregatesFilter<'Meeting'>
      | string
      | null;
    title?: StringWithAggregatesFilter<'Meeting'> | string;
    originalFileName?: StringWithAggregatesFilter<'Meeting'> | string;
    durationSeconds?: IntWithAggregatesFilter<'Meeting'> | number;
    fileUrl?: StringNullableWithAggregatesFilter<'Meeting'> | string | null;
    status?:
      | EnumMeetingStatusWithAggregatesFilter<'Meeting'>
      | $Enums.MeetingStatus;
    languageCode?:
      | StringNullableWithAggregatesFilter<'Meeting'>
      | string
      | null;
    transcriptLang?:
      | StringNullableWithAggregatesFilter<'Meeting'>
      | string
      | null;
    minutesLang?: StringNullableWithAggregatesFilter<'Meeting'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Meeting'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Meeting'> | Date | string;
    avgSpeakerConfidence?:
      | FloatNullableWithAggregatesFilter<'Meeting'>
      | number
      | null;
    inaudibleCount?: IntWithAggregatesFilter<'Meeting'> | number;
    qualityScore?: FloatNullableWithAggregatesFilter<'Meeting'> | number | null;
    lastProcessedAt?:
      | DateTimeNullableWithAggregatesFilter<'Meeting'>
      | Date
      | string
      | null;
  };

  export type KeyMomentWhereInput = {
    AND?: KeyMomentWhereInput | KeyMomentWhereInput[];
    OR?: KeyMomentWhereInput[];
    NOT?: KeyMomentWhereInput | KeyMomentWhereInput[];
    id?: StringFilter<'KeyMoment'> | string;
    meetingId?: StringFilter<'KeyMoment'> | string;
    timestamp?: FloatFilter<'KeyMoment'> | number;
    label?: StringFilter<'KeyMoment'> | string;
    description?: StringNullableFilter<'KeyMoment'> | string | null;
    type?: EnumMomentTypeFilter<'KeyMoment'> | $Enums.MomentType;
    isAutomatic?: BoolFilter<'KeyMoment'> | boolean;
    createdBy?: StringNullableFilter<'KeyMoment'> | string | null;
    createdAt?: DateTimeFilter<'KeyMoment'> | Date | string;
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
  };

  export type KeyMomentOrderByWithRelationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    timestamp?: SortOrder;
    label?: SortOrder;
    description?: SortOrderInput | SortOrder;
    type?: SortOrder;
    isAutomatic?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    meeting?: MeetingOrderByWithRelationInput;
  };

  export type KeyMomentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: KeyMomentWhereInput | KeyMomentWhereInput[];
      OR?: KeyMomentWhereInput[];
      NOT?: KeyMomentWhereInput | KeyMomentWhereInput[];
      meetingId?: StringFilter<'KeyMoment'> | string;
      timestamp?: FloatFilter<'KeyMoment'> | number;
      label?: StringFilter<'KeyMoment'> | string;
      description?: StringNullableFilter<'KeyMoment'> | string | null;
      type?: EnumMomentTypeFilter<'KeyMoment'> | $Enums.MomentType;
      isAutomatic?: BoolFilter<'KeyMoment'> | boolean;
      createdBy?: StringNullableFilter<'KeyMoment'> | string | null;
      createdAt?: DateTimeFilter<'KeyMoment'> | Date | string;
      meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
    },
    'id'
  >;

  export type KeyMomentOrderByWithAggregationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    timestamp?: SortOrder;
    label?: SortOrder;
    description?: SortOrderInput | SortOrder;
    type?: SortOrder;
    isAutomatic?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: KeyMomentCountOrderByAggregateInput;
    _avg?: KeyMomentAvgOrderByAggregateInput;
    _max?: KeyMomentMaxOrderByAggregateInput;
    _min?: KeyMomentMinOrderByAggregateInput;
    _sum?: KeyMomentSumOrderByAggregateInput;
  };

  export type KeyMomentScalarWhereWithAggregatesInput = {
    AND?:
      | KeyMomentScalarWhereWithAggregatesInput
      | KeyMomentScalarWhereWithAggregatesInput[];
    OR?: KeyMomentScalarWhereWithAggregatesInput[];
    NOT?:
      | KeyMomentScalarWhereWithAggregatesInput
      | KeyMomentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'KeyMoment'> | string;
    meetingId?: StringWithAggregatesFilter<'KeyMoment'> | string;
    timestamp?: FloatWithAggregatesFilter<'KeyMoment'> | number;
    label?: StringWithAggregatesFilter<'KeyMoment'> | string;
    description?:
      | StringNullableWithAggregatesFilter<'KeyMoment'>
      | string
      | null;
    type?: EnumMomentTypeWithAggregatesFilter<'KeyMoment'> | $Enums.MomentType;
    isAutomatic?: BoolWithAggregatesFilter<'KeyMoment'> | boolean;
    createdBy?: StringNullableWithAggregatesFilter<'KeyMoment'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'KeyMoment'> | Date | string;
  };

  export type TranscriptSegmentWhereInput = {
    AND?: TranscriptSegmentWhereInput | TranscriptSegmentWhereInput[];
    OR?: TranscriptSegmentWhereInput[];
    NOT?: TranscriptSegmentWhereInput | TranscriptSegmentWhereInput[];
    id?: StringFilter<'TranscriptSegment'> | string;
    meetingId?: StringFilter<'TranscriptSegment'> | string;
    speakerId?: StringNullableFilter<'TranscriptSegment'> | string | null;
    startTime?: FloatFilter<'TranscriptSegment'> | number;
    endTime?: FloatFilter<'TranscriptSegment'> | number;
    text?: StringFilter<'TranscriptSegment'> | string;
    languagesUsed?: StringNullableListFilter<'TranscriptSegment'>;
    originalText?: StringNullableFilter<'TranscriptSegment'> | string | null;
    edits?: SegmentEditListRelationFilter;
    corrections?: TranscriptCorrectionListRelationFilter;
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
    speaker?: XOR<
      SpeakerNullableScalarRelationFilter,
      SpeakerWhereInput
    > | null;
  };

  export type TranscriptSegmentOrderByWithRelationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    speakerId?: SortOrderInput | SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    text?: SortOrder;
    languagesUsed?: SortOrder;
    originalText?: SortOrderInput | SortOrder;
    edits?: SegmentEditOrderByRelationAggregateInput;
    corrections?: TranscriptCorrectionOrderByRelationAggregateInput;
    meeting?: MeetingOrderByWithRelationInput;
    speaker?: SpeakerOrderByWithRelationInput;
  };

  export type TranscriptSegmentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TranscriptSegmentWhereInput | TranscriptSegmentWhereInput[];
      OR?: TranscriptSegmentWhereInput[];
      NOT?: TranscriptSegmentWhereInput | TranscriptSegmentWhereInput[];
      meetingId?: StringFilter<'TranscriptSegment'> | string;
      speakerId?: StringNullableFilter<'TranscriptSegment'> | string | null;
      startTime?: FloatFilter<'TranscriptSegment'> | number;
      endTime?: FloatFilter<'TranscriptSegment'> | number;
      text?: StringFilter<'TranscriptSegment'> | string;
      languagesUsed?: StringNullableListFilter<'TranscriptSegment'>;
      originalText?: StringNullableFilter<'TranscriptSegment'> | string | null;
      edits?: SegmentEditListRelationFilter;
      corrections?: TranscriptCorrectionListRelationFilter;
      meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
      speaker?: XOR<
        SpeakerNullableScalarRelationFilter,
        SpeakerWhereInput
      > | null;
    },
    'id'
  >;

  export type TranscriptSegmentOrderByWithAggregationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    speakerId?: SortOrderInput | SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    text?: SortOrder;
    languagesUsed?: SortOrder;
    originalText?: SortOrderInput | SortOrder;
    _count?: TranscriptSegmentCountOrderByAggregateInput;
    _avg?: TranscriptSegmentAvgOrderByAggregateInput;
    _max?: TranscriptSegmentMaxOrderByAggregateInput;
    _min?: TranscriptSegmentMinOrderByAggregateInput;
    _sum?: TranscriptSegmentSumOrderByAggregateInput;
  };

  export type TranscriptSegmentScalarWhereWithAggregatesInput = {
    AND?:
      | TranscriptSegmentScalarWhereWithAggregatesInput
      | TranscriptSegmentScalarWhereWithAggregatesInput[];
    OR?: TranscriptSegmentScalarWhereWithAggregatesInput[];
    NOT?:
      | TranscriptSegmentScalarWhereWithAggregatesInput
      | TranscriptSegmentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'TranscriptSegment'> | string;
    meetingId?: StringWithAggregatesFilter<'TranscriptSegment'> | string;
    speakerId?:
      | StringNullableWithAggregatesFilter<'TranscriptSegment'>
      | string
      | null;
    startTime?: FloatWithAggregatesFilter<'TranscriptSegment'> | number;
    endTime?: FloatWithAggregatesFilter<'TranscriptSegment'> | number;
    text?: StringWithAggregatesFilter<'TranscriptSegment'> | string;
    languagesUsed?: StringNullableListFilter<'TranscriptSegment'>;
    originalText?:
      | StringNullableWithAggregatesFilter<'TranscriptSegment'>
      | string
      | null;
  };

  export type TranscriptCorrectionWhereInput = {
    AND?: TranscriptCorrectionWhereInput | TranscriptCorrectionWhereInput[];
    OR?: TranscriptCorrectionWhereInput[];
    NOT?: TranscriptCorrectionWhereInput | TranscriptCorrectionWhereInput[];
    id?: StringFilter<'TranscriptCorrection'> | string;
    segmentId?: StringFilter<'TranscriptCorrection'> | string;
    originalText?: StringFilter<'TranscriptCorrection'> | string;
    correctedText?: StringFilter<'TranscriptCorrection'> | string;
    correctedBy?: StringFilter<'TranscriptCorrection'> | string;
    createdAt?: DateTimeFilter<'TranscriptCorrection'> | Date | string;
    segment?: XOR<
      TranscriptSegmentScalarRelationFilter,
      TranscriptSegmentWhereInput
    >;
  };

  export type TranscriptCorrectionOrderByWithRelationInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    originalText?: SortOrder;
    correctedText?: SortOrder;
    correctedBy?: SortOrder;
    createdAt?: SortOrder;
    segment?: TranscriptSegmentOrderByWithRelationInput;
  };

  export type TranscriptCorrectionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TranscriptCorrectionWhereInput | TranscriptCorrectionWhereInput[];
      OR?: TranscriptCorrectionWhereInput[];
      NOT?: TranscriptCorrectionWhereInput | TranscriptCorrectionWhereInput[];
      segmentId?: StringFilter<'TranscriptCorrection'> | string;
      originalText?: StringFilter<'TranscriptCorrection'> | string;
      correctedText?: StringFilter<'TranscriptCorrection'> | string;
      correctedBy?: StringFilter<'TranscriptCorrection'> | string;
      createdAt?: DateTimeFilter<'TranscriptCorrection'> | Date | string;
      segment?: XOR<
        TranscriptSegmentScalarRelationFilter,
        TranscriptSegmentWhereInput
      >;
    },
    'id'
  >;

  export type TranscriptCorrectionOrderByWithAggregationInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    originalText?: SortOrder;
    correctedText?: SortOrder;
    correctedBy?: SortOrder;
    createdAt?: SortOrder;
    _count?: TranscriptCorrectionCountOrderByAggregateInput;
    _max?: TranscriptCorrectionMaxOrderByAggregateInput;
    _min?: TranscriptCorrectionMinOrderByAggregateInput;
  };

  export type TranscriptCorrectionScalarWhereWithAggregatesInput = {
    AND?:
      | TranscriptCorrectionScalarWhereWithAggregatesInput
      | TranscriptCorrectionScalarWhereWithAggregatesInput[];
    OR?: TranscriptCorrectionScalarWhereWithAggregatesInput[];
    NOT?:
      | TranscriptCorrectionScalarWhereWithAggregatesInput
      | TranscriptCorrectionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'TranscriptCorrection'> | string;
    segmentId?: StringWithAggregatesFilter<'TranscriptCorrection'> | string;
    originalText?: StringWithAggregatesFilter<'TranscriptCorrection'> | string;
    correctedText?: StringWithAggregatesFilter<'TranscriptCorrection'> | string;
    correctedBy?: StringWithAggregatesFilter<'TranscriptCorrection'> | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<'TranscriptCorrection'>
      | Date
      | string;
  };

  export type SegmentEditWhereInput = {
    AND?: SegmentEditWhereInput | SegmentEditWhereInput[];
    OR?: SegmentEditWhereInput[];
    NOT?: SegmentEditWhereInput | SegmentEditWhereInput[];
    id?: StringFilter<'SegmentEdit'> | string;
    segmentId?: StringFilter<'SegmentEdit'> | string;
    previousText?: StringFilter<'SegmentEdit'> | string;
    newText?: StringFilter<'SegmentEdit'> | string;
    editedBy?: StringFilter<'SegmentEdit'> | string;
    editReason?: StringNullableFilter<'SegmentEdit'> | string | null;
    createdAt?: DateTimeFilter<'SegmentEdit'> | Date | string;
    segment?: XOR<
      TranscriptSegmentScalarRelationFilter,
      TranscriptSegmentWhereInput
    >;
  };

  export type SegmentEditOrderByWithRelationInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    previousText?: SortOrder;
    newText?: SortOrder;
    editedBy?: SortOrder;
    editReason?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    segment?: TranscriptSegmentOrderByWithRelationInput;
  };

  export type SegmentEditWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SegmentEditWhereInput | SegmentEditWhereInput[];
      OR?: SegmentEditWhereInput[];
      NOT?: SegmentEditWhereInput | SegmentEditWhereInput[];
      segmentId?: StringFilter<'SegmentEdit'> | string;
      previousText?: StringFilter<'SegmentEdit'> | string;
      newText?: StringFilter<'SegmentEdit'> | string;
      editedBy?: StringFilter<'SegmentEdit'> | string;
      editReason?: StringNullableFilter<'SegmentEdit'> | string | null;
      createdAt?: DateTimeFilter<'SegmentEdit'> | Date | string;
      segment?: XOR<
        TranscriptSegmentScalarRelationFilter,
        TranscriptSegmentWhereInput
      >;
    },
    'id'
  >;

  export type SegmentEditOrderByWithAggregationInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    previousText?: SortOrder;
    newText?: SortOrder;
    editedBy?: SortOrder;
    editReason?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: SegmentEditCountOrderByAggregateInput;
    _max?: SegmentEditMaxOrderByAggregateInput;
    _min?: SegmentEditMinOrderByAggregateInput;
  };

  export type SegmentEditScalarWhereWithAggregatesInput = {
    AND?:
      | SegmentEditScalarWhereWithAggregatesInput
      | SegmentEditScalarWhereWithAggregatesInput[];
    OR?: SegmentEditScalarWhereWithAggregatesInput[];
    NOT?:
      | SegmentEditScalarWhereWithAggregatesInput
      | SegmentEditScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'SegmentEdit'> | string;
    segmentId?: StringWithAggregatesFilter<'SegmentEdit'> | string;
    previousText?: StringWithAggregatesFilter<'SegmentEdit'> | string;
    newText?: StringWithAggregatesFilter<'SegmentEdit'> | string;
    editedBy?: StringWithAggregatesFilter<'SegmentEdit'> | string;
    editReason?:
      | StringNullableWithAggregatesFilter<'SegmentEdit'>
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'SegmentEdit'> | Date | string;
  };

  export type SpeakerWhereInput = {
    AND?: SpeakerWhereInput | SpeakerWhereInput[];
    OR?: SpeakerWhereInput[];
    NOT?: SpeakerWhereInput | SpeakerWhereInput[];
    id?: StringFilter<'Speaker'> | string;
    meetingId?: StringFilter<'Speaker'> | string;
    name?: StringFilter<'Speaker'> | string;
    isUnknown?: BoolFilter<'Speaker'> | boolean;
    isConfirmed?: BoolFilter<'Speaker'> | boolean;
    nameConfidence?: FloatFilter<'Speaker'> | number;
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
    segments?: TranscriptSegmentListRelationFilter;
  };

  export type SpeakerOrderByWithRelationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    name?: SortOrder;
    isUnknown?: SortOrder;
    isConfirmed?: SortOrder;
    nameConfidence?: SortOrder;
    meeting?: MeetingOrderByWithRelationInput;
    segments?: TranscriptSegmentOrderByRelationAggregateInput;
  };

  export type SpeakerWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SpeakerWhereInput | SpeakerWhereInput[];
      OR?: SpeakerWhereInput[];
      NOT?: SpeakerWhereInput | SpeakerWhereInput[];
      meetingId?: StringFilter<'Speaker'> | string;
      name?: StringFilter<'Speaker'> | string;
      isUnknown?: BoolFilter<'Speaker'> | boolean;
      isConfirmed?: BoolFilter<'Speaker'> | boolean;
      nameConfidence?: FloatFilter<'Speaker'> | number;
      meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
      segments?: TranscriptSegmentListRelationFilter;
    },
    'id'
  >;

  export type SpeakerOrderByWithAggregationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    name?: SortOrder;
    isUnknown?: SortOrder;
    isConfirmed?: SortOrder;
    nameConfidence?: SortOrder;
    _count?: SpeakerCountOrderByAggregateInput;
    _avg?: SpeakerAvgOrderByAggregateInput;
    _max?: SpeakerMaxOrderByAggregateInput;
    _min?: SpeakerMinOrderByAggregateInput;
    _sum?: SpeakerSumOrderByAggregateInput;
  };

  export type SpeakerScalarWhereWithAggregatesInput = {
    AND?:
      | SpeakerScalarWhereWithAggregatesInput
      | SpeakerScalarWhereWithAggregatesInput[];
    OR?: SpeakerScalarWhereWithAggregatesInput[];
    NOT?:
      | SpeakerScalarWhereWithAggregatesInput
      | SpeakerScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Speaker'> | string;
    meetingId?: StringWithAggregatesFilter<'Speaker'> | string;
    name?: StringWithAggregatesFilter<'Speaker'> | string;
    isUnknown?: BoolWithAggregatesFilter<'Speaker'> | boolean;
    isConfirmed?: BoolWithAggregatesFilter<'Speaker'> | boolean;
    nameConfidence?: FloatWithAggregatesFilter<'Speaker'> | number;
  };

  export type MinutesWhereInput = {
    AND?: MinutesWhereInput | MinutesWhereInput[];
    OR?: MinutesWhereInput[];
    NOT?: MinutesWhereInput | MinutesWhereInput[];
    id?: StringFilter<'Minutes'> | string;
    meetingId?: StringFilter<'Minutes'> | string;
    content?: StringFilter<'Minutes'> | string;
    status?: EnumMinutesStatusFilter<'Minutes'> | $Enums.MinutesStatus;
    reviewerId?: StringNullableFilter<'Minutes'> | string | null;
    createdAt?: DateTimeFilter<'Minutes'> | Date | string;
    updatedAt?: DateTimeFilter<'Minutes'> | Date | string;
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    versions?: MinutesVersionListRelationFilter;
  };

  export type MinutesOrderByWithRelationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    content?: SortOrder;
    status?: SortOrder;
    reviewerId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    meeting?: MeetingOrderByWithRelationInput;
    reviewer?: UserOrderByWithRelationInput;
    versions?: MinutesVersionOrderByRelationAggregateInput;
  };

  export type MinutesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      meetingId?: string;
      AND?: MinutesWhereInput | MinutesWhereInput[];
      OR?: MinutesWhereInput[];
      NOT?: MinutesWhereInput | MinutesWhereInput[];
      content?: StringFilter<'Minutes'> | string;
      status?: EnumMinutesStatusFilter<'Minutes'> | $Enums.MinutesStatus;
      reviewerId?: StringNullableFilter<'Minutes'> | string | null;
      createdAt?: DateTimeFilter<'Minutes'> | Date | string;
      updatedAt?: DateTimeFilter<'Minutes'> | Date | string;
      meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
      reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      versions?: MinutesVersionListRelationFilter;
    },
    'id' | 'meetingId'
  >;

  export type MinutesOrderByWithAggregationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    content?: SortOrder;
    status?: SortOrder;
    reviewerId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: MinutesCountOrderByAggregateInput;
    _max?: MinutesMaxOrderByAggregateInput;
    _min?: MinutesMinOrderByAggregateInput;
  };

  export type MinutesScalarWhereWithAggregatesInput = {
    AND?:
      | MinutesScalarWhereWithAggregatesInput
      | MinutesScalarWhereWithAggregatesInput[];
    OR?: MinutesScalarWhereWithAggregatesInput[];
    NOT?:
      | MinutesScalarWhereWithAggregatesInput
      | MinutesScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Minutes'> | string;
    meetingId?: StringWithAggregatesFilter<'Minutes'> | string;
    content?: StringWithAggregatesFilter<'Minutes'> | string;
    status?:
      | EnumMinutesStatusWithAggregatesFilter<'Minutes'>
      | $Enums.MinutesStatus;
    reviewerId?: StringNullableWithAggregatesFilter<'Minutes'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Minutes'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Minutes'> | Date | string;
  };

  export type MinutesVersionWhereInput = {
    AND?: MinutesVersionWhereInput | MinutesVersionWhereInput[];
    OR?: MinutesVersionWhereInput[];
    NOT?: MinutesVersionWhereInput | MinutesVersionWhereInput[];
    id?: StringFilter<'MinutesVersion'> | string;
    minutesId?: StringFilter<'MinutesVersion'> | string;
    content?: StringFilter<'MinutesVersion'> | string;
    version?: IntFilter<'MinutesVersion'> | number;
    createdAt?: DateTimeFilter<'MinutesVersion'> | Date | string;
    minutes?: XOR<MinutesScalarRelationFilter, MinutesWhereInput>;
  };

  export type MinutesVersionOrderByWithRelationInput = {
    id?: SortOrder;
    minutesId?: SortOrder;
    content?: SortOrder;
    version?: SortOrder;
    createdAt?: SortOrder;
    minutes?: MinutesOrderByWithRelationInput;
  };

  export type MinutesVersionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MinutesVersionWhereInput | MinutesVersionWhereInput[];
      OR?: MinutesVersionWhereInput[];
      NOT?: MinutesVersionWhereInput | MinutesVersionWhereInput[];
      minutesId?: StringFilter<'MinutesVersion'> | string;
      content?: StringFilter<'MinutesVersion'> | string;
      version?: IntFilter<'MinutesVersion'> | number;
      createdAt?: DateTimeFilter<'MinutesVersion'> | Date | string;
      minutes?: XOR<MinutesScalarRelationFilter, MinutesWhereInput>;
    },
    'id'
  >;

  export type MinutesVersionOrderByWithAggregationInput = {
    id?: SortOrder;
    minutesId?: SortOrder;
    content?: SortOrder;
    version?: SortOrder;
    createdAt?: SortOrder;
    _count?: MinutesVersionCountOrderByAggregateInput;
    _avg?: MinutesVersionAvgOrderByAggregateInput;
    _max?: MinutesVersionMaxOrderByAggregateInput;
    _min?: MinutesVersionMinOrderByAggregateInput;
    _sum?: MinutesVersionSumOrderByAggregateInput;
  };

  export type MinutesVersionScalarWhereWithAggregatesInput = {
    AND?:
      | MinutesVersionScalarWhereWithAggregatesInput
      | MinutesVersionScalarWhereWithAggregatesInput[];
    OR?: MinutesVersionScalarWhereWithAggregatesInput[];
    NOT?:
      | MinutesVersionScalarWhereWithAggregatesInput
      | MinutesVersionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'MinutesVersion'> | string;
    minutesId?: StringWithAggregatesFilter<'MinutesVersion'> | string;
    content?: StringWithAggregatesFilter<'MinutesVersion'> | string;
    version?: IntWithAggregatesFilter<'MinutesVersion'> | number;
    createdAt?: DateTimeWithAggregatesFilter<'MinutesVersion'> | Date | string;
  };

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[];
    OR?: NotificationPreferenceWhereInput[];
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[];
    id?: StringFilter<'NotificationPreference'> | string;
    userId?: StringFilter<'NotificationPreference'> | string;
    email?: BoolFilter<'NotificationPreference'> | boolean;
    push?: BoolFilter<'NotificationPreference'> | boolean;
    deviceToken?:
      | StringNullableFilter<'NotificationPreference'>
      | string
      | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    push?: SortOrder;
    deviceToken?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?:
        | NotificationPreferenceWhereInput
        | NotificationPreferenceWhereInput[];
      OR?: NotificationPreferenceWhereInput[];
      NOT?:
        | NotificationPreferenceWhereInput
        | NotificationPreferenceWhereInput[];
      email?: BoolFilter<'NotificationPreference'> | boolean;
      push?: BoolFilter<'NotificationPreference'> | boolean;
      deviceToken?:
        | StringNullableFilter<'NotificationPreference'>
        | string
        | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'userId'
  >;

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    push?: SortOrder;
    deviceToken?: SortOrderInput | SortOrder;
    _count?: NotificationPreferenceCountOrderByAggregateInput;
    _max?: NotificationPreferenceMaxOrderByAggregateInput;
    _min?: NotificationPreferenceMinOrderByAggregateInput;
  };

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationPreferenceScalarWhereWithAggregatesInput
      | NotificationPreferenceScalarWhereWithAggregatesInput[];
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationPreferenceScalarWhereWithAggregatesInput
      | NotificationPreferenceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationPreference'> | string;
    userId?: StringWithAggregatesFilter<'NotificationPreference'> | string;
    email?: BoolWithAggregatesFilter<'NotificationPreference'> | boolean;
    push?: BoolWithAggregatesFilter<'NotificationPreference'> | boolean;
    deviceToken?:
      | StringNullableWithAggregatesFilter<'NotificationPreference'>
      | string
      | null;
  };

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[];
    OR?: TagWhereInput[];
    NOT?: TagWhereInput | TagWhereInput[];
    id?: StringFilter<'Tag'> | string;
    userId?: StringFilter<'Tag'> | string;
    organizationId?: StringNullableFilter<'Tag'> | string | null;
    name?: StringFilter<'Tag'> | string;
    color?: StringFilter<'Tag'> | string;
    createdAt?: DateTimeFilter<'Tag'> | Date | string;
    meetings?: MeetingTagListRelationFilter;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    organization?: XOR<
      OrganizationNullableScalarRelationFilter,
      OrganizationWhereInput
    > | null;
  };

  export type TagOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    name?: SortOrder;
    color?: SortOrder;
    createdAt?: SortOrder;
    meetings?: MeetingTagOrderByRelationAggregateInput;
    user?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type TagWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_name?: TagUserIdNameCompoundUniqueInput;
      AND?: TagWhereInput | TagWhereInput[];
      OR?: TagWhereInput[];
      NOT?: TagWhereInput | TagWhereInput[];
      userId?: StringFilter<'Tag'> | string;
      organizationId?: StringNullableFilter<'Tag'> | string | null;
      name?: StringFilter<'Tag'> | string;
      color?: StringFilter<'Tag'> | string;
      createdAt?: DateTimeFilter<'Tag'> | Date | string;
      meetings?: MeetingTagListRelationFilter;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      organization?: XOR<
        OrganizationNullableScalarRelationFilter,
        OrganizationWhereInput
      > | null;
    },
    'id' | 'userId_name'
  >;

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    name?: SortOrder;
    color?: SortOrder;
    createdAt?: SortOrder;
    _count?: TagCountOrderByAggregateInput;
    _max?: TagMaxOrderByAggregateInput;
    _min?: TagMinOrderByAggregateInput;
  };

  export type TagScalarWhereWithAggregatesInput = {
    AND?:
      | TagScalarWhereWithAggregatesInput
      | TagScalarWhereWithAggregatesInput[];
    OR?: TagScalarWhereWithAggregatesInput[];
    NOT?:
      | TagScalarWhereWithAggregatesInput
      | TagScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Tag'> | string;
    userId?: StringWithAggregatesFilter<'Tag'> | string;
    organizationId?: StringNullableWithAggregatesFilter<'Tag'> | string | null;
    name?: StringWithAggregatesFilter<'Tag'> | string;
    color?: StringWithAggregatesFilter<'Tag'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Tag'> | Date | string;
  };

  export type MeetingTagWhereInput = {
    AND?: MeetingTagWhereInput | MeetingTagWhereInput[];
    OR?: MeetingTagWhereInput[];
    NOT?: MeetingTagWhereInput | MeetingTagWhereInput[];
    id?: StringFilter<'MeetingTag'> | string;
    meetingId?: StringFilter<'MeetingTag'> | string;
    tagId?: StringFilter<'MeetingTag'> | string;
    createdAt?: DateTimeFilter<'MeetingTag'> | Date | string;
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>;
  };

  export type MeetingTagOrderByWithRelationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    tagId?: SortOrder;
    createdAt?: SortOrder;
    meeting?: MeetingOrderByWithRelationInput;
    tag?: TagOrderByWithRelationInput;
  };

  export type MeetingTagWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      meetingId_tagId?: MeetingTagMeetingIdTagIdCompoundUniqueInput;
      AND?: MeetingTagWhereInput | MeetingTagWhereInput[];
      OR?: MeetingTagWhereInput[];
      NOT?: MeetingTagWhereInput | MeetingTagWhereInput[];
      meetingId?: StringFilter<'MeetingTag'> | string;
      tagId?: StringFilter<'MeetingTag'> | string;
      createdAt?: DateTimeFilter<'MeetingTag'> | Date | string;
      meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
      tag?: XOR<TagScalarRelationFilter, TagWhereInput>;
    },
    'id' | 'meetingId_tagId'
  >;

  export type MeetingTagOrderByWithAggregationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    tagId?: SortOrder;
    createdAt?: SortOrder;
    _count?: MeetingTagCountOrderByAggregateInput;
    _max?: MeetingTagMaxOrderByAggregateInput;
    _min?: MeetingTagMinOrderByAggregateInput;
  };

  export type MeetingTagScalarWhereWithAggregatesInput = {
    AND?:
      | MeetingTagScalarWhereWithAggregatesInput
      | MeetingTagScalarWhereWithAggregatesInput[];
    OR?: MeetingTagScalarWhereWithAggregatesInput[];
    NOT?:
      | MeetingTagScalarWhereWithAggregatesInput
      | MeetingTagScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'MeetingTag'> | string;
    meetingId?: StringWithAggregatesFilter<'MeetingTag'> | string;
    tagId?: StringWithAggregatesFilter<'MeetingTag'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'MeetingTag'> | Date | string;
  };

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    read?: BoolFilter<'Notification'> | boolean;
    meetingId?: StringNullableFilter<'Notification'> | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    read?: SortOrder;
    meetingId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type NotificationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationWhereInput | NotificationWhereInput[];
      OR?: NotificationWhereInput[];
      NOT?: NotificationWhereInput | NotificationWhereInput[];
      userId?: StringFilter<'Notification'> | string;
      type?:
        | EnumNotificationTypeFilter<'Notification'>
        | $Enums.NotificationType;
      title?: StringFilter<'Notification'> | string;
      message?: StringFilter<'Notification'> | string;
      read?: BoolFilter<'Notification'> | boolean;
      meetingId?: StringNullableFilter<'Notification'> | string | null;
      createdAt?: DateTimeFilter<'Notification'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    read?: SortOrder;
    meetingId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
  };

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationScalarWhereWithAggregatesInput
      | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationScalarWhereWithAggregatesInput
      | NotificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Notification'> | string;
    userId?: StringWithAggregatesFilter<'Notification'> | string;
    type?:
      | EnumNotificationTypeWithAggregatesFilter<'Notification'>
      | $Enums.NotificationType;
    title?: StringWithAggregatesFilter<'Notification'> | string;
    message?: StringWithAggregatesFilter<'Notification'> | string;
    read?: BoolWithAggregatesFilter<'Notification'> | boolean;
    meetingId?:
      | StringNullableWithAggregatesFilter<'Notification'>
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
  };

  export type ShareLinkWhereInput = {
    AND?: ShareLinkWhereInput | ShareLinkWhereInput[];
    OR?: ShareLinkWhereInput[];
    NOT?: ShareLinkWhereInput | ShareLinkWhereInput[];
    id?: StringFilter<'ShareLink'> | string;
    meetingId?: StringFilter<'ShareLink'> | string;
    token?: StringFilter<'ShareLink'> | string;
    expiresAt?: DateTimeNullableFilter<'ShareLink'> | Date | string | null;
    shareType?: EnumShareTypeFilter<'ShareLink'> | $Enums.ShareType;
    createdAt?: DateTimeFilter<'ShareLink'> | Date | string;
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
  };

  export type ShareLinkOrderByWithRelationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    shareType?: SortOrder;
    createdAt?: SortOrder;
    meeting?: MeetingOrderByWithRelationInput;
  };

  export type ShareLinkWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      token?: string;
      AND?: ShareLinkWhereInput | ShareLinkWhereInput[];
      OR?: ShareLinkWhereInput[];
      NOT?: ShareLinkWhereInput | ShareLinkWhereInput[];
      meetingId?: StringFilter<'ShareLink'> | string;
      expiresAt?: DateTimeNullableFilter<'ShareLink'> | Date | string | null;
      shareType?: EnumShareTypeFilter<'ShareLink'> | $Enums.ShareType;
      createdAt?: DateTimeFilter<'ShareLink'> | Date | string;
      meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>;
    },
    'id' | 'token'
  >;

  export type ShareLinkOrderByWithAggregationInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    shareType?: SortOrder;
    createdAt?: SortOrder;
    _count?: ShareLinkCountOrderByAggregateInput;
    _max?: ShareLinkMaxOrderByAggregateInput;
    _min?: ShareLinkMinOrderByAggregateInput;
  };

  export type ShareLinkScalarWhereWithAggregatesInput = {
    AND?:
      | ShareLinkScalarWhereWithAggregatesInput
      | ShareLinkScalarWhereWithAggregatesInput[];
    OR?: ShareLinkScalarWhereWithAggregatesInput[];
    NOT?:
      | ShareLinkScalarWhereWithAggregatesInput
      | ShareLinkScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ShareLink'> | string;
    meetingId?: StringWithAggregatesFilter<'ShareLink'> | string;
    token?: StringWithAggregatesFilter<'ShareLink'> | string;
    expiresAt?:
      | DateTimeNullableWithAggregatesFilter<'ShareLink'>
      | Date
      | string
      | null;
    shareType?:
      | EnumShareTypeWithAggregatesFilter<'ShareLink'>
      | $Enums.ShareType;
    createdAt?: DateTimeWithAggregatesFilter<'ShareLink'> | Date | string;
  };

  export type CalendarConnectionWhereInput = {
    AND?: CalendarConnectionWhereInput | CalendarConnectionWhereInput[];
    OR?: CalendarConnectionWhereInput[];
    NOT?: CalendarConnectionWhereInput | CalendarConnectionWhereInput[];
    id?: StringFilter<'CalendarConnection'> | string;
    userId?: StringFilter<'CalendarConnection'> | string;
    provider?:
      | EnumCalendarProviderFilter<'CalendarConnection'>
      | $Enums.CalendarProvider;
    accessToken?: StringFilter<'CalendarConnection'> | string;
    refreshToken?: StringFilter<'CalendarConnection'> | string;
    expiresAt?: DateTimeFilter<'CalendarConnection'> | Date | string;
    lastSyncAt?:
      | DateTimeNullableFilter<'CalendarConnection'>
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFilter<'CalendarConnection'>
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFilter<'CalendarConnection'> | Date | string;
    updatedAt?: DateTimeFilter<'CalendarConnection'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    meetings?: MeetingListRelationFilter;
  };

  export type CalendarConnectionOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    expiresAt?: SortOrder;
    lastSyncAt?: SortOrderInput | SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    meetings?: MeetingOrderByRelationAggregateInput;
  };

  export type CalendarConnectionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_provider?: CalendarConnectionUserIdProviderCompoundUniqueInput;
      AND?: CalendarConnectionWhereInput | CalendarConnectionWhereInput[];
      OR?: CalendarConnectionWhereInput[];
      NOT?: CalendarConnectionWhereInput | CalendarConnectionWhereInput[];
      userId?: StringFilter<'CalendarConnection'> | string;
      provider?:
        | EnumCalendarProviderFilter<'CalendarConnection'>
        | $Enums.CalendarProvider;
      accessToken?: StringFilter<'CalendarConnection'> | string;
      refreshToken?: StringFilter<'CalendarConnection'> | string;
      expiresAt?: DateTimeFilter<'CalendarConnection'> | Date | string;
      lastSyncAt?:
        | DateTimeNullableFilter<'CalendarConnection'>
        | Date
        | string
        | null;
      status?:
        | EnumConnectionStatusFilter<'CalendarConnection'>
        | $Enums.ConnectionStatus;
      createdAt?: DateTimeFilter<'CalendarConnection'> | Date | string;
      updatedAt?: DateTimeFilter<'CalendarConnection'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      meetings?: MeetingListRelationFilter;
    },
    'id' | 'userId_provider'
  >;

  export type CalendarConnectionOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    expiresAt?: SortOrder;
    lastSyncAt?: SortOrderInput | SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: CalendarConnectionCountOrderByAggregateInput;
    _max?: CalendarConnectionMaxOrderByAggregateInput;
    _min?: CalendarConnectionMinOrderByAggregateInput;
  };

  export type CalendarConnectionScalarWhereWithAggregatesInput = {
    AND?:
      | CalendarConnectionScalarWhereWithAggregatesInput
      | CalendarConnectionScalarWhereWithAggregatesInput[];
    OR?: CalendarConnectionScalarWhereWithAggregatesInput[];
    NOT?:
      | CalendarConnectionScalarWhereWithAggregatesInput
      | CalendarConnectionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'CalendarConnection'> | string;
    userId?: StringWithAggregatesFilter<'CalendarConnection'> | string;
    provider?:
      | EnumCalendarProviderWithAggregatesFilter<'CalendarConnection'>
      | $Enums.CalendarProvider;
    accessToken?: StringWithAggregatesFilter<'CalendarConnection'> | string;
    refreshToken?: StringWithAggregatesFilter<'CalendarConnection'> | string;
    expiresAt?:
      | DateTimeWithAggregatesFilter<'CalendarConnection'>
      | Date
      | string;
    lastSyncAt?:
      | DateTimeNullableWithAggregatesFilter<'CalendarConnection'>
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusWithAggregatesFilter<'CalendarConnection'>
      | $Enums.ConnectionStatus;
    createdAt?:
      | DateTimeWithAggregatesFilter<'CalendarConnection'>
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<'CalendarConnection'>
      | Date
      | string;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionCreateNestedOneWithoutUserInput;
    tags?: TagCreateNestedManyWithoutUserInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput;
    tags?: TagUncheckedCreateNestedManyWithoutUserInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesUncheckedCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput;
    tags?: TagUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput;
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUncheckedUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrganizationCreateInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    members?: MembershipCreateNestedManyWithoutOrganizationInput;
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput;
    templates?: MinutesTemplateCreateNestedManyWithoutOrganizationInput;
    tags?: TagCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    members?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutOrganizationInput;
    tags?: TagUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    members?: MembershipUpdateManyWithoutOrganizationNestedInput;
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutOrganizationNestedInput;
    tags?: TagUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    members?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutOrganizationNestedInput;
    tags?: TagUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationCreateManyInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
  };

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type MembershipCreateInput = {
    id?: string;
    role?: $Enums.MemberRole;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutMembershipsInput;
    organization: OrganizationCreateNestedOneWithoutMembersInput;
  };

  export type MembershipUncheckedCreateInput = {
    id?: string;
    userId: string;
    organizationId: string;
    role?: $Enums.MemberRole;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput;
  };

  export type MembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MembershipCreateManyInput = {
    id?: string;
    userId: string;
    organizationId: string;
    role?: $Enums.MemberRole;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesTemplateCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    format: string;
    sections: JsonNullValueInput | InputJsonValue;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutTemplatesInput;
    organization?: OrganizationCreateNestedOneWithoutTemplatesInput;
  };

  export type MinutesTemplateUncheckedCreateInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    name: string;
    description?: string | null;
    format: string;
    sections: JsonNullValueInput | InputJsonValue;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MinutesTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutTemplatesNestedInput;
    organization?: OrganizationUpdateOneWithoutTemplatesNestedInput;
  };

  export type MinutesTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesTemplateCreateManyInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    name: string;
    description?: string | null;
    format: string;
    sections: JsonNullValueInput | InputJsonValue;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MinutesTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PlanCreateInput = {
    id?: string;
    name: string;
    maxMinutesPerUpload?: number;
    maxUploadsPerWeek?: number;
    monthlyMinutesLimit?: number;
    price?: Decimal | DecimalJsLike | number | string;
    currency?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput;
  };

  export type PlanUncheckedCreateInput = {
    id?: string;
    name: string;
    maxMinutesPerUpload?: number;
    maxUploadsPerWeek?: number;
    monthlyMinutesLimit?: number;
    price?: Decimal | DecimalJsLike | number | string;
    currency?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput;
  };

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    maxMinutesPerUpload?: IntFieldUpdateOperationsInput | number;
    maxUploadsPerWeek?: IntFieldUpdateOperationsInput | number;
    monthlyMinutesLimit?: IntFieldUpdateOperationsInput | number;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput;
  };

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    maxMinutesPerUpload?: IntFieldUpdateOperationsInput | number;
    maxUploadsPerWeek?: IntFieldUpdateOperationsInput | number;
    monthlyMinutesLimit?: IntFieldUpdateOperationsInput | number;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput;
  };

  export type PlanCreateManyInput = {
    id?: string;
    name: string;
    maxMinutesPerUpload?: number;
    maxUploadsPerWeek?: number;
    monthlyMinutesLimit?: number;
    price?: Decimal | DecimalJsLike | number | string;
    currency?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    maxMinutesPerUpload?: IntFieldUpdateOperationsInput | number;
    maxUploadsPerWeek?: IntFieldUpdateOperationsInput | number;
    monthlyMinutesLimit?: IntFieldUpdateOperationsInput | number;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    maxMinutesPerUpload?: IntFieldUpdateOperationsInput | number;
    maxUploadsPerWeek?: IntFieldUpdateOperationsInput | number;
    monthlyMinutesLimit?: IntFieldUpdateOperationsInput | number;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubscriptionCreateInput = {
    id?: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
    plan: PlanCreateNestedOneWithoutSubscriptionsInput;
    user: UserCreateNestedOneWithoutSubscriptionInput;
    usage?: WeeklyUsageCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionUncheckedCreateInput = {
    id?: string;
    userId: string;
    planId: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
    usage?: WeeklyUsageUncheckedCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput;
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput;
    usage?: WeeklyUsageUpdateManyWithoutSubscriptionNestedInput;
  };

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usage?: WeeklyUsageUncheckedUpdateManyWithoutSubscriptionNestedInput;
  };

  export type SubscriptionCreateManyInput = {
    id?: string;
    userId: string;
    planId: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
  };

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type WeeklyUsageCreateInput = {
    id?: string;
    weekStartDate: Date | string;
    uploadCount?: number;
    minutesProcessed?: number;
    subscription: SubscriptionCreateNestedOneWithoutUsageInput;
  };

  export type WeeklyUsageUncheckedCreateInput = {
    id?: string;
    subscriptionId: string;
    weekStartDate: Date | string;
    uploadCount?: number;
    minutesProcessed?: number;
  };

  export type WeeklyUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    uploadCount?: IntFieldUpdateOperationsInput | number;
    minutesProcessed?: IntFieldUpdateOperationsInput | number;
    subscription?: SubscriptionUpdateOneRequiredWithoutUsageNestedInput;
  };

  export type WeeklyUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subscriptionId?: StringFieldUpdateOperationsInput | string;
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    uploadCount?: IntFieldUpdateOperationsInput | number;
    minutesProcessed?: IntFieldUpdateOperationsInput | number;
  };

  export type WeeklyUsageCreateManyInput = {
    id?: string;
    subscriptionId: string;
    weekStartDate: Date | string;
    uploadCount?: number;
    minutesProcessed?: number;
  };

  export type WeeklyUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    uploadCount?: IntFieldUpdateOperationsInput | number;
    minutesProcessed?: IntFieldUpdateOperationsInput | number;
  };

  export type WeeklyUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subscriptionId?: StringFieldUpdateOperationsInput | string;
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    uploadCount?: IntFieldUpdateOperationsInput | number;
    minutesProcessed?: IntFieldUpdateOperationsInput | number;
  };

  export type MeetingCreateInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentCreateNestedManyWithoutMeetingInput;
    user: UserCreateNestedOneWithoutMeetingsInput;
    organization?: OrganizationCreateNestedOneWithoutMeetingsInput;
    calendarConnection?: CalendarConnectionCreateNestedOneWithoutMeetingsInput;
    tags?: MeetingTagCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentUncheckedCreateNestedManyWithoutMeetingInput;
    tags?: MeetingTagUncheckedCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesUncheckedCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerUncheckedCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUpdateManyWithoutMeetingNestedInput;
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput;
    organization?: OrganizationUpdateOneWithoutMeetingsNestedInput;
    calendarConnection?: CalendarConnectionUpdateOneWithoutMeetingsNestedInput;
    tags?: MeetingTagUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput;
    tags?: MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUncheckedUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUncheckedUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingCreateManyInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
  };

  export type MeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type MeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type KeyMomentCreateInput = {
    id?: string;
    timestamp: number;
    label: string;
    description?: string | null;
    type?: $Enums.MomentType;
    isAutomatic?: boolean;
    createdBy?: string | null;
    createdAt?: Date | string;
    meeting: MeetingCreateNestedOneWithoutKeyMomentsInput;
  };

  export type KeyMomentUncheckedCreateInput = {
    id?: string;
    meetingId: string;
    timestamp: number;
    label: string;
    description?: string | null;
    type?: $Enums.MomentType;
    isAutomatic?: boolean;
    createdBy?: string | null;
    createdAt?: Date | string;
  };

  export type KeyMomentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timestamp?: FloatFieldUpdateOperationsInput | number;
    label?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumMomentTypeFieldUpdateOperationsInput | $Enums.MomentType;
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meeting?: MeetingUpdateOneRequiredWithoutKeyMomentsNestedInput;
  };

  export type KeyMomentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    timestamp?: FloatFieldUpdateOperationsInput | number;
    label?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumMomentTypeFieldUpdateOperationsInput | $Enums.MomentType;
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type KeyMomentCreateManyInput = {
    id?: string;
    meetingId: string;
    timestamp: number;
    label: string;
    description?: string | null;
    type?: $Enums.MomentType;
    isAutomatic?: boolean;
    createdBy?: string | null;
    createdAt?: Date | string;
  };

  export type KeyMomentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timestamp?: FloatFieldUpdateOperationsInput | number;
    label?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumMomentTypeFieldUpdateOperationsInput | $Enums.MomentType;
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type KeyMomentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    timestamp?: FloatFieldUpdateOperationsInput | number;
    label?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumMomentTypeFieldUpdateOperationsInput | $Enums.MomentType;
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TranscriptSegmentCreateInput = {
    id?: string;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    edits?: SegmentEditCreateNestedManyWithoutSegmentInput;
    corrections?: TranscriptCorrectionCreateNestedManyWithoutSegmentInput;
    meeting: MeetingCreateNestedOneWithoutTranscriptInput;
    speaker?: SpeakerCreateNestedOneWithoutSegmentsInput;
  };

  export type TranscriptSegmentUncheckedCreateInput = {
    id?: string;
    meetingId: string;
    speakerId?: string | null;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    edits?: SegmentEditUncheckedCreateNestedManyWithoutSegmentInput;
    corrections?: TranscriptCorrectionUncheckedCreateNestedManyWithoutSegmentInput;
  };

  export type TranscriptSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    edits?: SegmentEditUpdateManyWithoutSegmentNestedInput;
    corrections?: TranscriptCorrectionUpdateManyWithoutSegmentNestedInput;
    meeting?: MeetingUpdateOneRequiredWithoutTranscriptNestedInput;
    speaker?: SpeakerUpdateOneWithoutSegmentsNestedInput;
  };

  export type TranscriptSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    edits?: SegmentEditUncheckedUpdateManyWithoutSegmentNestedInput;
    corrections?: TranscriptCorrectionUncheckedUpdateManyWithoutSegmentNestedInput;
  };

  export type TranscriptSegmentCreateManyInput = {
    id?: string;
    meetingId: string;
    speakerId?: string | null;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
  };

  export type TranscriptSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TranscriptSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TranscriptCorrectionCreateInput = {
    id?: string;
    originalText: string;
    correctedText: string;
    correctedBy: string;
    createdAt?: Date | string;
    segment: TranscriptSegmentCreateNestedOneWithoutCorrectionsInput;
  };

  export type TranscriptCorrectionUncheckedCreateInput = {
    id?: string;
    segmentId: string;
    originalText: string;
    correctedText: string;
    correctedBy: string;
    createdAt?: Date | string;
  };

  export type TranscriptCorrectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    originalText?: StringFieldUpdateOperationsInput | string;
    correctedText?: StringFieldUpdateOperationsInput | string;
    correctedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    segment?: TranscriptSegmentUpdateOneRequiredWithoutCorrectionsNestedInput;
  };

  export type TranscriptCorrectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    segmentId?: StringFieldUpdateOperationsInput | string;
    originalText?: StringFieldUpdateOperationsInput | string;
    correctedText?: StringFieldUpdateOperationsInput | string;
    correctedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TranscriptCorrectionCreateManyInput = {
    id?: string;
    segmentId: string;
    originalText: string;
    correctedText: string;
    correctedBy: string;
    createdAt?: Date | string;
  };

  export type TranscriptCorrectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    originalText?: StringFieldUpdateOperationsInput | string;
    correctedText?: StringFieldUpdateOperationsInput | string;
    correctedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TranscriptCorrectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    segmentId?: StringFieldUpdateOperationsInput | string;
    originalText?: StringFieldUpdateOperationsInput | string;
    correctedText?: StringFieldUpdateOperationsInput | string;
    correctedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SegmentEditCreateInput = {
    id?: string;
    previousText: string;
    newText: string;
    editedBy: string;
    editReason?: string | null;
    createdAt?: Date | string;
    segment: TranscriptSegmentCreateNestedOneWithoutEditsInput;
  };

  export type SegmentEditUncheckedCreateInput = {
    id?: string;
    segmentId: string;
    previousText: string;
    newText: string;
    editedBy: string;
    editReason?: string | null;
    createdAt?: Date | string;
  };

  export type SegmentEditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousText?: StringFieldUpdateOperationsInput | string;
    newText?: StringFieldUpdateOperationsInput | string;
    editedBy?: StringFieldUpdateOperationsInput | string;
    editReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    segment?: TranscriptSegmentUpdateOneRequiredWithoutEditsNestedInput;
  };

  export type SegmentEditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    segmentId?: StringFieldUpdateOperationsInput | string;
    previousText?: StringFieldUpdateOperationsInput | string;
    newText?: StringFieldUpdateOperationsInput | string;
    editedBy?: StringFieldUpdateOperationsInput | string;
    editReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SegmentEditCreateManyInput = {
    id?: string;
    segmentId: string;
    previousText: string;
    newText: string;
    editedBy: string;
    editReason?: string | null;
    createdAt?: Date | string;
  };

  export type SegmentEditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousText?: StringFieldUpdateOperationsInput | string;
    newText?: StringFieldUpdateOperationsInput | string;
    editedBy?: StringFieldUpdateOperationsInput | string;
    editReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SegmentEditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    segmentId?: StringFieldUpdateOperationsInput | string;
    previousText?: StringFieldUpdateOperationsInput | string;
    newText?: StringFieldUpdateOperationsInput | string;
    editedBy?: StringFieldUpdateOperationsInput | string;
    editReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SpeakerCreateInput = {
    id?: string;
    name: string;
    isUnknown?: boolean;
    isConfirmed?: boolean;
    nameConfidence?: number;
    meeting: MeetingCreateNestedOneWithoutSpeakersInput;
    segments?: TranscriptSegmentCreateNestedManyWithoutSpeakerInput;
  };

  export type SpeakerUncheckedCreateInput = {
    id?: string;
    meetingId: string;
    name: string;
    isUnknown?: boolean;
    isConfirmed?: boolean;
    nameConfidence?: number;
    segments?: TranscriptSegmentUncheckedCreateNestedManyWithoutSpeakerInput;
  };

  export type SpeakerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isUnknown?: BoolFieldUpdateOperationsInput | boolean;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    nameConfidence?: FloatFieldUpdateOperationsInput | number;
    meeting?: MeetingUpdateOneRequiredWithoutSpeakersNestedInput;
    segments?: TranscriptSegmentUpdateManyWithoutSpeakerNestedInput;
  };

  export type SpeakerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isUnknown?: BoolFieldUpdateOperationsInput | boolean;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    nameConfidence?: FloatFieldUpdateOperationsInput | number;
    segments?: TranscriptSegmentUncheckedUpdateManyWithoutSpeakerNestedInput;
  };

  export type SpeakerCreateManyInput = {
    id?: string;
    meetingId: string;
    name: string;
    isUnknown?: boolean;
    isConfirmed?: boolean;
    nameConfidence?: number;
  };

  export type SpeakerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isUnknown?: BoolFieldUpdateOperationsInput | boolean;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    nameConfidence?: FloatFieldUpdateOperationsInput | number;
  };

  export type SpeakerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isUnknown?: BoolFieldUpdateOperationsInput | boolean;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    nameConfidence?: FloatFieldUpdateOperationsInput | number;
  };

  export type MinutesCreateInput = {
    id?: string;
    content: string;
    status?: $Enums.MinutesStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    meeting: MeetingCreateNestedOneWithoutMinutesInput;
    reviewer?: UserCreateNestedOneWithoutReviewedMinutesInput;
    versions?: MinutesVersionCreateNestedManyWithoutMinutesInput;
  };

  export type MinutesUncheckedCreateInput = {
    id?: string;
    meetingId: string;
    content: string;
    status?: $Enums.MinutesStatus;
    reviewerId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    versions?: MinutesVersionUncheckedCreateNestedManyWithoutMinutesInput;
  };

  export type MinutesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meeting?: MeetingUpdateOneRequiredWithoutMinutesNestedInput;
    reviewer?: UserUpdateOneWithoutReviewedMinutesNestedInput;
    versions?: MinutesVersionUpdateManyWithoutMinutesNestedInput;
  };

  export type MinutesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    versions?: MinutesVersionUncheckedUpdateManyWithoutMinutesNestedInput;
  };

  export type MinutesCreateManyInput = {
    id?: string;
    meetingId: string;
    content: string;
    status?: $Enums.MinutesStatus;
    reviewerId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MinutesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesVersionCreateInput = {
    id?: string;
    content: string;
    version: number;
    createdAt?: Date | string;
    minutes: MinutesCreateNestedOneWithoutVersionsInput;
  };

  export type MinutesVersionUncheckedCreateInput = {
    id?: string;
    minutesId: string;
    content: string;
    version: number;
    createdAt?: Date | string;
  };

  export type MinutesVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    version?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    minutes?: MinutesUpdateOneRequiredWithoutVersionsNestedInput;
  };

  export type MinutesVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    minutesId?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    version?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesVersionCreateManyInput = {
    id?: string;
    minutesId: string;
    content: string;
    version: number;
    createdAt?: Date | string;
  };

  export type MinutesVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    version?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    minutesId?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    version?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationPreferenceCreateInput = {
    id?: string;
    email?: boolean;
    push?: boolean;
    deviceToken?: string | null;
    user: UserCreateNestedOneWithoutNotificationSettingsInput;
  };

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string;
    userId: string;
    email?: boolean;
    push?: boolean;
    deviceToken?: string | null;
  };

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: BoolFieldUpdateOperationsInput | boolean;
    push?: BoolFieldUpdateOperationsInput | boolean;
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutNotificationSettingsNestedInput;
  };

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    email?: BoolFieldUpdateOperationsInput | boolean;
    push?: BoolFieldUpdateOperationsInput | boolean;
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationPreferenceCreateManyInput = {
    id?: string;
    userId: string;
    email?: boolean;
    push?: boolean;
    deviceToken?: string | null;
  };

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: BoolFieldUpdateOperationsInput | boolean;
    push?: BoolFieldUpdateOperationsInput | boolean;
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    email?: BoolFieldUpdateOperationsInput | boolean;
    push?: BoolFieldUpdateOperationsInput | boolean;
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TagCreateInput = {
    id?: string;
    name: string;
    color?: string;
    createdAt?: Date | string;
    meetings?: MeetingTagCreateNestedManyWithoutTagInput;
    user: UserCreateNestedOneWithoutTagsInput;
    organization?: OrganizationCreateNestedOneWithoutTagsInput;
  };

  export type TagUncheckedCreateInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    name: string;
    color?: string;
    createdAt?: Date | string;
    meetings?: MeetingTagUncheckedCreateNestedManyWithoutTagInput;
  };

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meetings?: MeetingTagUpdateManyWithoutTagNestedInput;
    user?: UserUpdateOneRequiredWithoutTagsNestedInput;
    organization?: OrganizationUpdateOneWithoutTagsNestedInput;
  };

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meetings?: MeetingTagUncheckedUpdateManyWithoutTagNestedInput;
  };

  export type TagCreateManyInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    name: string;
    color?: string;
    createdAt?: Date | string;
  };

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingTagCreateInput = {
    id?: string;
    createdAt?: Date | string;
    meeting: MeetingCreateNestedOneWithoutTagsInput;
    tag: TagCreateNestedOneWithoutMeetingsInput;
  };

  export type MeetingTagUncheckedCreateInput = {
    id?: string;
    meetingId: string;
    tagId: string;
    createdAt?: Date | string;
  };

  export type MeetingTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meeting?: MeetingUpdateOneRequiredWithoutTagsNestedInput;
    tag?: TagUpdateOneRequiredWithoutMeetingsNestedInput;
  };

  export type MeetingTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    tagId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingTagCreateManyInput = {
    id?: string;
    meetingId: string;
    tagId: string;
    createdAt?: Date | string;
  };

  export type MeetingTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    tagId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateInput = {
    id?: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    read?: boolean;
    meetingId?: string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutNotificationsInput;
  };

  export type NotificationUncheckedCreateInput = {
    id?: string;
    userId: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    read?: boolean;
    meetingId?: string | null;
    createdAt?: Date | string;
  };

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput;
  };

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateManyInput = {
    id?: string;
    userId: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    read?: boolean;
    meetingId?: string | null;
    createdAt?: Date | string;
  };

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ShareLinkCreateInput = {
    id?: string;
    token: string;
    expiresAt?: Date | string | null;
    shareType?: $Enums.ShareType;
    createdAt?: Date | string;
    meeting: MeetingCreateNestedOneWithoutShareLinksInput;
  };

  export type ShareLinkUncheckedCreateInput = {
    id?: string;
    meetingId: string;
    token: string;
    expiresAt?: Date | string | null;
    shareType?: $Enums.ShareType;
    createdAt?: Date | string;
  };

  export type ShareLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    shareType?: EnumShareTypeFieldUpdateOperationsInput | $Enums.ShareType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meeting?: MeetingUpdateOneRequiredWithoutShareLinksNestedInput;
  };

  export type ShareLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    shareType?: EnumShareTypeFieldUpdateOperationsInput | $Enums.ShareType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ShareLinkCreateManyInput = {
    id?: string;
    meetingId: string;
    token: string;
    expiresAt?: Date | string | null;
    shareType?: $Enums.ShareType;
    createdAt?: Date | string;
  };

  export type ShareLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    shareType?: EnumShareTypeFieldUpdateOperationsInput | $Enums.ShareType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ShareLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    shareType?: EnumShareTypeFieldUpdateOperationsInput | $Enums.ShareType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CalendarConnectionCreateInput = {
    id?: string;
    provider: $Enums.CalendarProvider;
    accessToken: string;
    refreshToken: string;
    expiresAt: Date | string;
    lastSyncAt?: Date | string | null;
    status?: $Enums.ConnectionStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutCalendarConnectionsInput;
    meetings?: MeetingCreateNestedManyWithoutCalendarConnectionInput;
  };

  export type CalendarConnectionUncheckedCreateInput = {
    id?: string;
    userId: string;
    provider: $Enums.CalendarProvider;
    accessToken: string;
    refreshToken: string;
    expiresAt: Date | string;
    lastSyncAt?: Date | string | null;
    status?: $Enums.ConnectionStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    meetings?: MeetingUncheckedCreateNestedManyWithoutCalendarConnectionInput;
  };

  export type CalendarConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?:
      | EnumCalendarProviderFieldUpdateOperationsInput
      | $Enums.CalendarProvider;
    accessToken?: StringFieldUpdateOperationsInput | string;
    refreshToken?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastSyncAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFieldUpdateOperationsInput
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCalendarConnectionsNestedInput;
    meetings?: MeetingUpdateManyWithoutCalendarConnectionNestedInput;
  };

  export type CalendarConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    provider?:
      | EnumCalendarProviderFieldUpdateOperationsInput
      | $Enums.CalendarProvider;
    accessToken?: StringFieldUpdateOperationsInput | string;
    refreshToken?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastSyncAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFieldUpdateOperationsInput
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meetings?: MeetingUncheckedUpdateManyWithoutCalendarConnectionNestedInput;
  };

  export type CalendarConnectionCreateManyInput = {
    id?: string;
    userId: string;
    provider: $Enums.CalendarProvider;
    accessToken: string;
    refreshToken: string;
    expiresAt: Date | string;
    lastSyncAt?: Date | string | null;
    status?: $Enums.ConnectionStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CalendarConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?:
      | EnumCalendarProviderFieldUpdateOperationsInput
      | $Enums.CalendarProvider;
    accessToken?: StringFieldUpdateOperationsInput | string;
    refreshToken?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastSyncAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFieldUpdateOperationsInput
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CalendarConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    provider?:
      | EnumCalendarProviderFieldUpdateOperationsInput
      | $Enums.CalendarProvider;
    accessToken?: StringFieldUpdateOperationsInput | string;
    refreshToken?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastSyncAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFieldUpdateOperationsInput
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput;
    some?: MeetingWhereInput;
    none?: MeetingWhereInput;
  };

  export type MinutesTemplateListRelationFilter = {
    every?: MinutesTemplateWhereInput;
    some?: MinutesTemplateWhereInput;
    none?: MinutesTemplateWhereInput;
  };

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
  };

  export type NotificationPreferenceNullableScalarRelationFilter = {
    is?: NotificationPreferenceWhereInput | null;
    isNot?: NotificationPreferenceWhereInput | null;
  };

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null;
    isNot?: SubscriptionWhereInput | null;
  };

  export type TagListRelationFilter = {
    every?: TagWhereInput;
    some?: TagWhereInput;
    none?: TagWhereInput;
  };

  export type MembershipListRelationFilter = {
    every?: MembershipWhereInput;
    some?: MembershipWhereInput;
    none?: MembershipWhereInput;
  };

  export type MinutesListRelationFilter = {
    every?: MinutesWhereInput;
    some?: MinutesWhereInput;
    none?: MinutesWhereInput;
  };

  export type CalendarConnectionListRelationFilter = {
    every?: CalendarConnectionWhereInput;
    some?: CalendarConnectionWhereInput;
    none?: CalendarConnectionWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MinutesTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MembershipOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MinutesOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CalendarConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    role?: SortOrder;
    isActive?: SortOrder;
    telegramId?: SortOrder;
    telegramChatId?: SortOrder;
    telegramLinkCode?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    role?: SortOrder;
    isActive?: SortOrder;
    telegramId?: SortOrder;
    telegramChatId?: SortOrder;
    telegramLinkCode?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    role?: SortOrder;
    isActive?: SortOrder;
    telegramId?: SortOrder;
    telegramChatId?: SortOrder;
    telegramLinkCode?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRoleFilter<$PrismaModel>;
    _max?: NestedEnumRoleFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isPersonal?: SortOrder;
    autoRedact?: SortOrder;
    retentionDays?: SortOrder;
  };

  export type OrganizationAvgOrderByAggregateInput = {
    retentionDays?: SortOrder;
  };

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isPersonal?: SortOrder;
    autoRedact?: SortOrder;
    retentionDays?: SortOrder;
  };

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isPersonal?: SortOrder;
    autoRedact?: SortOrder;
    retentionDays?: SortOrder;
  };

  export type OrganizationSumOrderByAggregateInput = {
    retentionDays?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type EnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput;
    isNot?: OrganizationWhereInput;
  };

  export type MembershipUserIdOrganizationIdCompoundUniqueInput = {
    userId: string;
    organizationId: string;
  };

  export type MembershipCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MembershipMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MembershipMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.MemberRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>;
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null;
    isNot?: OrganizationWhereInput | null;
  };

  export type MinutesTemplateCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    format?: SortOrder;
    sections?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MinutesTemplateMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    format?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MinutesTemplateMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    format?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type DecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput;
    some?: SubscriptionWhereInput;
    none?: SubscriptionWhereInput;
  };

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    maxMinutesPerUpload?: SortOrder;
    maxUploadsPerWeek?: SortOrder;
    monthlyMinutesLimit?: SortOrder;
    price?: SortOrder;
    currency?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PlanAvgOrderByAggregateInput = {
    maxMinutesPerUpload?: SortOrder;
    maxUploadsPerWeek?: SortOrder;
    monthlyMinutesLimit?: SortOrder;
    price?: SortOrder;
  };

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    maxMinutesPerUpload?: SortOrder;
    maxUploadsPerWeek?: SortOrder;
    monthlyMinutesLimit?: SortOrder;
    price?: SortOrder;
    currency?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    maxMinutesPerUpload?: SortOrder;
    maxUploadsPerWeek?: SortOrder;
    monthlyMinutesLimit?: SortOrder;
    price?: SortOrder;
    currency?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PlanSumOrderByAggregateInput = {
    maxMinutesPerUpload?: SortOrder;
    maxUploadsPerWeek?: SortOrder;
    monthlyMinutesLimit?: SortOrder;
    price?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput;
    isNot?: PlanWhereInput;
  };

  export type WeeklyUsageListRelationFilter = {
    every?: WeeklyUsageWhereInput;
    some?: WeeklyUsageWhereInput;
    none?: WeeklyUsageWhereInput;
  };

  export type WeeklyUsageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    planId?: SortOrder;
    active?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
  };

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    planId?: SortOrder;
    active?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
  };

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    planId?: SortOrder;
    active?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput;
    isNot?: SubscriptionWhereInput;
  };

  export type WeeklyUsageSubscriptionIdWeekStartDateCompoundUniqueInput = {
    subscriptionId: string;
    weekStartDate: Date | string;
  };

  export type WeeklyUsageCountOrderByAggregateInput = {
    id?: SortOrder;
    subscriptionId?: SortOrder;
    weekStartDate?: SortOrder;
    uploadCount?: SortOrder;
    minutesProcessed?: SortOrder;
  };

  export type WeeklyUsageAvgOrderByAggregateInput = {
    uploadCount?: SortOrder;
    minutesProcessed?: SortOrder;
  };

  export type WeeklyUsageMaxOrderByAggregateInput = {
    id?: SortOrder;
    subscriptionId?: SortOrder;
    weekStartDate?: SortOrder;
    uploadCount?: SortOrder;
    minutesProcessed?: SortOrder;
  };

  export type WeeklyUsageMinOrderByAggregateInput = {
    id?: SortOrder;
    subscriptionId?: SortOrder;
    weekStartDate?: SortOrder;
    uploadCount?: SortOrder;
    minutesProcessed?: SortOrder;
  };

  export type WeeklyUsageSumOrderByAggregateInput = {
    uploadCount?: SortOrder;
    minutesProcessed?: SortOrder;
  };

  export type EnumMeetingStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.MeetingStatus
      | EnumMeetingStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.MeetingStatus[]
      | ListEnumMeetingStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MeetingStatus[]
      | ListEnumMeetingStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumMeetingStatusFilter<$PrismaModel> | $Enums.MeetingStatus;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type KeyMomentListRelationFilter = {
    every?: KeyMomentWhereInput;
    some?: KeyMomentWhereInput;
    none?: KeyMomentWhereInput;
  };

  export type CalendarConnectionNullableScalarRelationFilter = {
    is?: CalendarConnectionWhereInput | null;
    isNot?: CalendarConnectionWhereInput | null;
  };

  export type MeetingTagListRelationFilter = {
    every?: MeetingTagWhereInput;
    some?: MeetingTagWhereInput;
    none?: MeetingTagWhereInput;
  };

  export type MinutesNullableScalarRelationFilter = {
    is?: MinutesWhereInput | null;
    isNot?: MinutesWhereInput | null;
  };

  export type ShareLinkListRelationFilter = {
    every?: ShareLinkWhereInput;
    some?: ShareLinkWhereInput;
    none?: ShareLinkWhereInput;
  };

  export type SpeakerListRelationFilter = {
    every?: SpeakerWhereInput;
    some?: SpeakerWhereInput;
    none?: SpeakerWhereInput;
  };

  export type TranscriptSegmentListRelationFilter = {
    every?: TranscriptSegmentWhereInput;
    some?: TranscriptSegmentWhereInput;
    none?: TranscriptSegmentWhereInput;
  };

  export type KeyMomentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MeetingTagOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ShareLinkOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SpeakerOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TranscriptSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    calendarConnectionId?: SortOrder;
    title?: SortOrder;
    originalFileName?: SortOrder;
    durationSeconds?: SortOrder;
    fileUrl?: SortOrder;
    status?: SortOrder;
    languageCode?: SortOrder;
    transcriptLang?: SortOrder;
    minutesLang?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    avgSpeakerConfidence?: SortOrder;
    inaudibleCount?: SortOrder;
    qualityScore?: SortOrder;
    lastProcessedAt?: SortOrder;
  };

  export type MeetingAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder;
    avgSpeakerConfidence?: SortOrder;
    inaudibleCount?: SortOrder;
    qualityScore?: SortOrder;
  };

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    calendarConnectionId?: SortOrder;
    title?: SortOrder;
    originalFileName?: SortOrder;
    durationSeconds?: SortOrder;
    fileUrl?: SortOrder;
    status?: SortOrder;
    languageCode?: SortOrder;
    transcriptLang?: SortOrder;
    minutesLang?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    avgSpeakerConfidence?: SortOrder;
    inaudibleCount?: SortOrder;
    qualityScore?: SortOrder;
    lastProcessedAt?: SortOrder;
  };

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    calendarConnectionId?: SortOrder;
    title?: SortOrder;
    originalFileName?: SortOrder;
    durationSeconds?: SortOrder;
    fileUrl?: SortOrder;
    status?: SortOrder;
    languageCode?: SortOrder;
    transcriptLang?: SortOrder;
    minutesLang?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    avgSpeakerConfidence?: SortOrder;
    inaudibleCount?: SortOrder;
    qualityScore?: SortOrder;
    lastProcessedAt?: SortOrder;
  };

  export type MeetingSumOrderByAggregateInput = {
    durationSeconds?: SortOrder;
    avgSpeakerConfidence?: SortOrder;
    inaudibleCount?: SortOrder;
    qualityScore?: SortOrder;
  };

  export type EnumMeetingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.MeetingStatus
      | EnumMeetingStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.MeetingStatus[]
      | ListEnumMeetingStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MeetingStatus[]
      | ListEnumMeetingStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumMeetingStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.MeetingStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMeetingStatusFilter<$PrismaModel>;
    _max?: NestedEnumMeetingStatusFilter<$PrismaModel>;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type EnumMomentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MomentType | EnumMomentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.MomentType[] | ListEnumMomentTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MomentType[] | ListEnumMomentTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumMomentTypeFilter<$PrismaModel> | $Enums.MomentType;
  };

  export type MeetingScalarRelationFilter = {
    is?: MeetingWhereInput;
    isNot?: MeetingWhereInput;
  };

  export type KeyMomentCountOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    timestamp?: SortOrder;
    label?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    isAutomatic?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
  };

  export type KeyMomentAvgOrderByAggregateInput = {
    timestamp?: SortOrder;
  };

  export type KeyMomentMaxOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    timestamp?: SortOrder;
    label?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    isAutomatic?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
  };

  export type KeyMomentMinOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    timestamp?: SortOrder;
    label?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    isAutomatic?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
  };

  export type KeyMomentSumOrderByAggregateInput = {
    timestamp?: SortOrder;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type EnumMomentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MomentType | EnumMomentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.MomentType[] | ListEnumMomentTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MomentType[] | ListEnumMomentTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumMomentTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.MomentType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMomentTypeFilter<$PrismaModel>;
    _max?: NestedEnumMomentTypeFilter<$PrismaModel>;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type SegmentEditListRelationFilter = {
    every?: SegmentEditWhereInput;
    some?: SegmentEditWhereInput;
    none?: SegmentEditWhereInput;
  };

  export type TranscriptCorrectionListRelationFilter = {
    every?: TranscriptCorrectionWhereInput;
    some?: TranscriptCorrectionWhereInput;
    none?: TranscriptCorrectionWhereInput;
  };

  export type SpeakerNullableScalarRelationFilter = {
    is?: SpeakerWhereInput | null;
    isNot?: SpeakerWhereInput | null;
  };

  export type SegmentEditOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TranscriptCorrectionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TranscriptSegmentCountOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    speakerId?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    text?: SortOrder;
    languagesUsed?: SortOrder;
    originalText?: SortOrder;
  };

  export type TranscriptSegmentAvgOrderByAggregateInput = {
    startTime?: SortOrder;
    endTime?: SortOrder;
  };

  export type TranscriptSegmentMaxOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    speakerId?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    text?: SortOrder;
    originalText?: SortOrder;
  };

  export type TranscriptSegmentMinOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    speakerId?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    text?: SortOrder;
    originalText?: SortOrder;
  };

  export type TranscriptSegmentSumOrderByAggregateInput = {
    startTime?: SortOrder;
    endTime?: SortOrder;
  };

  export type TranscriptSegmentScalarRelationFilter = {
    is?: TranscriptSegmentWhereInput;
    isNot?: TranscriptSegmentWhereInput;
  };

  export type TranscriptCorrectionCountOrderByAggregateInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    originalText?: SortOrder;
    correctedText?: SortOrder;
    correctedBy?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TranscriptCorrectionMaxOrderByAggregateInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    originalText?: SortOrder;
    correctedText?: SortOrder;
    correctedBy?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TranscriptCorrectionMinOrderByAggregateInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    originalText?: SortOrder;
    correctedText?: SortOrder;
    correctedBy?: SortOrder;
    createdAt?: SortOrder;
  };

  export type SegmentEditCountOrderByAggregateInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    previousText?: SortOrder;
    newText?: SortOrder;
    editedBy?: SortOrder;
    editReason?: SortOrder;
    createdAt?: SortOrder;
  };

  export type SegmentEditMaxOrderByAggregateInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    previousText?: SortOrder;
    newText?: SortOrder;
    editedBy?: SortOrder;
    editReason?: SortOrder;
    createdAt?: SortOrder;
  };

  export type SegmentEditMinOrderByAggregateInput = {
    id?: SortOrder;
    segmentId?: SortOrder;
    previousText?: SortOrder;
    newText?: SortOrder;
    editedBy?: SortOrder;
    editReason?: SortOrder;
    createdAt?: SortOrder;
  };

  export type SpeakerCountOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    name?: SortOrder;
    isUnknown?: SortOrder;
    isConfirmed?: SortOrder;
    nameConfidence?: SortOrder;
  };

  export type SpeakerAvgOrderByAggregateInput = {
    nameConfidence?: SortOrder;
  };

  export type SpeakerMaxOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    name?: SortOrder;
    isUnknown?: SortOrder;
    isConfirmed?: SortOrder;
    nameConfidence?: SortOrder;
  };

  export type SpeakerMinOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    name?: SortOrder;
    isUnknown?: SortOrder;
    isConfirmed?: SortOrder;
    nameConfidence?: SortOrder;
  };

  export type SpeakerSumOrderByAggregateInput = {
    nameConfidence?: SortOrder;
  };

  export type EnumMinutesStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.MinutesStatus
      | EnumMinutesStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.MinutesStatus[]
      | ListEnumMinutesStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MinutesStatus[]
      | ListEnumMinutesStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumMinutesStatusFilter<$PrismaModel> | $Enums.MinutesStatus;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type MinutesVersionListRelationFilter = {
    every?: MinutesVersionWhereInput;
    some?: MinutesVersionWhereInput;
    none?: MinutesVersionWhereInput;
  };

  export type MinutesVersionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MinutesCountOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    content?: SortOrder;
    status?: SortOrder;
    reviewerId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MinutesMaxOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    content?: SortOrder;
    status?: SortOrder;
    reviewerId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MinutesMinOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    content?: SortOrder;
    status?: SortOrder;
    reviewerId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumMinutesStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.MinutesStatus
      | EnumMinutesStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.MinutesStatus[]
      | ListEnumMinutesStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MinutesStatus[]
      | ListEnumMinutesStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumMinutesStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.MinutesStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMinutesStatusFilter<$PrismaModel>;
    _max?: NestedEnumMinutesStatusFilter<$PrismaModel>;
  };

  export type MinutesScalarRelationFilter = {
    is?: MinutesWhereInput;
    isNot?: MinutesWhereInput;
  };

  export type MinutesVersionCountOrderByAggregateInput = {
    id?: SortOrder;
    minutesId?: SortOrder;
    content?: SortOrder;
    version?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MinutesVersionAvgOrderByAggregateInput = {
    version?: SortOrder;
  };

  export type MinutesVersionMaxOrderByAggregateInput = {
    id?: SortOrder;
    minutesId?: SortOrder;
    content?: SortOrder;
    version?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MinutesVersionMinOrderByAggregateInput = {
    id?: SortOrder;
    minutesId?: SortOrder;
    content?: SortOrder;
    version?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MinutesVersionSumOrderByAggregateInput = {
    version?: SortOrder;
  };

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    push?: SortOrder;
    deviceToken?: SortOrder;
  };

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    push?: SortOrder;
    deviceToken?: SortOrder;
  };

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    push?: SortOrder;
    deviceToken?: SortOrder;
  };

  export type TagUserIdNameCompoundUniqueInput = {
    userId: string;
    name: string;
  };

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    color?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    color?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    color?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TagScalarRelationFilter = {
    is?: TagWhereInput;
    isNot?: TagWhereInput;
  };

  export type MeetingTagMeetingIdTagIdCompoundUniqueInput = {
    meetingId: string;
    tagId: string;
  };

  export type MeetingTagCountOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    tagId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MeetingTagMaxOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    tagId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MeetingTagMinOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    tagId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationType
      | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationTypeFilter<$PrismaModel>
      | $Enums.NotificationType;
  };

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    read?: SortOrder;
    meetingId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    read?: SortOrder;
    meetingId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    read?: SortOrder;
    meetingId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationType
      | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>;
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>;
  };

  export type EnumShareTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareType | EnumShareTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ShareType[] | ListEnumShareTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ShareType[] | ListEnumShareTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumShareTypeFilter<$PrismaModel> | $Enums.ShareType;
  };

  export type ShareLinkCountOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrder;
    shareType?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ShareLinkMaxOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrder;
    shareType?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ShareLinkMinOrderByAggregateInput = {
    id?: SortOrder;
    meetingId?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrder;
    shareType?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumShareTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareType | EnumShareTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ShareType[] | ListEnumShareTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ShareType[] | ListEnumShareTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumShareTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.ShareType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumShareTypeFilter<$PrismaModel>;
    _max?: NestedEnumShareTypeFilter<$PrismaModel>;
  };

  export type EnumCalendarProviderFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.CalendarProvider
      | EnumCalendarProviderFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CalendarProvider[]
      | ListEnumCalendarProviderFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CalendarProvider[]
      | ListEnumCalendarProviderFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCalendarProviderFilter<$PrismaModel>
      | $Enums.CalendarProvider;
  };

  export type EnumConnectionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ConnectionStatus
      | EnumConnectionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ConnectionStatus[]
      | ListEnumConnectionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ConnectionStatus[]
      | ListEnumConnectionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumConnectionStatusFilter<$PrismaModel>
      | $Enums.ConnectionStatus;
  };

  export type CalendarConnectionUserIdProviderCompoundUniqueInput = {
    userId: string;
    provider: $Enums.CalendarProvider;
  };

  export type CalendarConnectionCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    expiresAt?: SortOrder;
    lastSyncAt?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CalendarConnectionMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    expiresAt?: SortOrder;
    lastSyncAt?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CalendarConnectionMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    expiresAt?: SortOrder;
    lastSyncAt?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumCalendarProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.CalendarProvider
      | EnumCalendarProviderFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CalendarProvider[]
      | ListEnumCalendarProviderFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CalendarProvider[]
      | ListEnumCalendarProviderFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCalendarProviderWithAggregatesFilter<$PrismaModel>
      | $Enums.CalendarProvider;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCalendarProviderFilter<$PrismaModel>;
    _max?: NestedEnumCalendarProviderFilter<$PrismaModel>;
  };

  export type EnumConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ConnectionStatus
      | EnumConnectionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ConnectionStatus[]
      | ListEnumConnectionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ConnectionStatus[]
      | ListEnumConnectionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumConnectionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ConnectionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumConnectionStatusFilter<$PrismaModel>;
    _max?: NestedEnumConnectionStatusFilter<$PrismaModel>;
  };

  export type MeetingCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          MeetingCreateWithoutUserInput,
          MeetingUncheckedCreateWithoutUserInput
        >
      | MeetingCreateWithoutUserInput[]
      | MeetingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutUserInput
      | MeetingCreateOrConnectWithoutUserInput[];
    createMany?: MeetingCreateManyUserInputEnvelope;
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
  };

  export type MinutesTemplateCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          MinutesTemplateCreateWithoutUserInput,
          MinutesTemplateUncheckedCreateWithoutUserInput
        >
      | MinutesTemplateCreateWithoutUserInput[]
      | MinutesTemplateUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MinutesTemplateCreateOrConnectWithoutUserInput
      | MinutesTemplateCreateOrConnectWithoutUserInput[];
    createMany?: MinutesTemplateCreateManyUserInputEnvelope;
    connect?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
  };

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<
      NotificationPreferenceCreateWithoutUserInput,
      NotificationPreferenceUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput;
    connect?: NotificationPreferenceWhereUniqueInput;
  };

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<
      SubscriptionCreateWithoutUserInput,
      SubscriptionUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput;
    connect?: SubscriptionWhereUniqueInput;
  };

  export type TagCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>
      | TagCreateWithoutUserInput[]
      | TagUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TagCreateOrConnectWithoutUserInput
      | TagCreateOrConnectWithoutUserInput[];
    createMany?: TagCreateManyUserInputEnvelope;
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[];
  };

  export type MembershipCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          MembershipCreateWithoutUserInput,
          MembershipUncheckedCreateWithoutUserInput
        >
      | MembershipCreateWithoutUserInput[]
      | MembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutUserInput
      | MembershipCreateOrConnectWithoutUserInput[];
    createMany?: MembershipCreateManyUserInputEnvelope;
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
  };

  export type MinutesCreateNestedManyWithoutReviewerInput = {
    create?:
      | XOR<
          MinutesCreateWithoutReviewerInput,
          MinutesUncheckedCreateWithoutReviewerInput
        >
      | MinutesCreateWithoutReviewerInput[]
      | MinutesUncheckedCreateWithoutReviewerInput[];
    connectOrCreate?:
      | MinutesCreateOrConnectWithoutReviewerInput
      | MinutesCreateOrConnectWithoutReviewerInput[];
    createMany?: MinutesCreateManyReviewerInputEnvelope;
    connect?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
  };

  export type CalendarConnectionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          CalendarConnectionCreateWithoutUserInput,
          CalendarConnectionUncheckedCreateWithoutUserInput
        >
      | CalendarConnectionCreateWithoutUserInput[]
      | CalendarConnectionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CalendarConnectionCreateOrConnectWithoutUserInput
      | CalendarConnectionCreateOrConnectWithoutUserInput[];
    createMany?: CalendarConnectionCreateManyUserInputEnvelope;
    connect?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
  };

  export type MeetingUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          MeetingCreateWithoutUserInput,
          MeetingUncheckedCreateWithoutUserInput
        >
      | MeetingCreateWithoutUserInput[]
      | MeetingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutUserInput
      | MeetingCreateOrConnectWithoutUserInput[];
    createMany?: MeetingCreateManyUserInputEnvelope;
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
  };

  export type MinutesTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          MinutesTemplateCreateWithoutUserInput,
          MinutesTemplateUncheckedCreateWithoutUserInput
        >
      | MinutesTemplateCreateWithoutUserInput[]
      | MinutesTemplateUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MinutesTemplateCreateOrConnectWithoutUserInput
      | MinutesTemplateCreateOrConnectWithoutUserInput[];
    createMany?: MinutesTemplateCreateManyUserInputEnvelope;
    connect?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      NotificationPreferenceCreateWithoutUserInput,
      NotificationPreferenceUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput;
    connect?: NotificationPreferenceWhereUniqueInput;
  };

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      SubscriptionCreateWithoutUserInput,
      SubscriptionUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput;
    connect?: SubscriptionWhereUniqueInput;
  };

  export type TagUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>
      | TagCreateWithoutUserInput[]
      | TagUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TagCreateOrConnectWithoutUserInput
      | TagCreateOrConnectWithoutUserInput[];
    createMany?: TagCreateManyUserInputEnvelope;
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[];
  };

  export type MembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          MembershipCreateWithoutUserInput,
          MembershipUncheckedCreateWithoutUserInput
        >
      | MembershipCreateWithoutUserInput[]
      | MembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutUserInput
      | MembershipCreateOrConnectWithoutUserInput[];
    createMany?: MembershipCreateManyUserInputEnvelope;
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
  };

  export type MinutesUncheckedCreateNestedManyWithoutReviewerInput = {
    create?:
      | XOR<
          MinutesCreateWithoutReviewerInput,
          MinutesUncheckedCreateWithoutReviewerInput
        >
      | MinutesCreateWithoutReviewerInput[]
      | MinutesUncheckedCreateWithoutReviewerInput[];
    connectOrCreate?:
      | MinutesCreateOrConnectWithoutReviewerInput
      | MinutesCreateOrConnectWithoutReviewerInput[];
    createMany?: MinutesCreateManyReviewerInputEnvelope;
    connect?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
  };

  export type CalendarConnectionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          CalendarConnectionCreateWithoutUserInput,
          CalendarConnectionUncheckedCreateWithoutUserInput
        >
      | CalendarConnectionCreateWithoutUserInput[]
      | CalendarConnectionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CalendarConnectionCreateOrConnectWithoutUserInput
      | CalendarConnectionCreateOrConnectWithoutUserInput[];
    createMany?: CalendarConnectionCreateManyUserInputEnvelope;
    connect?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type MeetingUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          MeetingCreateWithoutUserInput,
          MeetingUncheckedCreateWithoutUserInput
        >
      | MeetingCreateWithoutUserInput[]
      | MeetingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutUserInput
      | MeetingCreateOrConnectWithoutUserInput[];
    upsert?:
      | MeetingUpsertWithWhereUniqueWithoutUserInput
      | MeetingUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MeetingCreateManyUserInputEnvelope;
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    update?:
      | MeetingUpdateWithWhereUniqueWithoutUserInput
      | MeetingUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MeetingUpdateManyWithWhereWithoutUserInput
      | MeetingUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[];
  };

  export type MinutesTemplateUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          MinutesTemplateCreateWithoutUserInput,
          MinutesTemplateUncheckedCreateWithoutUserInput
        >
      | MinutesTemplateCreateWithoutUserInput[]
      | MinutesTemplateUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MinutesTemplateCreateOrConnectWithoutUserInput
      | MinutesTemplateCreateOrConnectWithoutUserInput[];
    upsert?:
      | MinutesTemplateUpsertWithWhereUniqueWithoutUserInput
      | MinutesTemplateUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MinutesTemplateCreateManyUserInputEnvelope;
    set?: MinutesTemplateWhereUniqueInput | MinutesTemplateWhereUniqueInput[];
    disconnect?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
    delete?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
    connect?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
    update?:
      | MinutesTemplateUpdateWithWhereUniqueWithoutUserInput
      | MinutesTemplateUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MinutesTemplateUpdateManyWithWhereWithoutUserInput
      | MinutesTemplateUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | MinutesTemplateScalarWhereInput
      | MinutesTemplateScalarWhereInput[];
  };

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      NotificationPreferenceCreateWithoutUserInput,
      NotificationPreferenceUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput;
    upsert?: NotificationPreferenceUpsertWithoutUserInput;
    disconnect?: NotificationPreferenceWhereInput | boolean;
    delete?: NotificationPreferenceWhereInput | boolean;
    connect?: NotificationPreferenceWhereUniqueInput;
    update?: XOR<
      XOR<
        NotificationPreferenceUpdateToOneWithWhereWithoutUserInput,
        NotificationPreferenceUpdateWithoutUserInput
      >,
      NotificationPreferenceUncheckedUpdateWithoutUserInput
    >;
  };

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      SubscriptionCreateWithoutUserInput,
      SubscriptionUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput;
    upsert?: SubscriptionUpsertWithoutUserInput;
    disconnect?: SubscriptionWhereInput | boolean;
    delete?: SubscriptionWhereInput | boolean;
    connect?: SubscriptionWhereUniqueInput;
    update?: XOR<
      XOR<
        SubscriptionUpdateToOneWithWhereWithoutUserInput,
        SubscriptionUpdateWithoutUserInput
      >,
      SubscriptionUncheckedUpdateWithoutUserInput
    >;
  };

  export type TagUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>
      | TagCreateWithoutUserInput[]
      | TagUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TagCreateOrConnectWithoutUserInput
      | TagCreateOrConnectWithoutUserInput[];
    upsert?:
      | TagUpsertWithWhereUniqueWithoutUserInput
      | TagUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TagCreateManyUserInputEnvelope;
    set?: TagWhereUniqueInput | TagWhereUniqueInput[];
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[];
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[];
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[];
    update?:
      | TagUpdateWithWhereUniqueWithoutUserInput
      | TagUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TagUpdateManyWithWhereWithoutUserInput
      | TagUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[];
  };

  export type MembershipUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          MembershipCreateWithoutUserInput,
          MembershipUncheckedCreateWithoutUserInput
        >
      | MembershipCreateWithoutUserInput[]
      | MembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutUserInput
      | MembershipCreateOrConnectWithoutUserInput[];
    upsert?:
      | MembershipUpsertWithWhereUniqueWithoutUserInput
      | MembershipUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MembershipCreateManyUserInputEnvelope;
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    update?:
      | MembershipUpdateWithWhereUniqueWithoutUserInput
      | MembershipUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MembershipUpdateManyWithWhereWithoutUserInput
      | MembershipUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
  };

  export type MinutesUpdateManyWithoutReviewerNestedInput = {
    create?:
      | XOR<
          MinutesCreateWithoutReviewerInput,
          MinutesUncheckedCreateWithoutReviewerInput
        >
      | MinutesCreateWithoutReviewerInput[]
      | MinutesUncheckedCreateWithoutReviewerInput[];
    connectOrCreate?:
      | MinutesCreateOrConnectWithoutReviewerInput
      | MinutesCreateOrConnectWithoutReviewerInput[];
    upsert?:
      | MinutesUpsertWithWhereUniqueWithoutReviewerInput
      | MinutesUpsertWithWhereUniqueWithoutReviewerInput[];
    createMany?: MinutesCreateManyReviewerInputEnvelope;
    set?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
    disconnect?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
    delete?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
    connect?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
    update?:
      | MinutesUpdateWithWhereUniqueWithoutReviewerInput
      | MinutesUpdateWithWhereUniqueWithoutReviewerInput[];
    updateMany?:
      | MinutesUpdateManyWithWhereWithoutReviewerInput
      | MinutesUpdateManyWithWhereWithoutReviewerInput[];
    deleteMany?: MinutesScalarWhereInput | MinutesScalarWhereInput[];
  };

  export type CalendarConnectionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          CalendarConnectionCreateWithoutUserInput,
          CalendarConnectionUncheckedCreateWithoutUserInput
        >
      | CalendarConnectionCreateWithoutUserInput[]
      | CalendarConnectionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CalendarConnectionCreateOrConnectWithoutUserInput
      | CalendarConnectionCreateOrConnectWithoutUserInput[];
    upsert?:
      | CalendarConnectionUpsertWithWhereUniqueWithoutUserInput
      | CalendarConnectionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CalendarConnectionCreateManyUserInputEnvelope;
    set?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
    disconnect?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
    delete?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
    connect?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
    update?:
      | CalendarConnectionUpdateWithWhereUniqueWithoutUserInput
      | CalendarConnectionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CalendarConnectionUpdateManyWithWhereWithoutUserInput
      | CalendarConnectionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | CalendarConnectionScalarWhereInput
      | CalendarConnectionScalarWhereInput[];
  };

  export type MeetingUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          MeetingCreateWithoutUserInput,
          MeetingUncheckedCreateWithoutUserInput
        >
      | MeetingCreateWithoutUserInput[]
      | MeetingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutUserInput
      | MeetingCreateOrConnectWithoutUserInput[];
    upsert?:
      | MeetingUpsertWithWhereUniqueWithoutUserInput
      | MeetingUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MeetingCreateManyUserInputEnvelope;
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    update?:
      | MeetingUpdateWithWhereUniqueWithoutUserInput
      | MeetingUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MeetingUpdateManyWithWhereWithoutUserInput
      | MeetingUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[];
  };

  export type MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          MinutesTemplateCreateWithoutUserInput,
          MinutesTemplateUncheckedCreateWithoutUserInput
        >
      | MinutesTemplateCreateWithoutUserInput[]
      | MinutesTemplateUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MinutesTemplateCreateOrConnectWithoutUserInput
      | MinutesTemplateCreateOrConnectWithoutUserInput[];
    upsert?:
      | MinutesTemplateUpsertWithWhereUniqueWithoutUserInput
      | MinutesTemplateUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MinutesTemplateCreateManyUserInputEnvelope;
    set?: MinutesTemplateWhereUniqueInput | MinutesTemplateWhereUniqueInput[];
    disconnect?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
    delete?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
    connect?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
    update?:
      | MinutesTemplateUpdateWithWhereUniqueWithoutUserInput
      | MinutesTemplateUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MinutesTemplateUpdateManyWithWhereWithoutUserInput
      | MinutesTemplateUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | MinutesTemplateScalarWhereInput
      | MinutesTemplateScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      NotificationPreferenceCreateWithoutUserInput,
      NotificationPreferenceUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput;
    upsert?: NotificationPreferenceUpsertWithoutUserInput;
    disconnect?: NotificationPreferenceWhereInput | boolean;
    delete?: NotificationPreferenceWhereInput | boolean;
    connect?: NotificationPreferenceWhereUniqueInput;
    update?: XOR<
      XOR<
        NotificationPreferenceUpdateToOneWithWhereWithoutUserInput,
        NotificationPreferenceUpdateWithoutUserInput
      >,
      NotificationPreferenceUncheckedUpdateWithoutUserInput
    >;
  };

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      SubscriptionCreateWithoutUserInput,
      SubscriptionUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput;
    upsert?: SubscriptionUpsertWithoutUserInput;
    disconnect?: SubscriptionWhereInput | boolean;
    delete?: SubscriptionWhereInput | boolean;
    connect?: SubscriptionWhereUniqueInput;
    update?: XOR<
      XOR<
        SubscriptionUpdateToOneWithWhereWithoutUserInput,
        SubscriptionUpdateWithoutUserInput
      >,
      SubscriptionUncheckedUpdateWithoutUserInput
    >;
  };

  export type TagUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>
      | TagCreateWithoutUserInput[]
      | TagUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TagCreateOrConnectWithoutUserInput
      | TagCreateOrConnectWithoutUserInput[];
    upsert?:
      | TagUpsertWithWhereUniqueWithoutUserInput
      | TagUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TagCreateManyUserInputEnvelope;
    set?: TagWhereUniqueInput | TagWhereUniqueInput[];
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[];
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[];
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[];
    update?:
      | TagUpdateWithWhereUniqueWithoutUserInput
      | TagUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TagUpdateManyWithWhereWithoutUserInput
      | TagUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[];
  };

  export type MembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          MembershipCreateWithoutUserInput,
          MembershipUncheckedCreateWithoutUserInput
        >
      | MembershipCreateWithoutUserInput[]
      | MembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutUserInput
      | MembershipCreateOrConnectWithoutUserInput[];
    upsert?:
      | MembershipUpsertWithWhereUniqueWithoutUserInput
      | MembershipUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MembershipCreateManyUserInputEnvelope;
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    update?:
      | MembershipUpdateWithWhereUniqueWithoutUserInput
      | MembershipUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MembershipUpdateManyWithWhereWithoutUserInput
      | MembershipUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
  };

  export type MinutesUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?:
      | XOR<
          MinutesCreateWithoutReviewerInput,
          MinutesUncheckedCreateWithoutReviewerInput
        >
      | MinutesCreateWithoutReviewerInput[]
      | MinutesUncheckedCreateWithoutReviewerInput[];
    connectOrCreate?:
      | MinutesCreateOrConnectWithoutReviewerInput
      | MinutesCreateOrConnectWithoutReviewerInput[];
    upsert?:
      | MinutesUpsertWithWhereUniqueWithoutReviewerInput
      | MinutesUpsertWithWhereUniqueWithoutReviewerInput[];
    createMany?: MinutesCreateManyReviewerInputEnvelope;
    set?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
    disconnect?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
    delete?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
    connect?: MinutesWhereUniqueInput | MinutesWhereUniqueInput[];
    update?:
      | MinutesUpdateWithWhereUniqueWithoutReviewerInput
      | MinutesUpdateWithWhereUniqueWithoutReviewerInput[];
    updateMany?:
      | MinutesUpdateManyWithWhereWithoutReviewerInput
      | MinutesUpdateManyWithWhereWithoutReviewerInput[];
    deleteMany?: MinutesScalarWhereInput | MinutesScalarWhereInput[];
  };

  export type CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          CalendarConnectionCreateWithoutUserInput,
          CalendarConnectionUncheckedCreateWithoutUserInput
        >
      | CalendarConnectionCreateWithoutUserInput[]
      | CalendarConnectionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CalendarConnectionCreateOrConnectWithoutUserInput
      | CalendarConnectionCreateOrConnectWithoutUserInput[];
    upsert?:
      | CalendarConnectionUpsertWithWhereUniqueWithoutUserInput
      | CalendarConnectionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CalendarConnectionCreateManyUserInputEnvelope;
    set?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
    disconnect?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
    delete?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
    connect?:
      | CalendarConnectionWhereUniqueInput
      | CalendarConnectionWhereUniqueInput[];
    update?:
      | CalendarConnectionUpdateWithWhereUniqueWithoutUserInput
      | CalendarConnectionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CalendarConnectionUpdateManyWithWhereWithoutUserInput
      | CalendarConnectionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | CalendarConnectionScalarWhereInput
      | CalendarConnectionScalarWhereInput[];
  };

  export type MembershipCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          MembershipCreateWithoutOrganizationInput,
          MembershipUncheckedCreateWithoutOrganizationInput
        >
      | MembershipCreateWithoutOrganizationInput[]
      | MembershipUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutOrganizationInput
      | MembershipCreateOrConnectWithoutOrganizationInput[];
    createMany?: MembershipCreateManyOrganizationInputEnvelope;
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
  };

  export type MeetingCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          MeetingCreateWithoutOrganizationInput,
          MeetingUncheckedCreateWithoutOrganizationInput
        >
      | MeetingCreateWithoutOrganizationInput[]
      | MeetingUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutOrganizationInput
      | MeetingCreateOrConnectWithoutOrganizationInput[];
    createMany?: MeetingCreateManyOrganizationInputEnvelope;
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
  };

  export type MinutesTemplateCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          MinutesTemplateCreateWithoutOrganizationInput,
          MinutesTemplateUncheckedCreateWithoutOrganizationInput
        >
      | MinutesTemplateCreateWithoutOrganizationInput[]
      | MinutesTemplateUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MinutesTemplateCreateOrConnectWithoutOrganizationInput
      | MinutesTemplateCreateOrConnectWithoutOrganizationInput[];
    createMany?: MinutesTemplateCreateManyOrganizationInputEnvelope;
    connect?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
  };

  export type TagCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          TagCreateWithoutOrganizationInput,
          TagUncheckedCreateWithoutOrganizationInput
        >
      | TagCreateWithoutOrganizationInput[]
      | TagUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | TagCreateOrConnectWithoutOrganizationInput
      | TagCreateOrConnectWithoutOrganizationInput[];
    createMany?: TagCreateManyOrganizationInputEnvelope;
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[];
  };

  export type MembershipUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          MembershipCreateWithoutOrganizationInput,
          MembershipUncheckedCreateWithoutOrganizationInput
        >
      | MembershipCreateWithoutOrganizationInput[]
      | MembershipUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutOrganizationInput
      | MembershipCreateOrConnectWithoutOrganizationInput[];
    createMany?: MembershipCreateManyOrganizationInputEnvelope;
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
  };

  export type MeetingUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          MeetingCreateWithoutOrganizationInput,
          MeetingUncheckedCreateWithoutOrganizationInput
        >
      | MeetingCreateWithoutOrganizationInput[]
      | MeetingUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutOrganizationInput
      | MeetingCreateOrConnectWithoutOrganizationInput[];
    createMany?: MeetingCreateManyOrganizationInputEnvelope;
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
  };

  export type MinutesTemplateUncheckedCreateNestedManyWithoutOrganizationInput =
    {
      create?:
        | XOR<
            MinutesTemplateCreateWithoutOrganizationInput,
            MinutesTemplateUncheckedCreateWithoutOrganizationInput
          >
        | MinutesTemplateCreateWithoutOrganizationInput[]
        | MinutesTemplateUncheckedCreateWithoutOrganizationInput[];
      connectOrCreate?:
        | MinutesTemplateCreateOrConnectWithoutOrganizationInput
        | MinutesTemplateCreateOrConnectWithoutOrganizationInput[];
      createMany?: MinutesTemplateCreateManyOrganizationInputEnvelope;
      connect?:
        | MinutesTemplateWhereUniqueInput
        | MinutesTemplateWhereUniqueInput[];
    };

  export type TagUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          TagCreateWithoutOrganizationInput,
          TagUncheckedCreateWithoutOrganizationInput
        >
      | TagCreateWithoutOrganizationInput[]
      | TagUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | TagCreateOrConnectWithoutOrganizationInput
      | TagCreateOrConnectWithoutOrganizationInput[];
    createMany?: TagCreateManyOrganizationInputEnvelope;
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[];
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type MembershipUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          MembershipCreateWithoutOrganizationInput,
          MembershipUncheckedCreateWithoutOrganizationInput
        >
      | MembershipCreateWithoutOrganizationInput[]
      | MembershipUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutOrganizationInput
      | MembershipCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | MembershipUpsertWithWhereUniqueWithoutOrganizationInput
      | MembershipUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: MembershipCreateManyOrganizationInputEnvelope;
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    update?:
      | MembershipUpdateWithWhereUniqueWithoutOrganizationInput
      | MembershipUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | MembershipUpdateManyWithWhereWithoutOrganizationInput
      | MembershipUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
  };

  export type MeetingUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          MeetingCreateWithoutOrganizationInput,
          MeetingUncheckedCreateWithoutOrganizationInput
        >
      | MeetingCreateWithoutOrganizationInput[]
      | MeetingUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutOrganizationInput
      | MeetingCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | MeetingUpsertWithWhereUniqueWithoutOrganizationInput
      | MeetingUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: MeetingCreateManyOrganizationInputEnvelope;
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    update?:
      | MeetingUpdateWithWhereUniqueWithoutOrganizationInput
      | MeetingUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | MeetingUpdateManyWithWhereWithoutOrganizationInput
      | MeetingUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[];
  };

  export type MinutesTemplateUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          MinutesTemplateCreateWithoutOrganizationInput,
          MinutesTemplateUncheckedCreateWithoutOrganizationInput
        >
      | MinutesTemplateCreateWithoutOrganizationInput[]
      | MinutesTemplateUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MinutesTemplateCreateOrConnectWithoutOrganizationInput
      | MinutesTemplateCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | MinutesTemplateUpsertWithWhereUniqueWithoutOrganizationInput
      | MinutesTemplateUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: MinutesTemplateCreateManyOrganizationInputEnvelope;
    set?: MinutesTemplateWhereUniqueInput | MinutesTemplateWhereUniqueInput[];
    disconnect?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
    delete?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
    connect?:
      | MinutesTemplateWhereUniqueInput
      | MinutesTemplateWhereUniqueInput[];
    update?:
      | MinutesTemplateUpdateWithWhereUniqueWithoutOrganizationInput
      | MinutesTemplateUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | MinutesTemplateUpdateManyWithWhereWithoutOrganizationInput
      | MinutesTemplateUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?:
      | MinutesTemplateScalarWhereInput
      | MinutesTemplateScalarWhereInput[];
  };

  export type TagUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          TagCreateWithoutOrganizationInput,
          TagUncheckedCreateWithoutOrganizationInput
        >
      | TagCreateWithoutOrganizationInput[]
      | TagUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | TagCreateOrConnectWithoutOrganizationInput
      | TagCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | TagUpsertWithWhereUniqueWithoutOrganizationInput
      | TagUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: TagCreateManyOrganizationInputEnvelope;
    set?: TagWhereUniqueInput | TagWhereUniqueInput[];
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[];
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[];
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[];
    update?:
      | TagUpdateWithWhereUniqueWithoutOrganizationInput
      | TagUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | TagUpdateManyWithWhereWithoutOrganizationInput
      | TagUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[];
  };

  export type MembershipUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          MembershipCreateWithoutOrganizationInput,
          MembershipUncheckedCreateWithoutOrganizationInput
        >
      | MembershipCreateWithoutOrganizationInput[]
      | MembershipUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutOrganizationInput
      | MembershipCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | MembershipUpsertWithWhereUniqueWithoutOrganizationInput
      | MembershipUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: MembershipCreateManyOrganizationInputEnvelope;
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    update?:
      | MembershipUpdateWithWhereUniqueWithoutOrganizationInput
      | MembershipUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | MembershipUpdateManyWithWhereWithoutOrganizationInput
      | MembershipUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
  };

  export type MeetingUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          MeetingCreateWithoutOrganizationInput,
          MeetingUncheckedCreateWithoutOrganizationInput
        >
      | MeetingCreateWithoutOrganizationInput[]
      | MeetingUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutOrganizationInput
      | MeetingCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | MeetingUpsertWithWhereUniqueWithoutOrganizationInput
      | MeetingUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: MeetingCreateManyOrganizationInputEnvelope;
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    update?:
      | MeetingUpdateWithWhereUniqueWithoutOrganizationInput
      | MeetingUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | MeetingUpdateManyWithWhereWithoutOrganizationInput
      | MeetingUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[];
  };

  export type MinutesTemplateUncheckedUpdateManyWithoutOrganizationNestedInput =
    {
      create?:
        | XOR<
            MinutesTemplateCreateWithoutOrganizationInput,
            MinutesTemplateUncheckedCreateWithoutOrganizationInput
          >
        | MinutesTemplateCreateWithoutOrganizationInput[]
        | MinutesTemplateUncheckedCreateWithoutOrganizationInput[];
      connectOrCreate?:
        | MinutesTemplateCreateOrConnectWithoutOrganizationInput
        | MinutesTemplateCreateOrConnectWithoutOrganizationInput[];
      upsert?:
        | MinutesTemplateUpsertWithWhereUniqueWithoutOrganizationInput
        | MinutesTemplateUpsertWithWhereUniqueWithoutOrganizationInput[];
      createMany?: MinutesTemplateCreateManyOrganizationInputEnvelope;
      set?: MinutesTemplateWhereUniqueInput | MinutesTemplateWhereUniqueInput[];
      disconnect?:
        | MinutesTemplateWhereUniqueInput
        | MinutesTemplateWhereUniqueInput[];
      delete?:
        | MinutesTemplateWhereUniqueInput
        | MinutesTemplateWhereUniqueInput[];
      connect?:
        | MinutesTemplateWhereUniqueInput
        | MinutesTemplateWhereUniqueInput[];
      update?:
        | MinutesTemplateUpdateWithWhereUniqueWithoutOrganizationInput
        | MinutesTemplateUpdateWithWhereUniqueWithoutOrganizationInput[];
      updateMany?:
        | MinutesTemplateUpdateManyWithWhereWithoutOrganizationInput
        | MinutesTemplateUpdateManyWithWhereWithoutOrganizationInput[];
      deleteMany?:
        | MinutesTemplateScalarWhereInput
        | MinutesTemplateScalarWhereInput[];
    };

  export type TagUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          TagCreateWithoutOrganizationInput,
          TagUncheckedCreateWithoutOrganizationInput
        >
      | TagCreateWithoutOrganizationInput[]
      | TagUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | TagCreateOrConnectWithoutOrganizationInput
      | TagCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | TagUpsertWithWhereUniqueWithoutOrganizationInput
      | TagUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: TagCreateManyOrganizationInputEnvelope;
    set?: TagWhereUniqueInput | TagWhereUniqueInput[];
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[];
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[];
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[];
    update?:
      | TagUpdateWithWhereUniqueWithoutOrganizationInput
      | TagUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | TagUpdateManyWithWhereWithoutOrganizationInput
      | TagUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<
      UserCreateWithoutMembershipsInput,
      UserUncheckedCreateWithoutMembershipsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<
      OrganizationCreateWithoutMembersInput,
      OrganizationUncheckedCreateWithoutMembersInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type EnumMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.MemberRole;
  };

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<
      UserCreateWithoutMembershipsInput,
      UserUncheckedCreateWithoutMembershipsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput;
    upsert?: UserUpsertWithoutMembershipsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutMembershipsInput,
        UserUpdateWithoutMembershipsInput
      >,
      UserUncheckedUpdateWithoutMembershipsInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutMembersInput,
      OrganizationUncheckedCreateWithoutMembersInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput;
    upsert?: OrganizationUpsertWithoutMembersInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutMembersInput,
        OrganizationUpdateWithoutMembersInput
      >,
      OrganizationUncheckedUpdateWithoutMembersInput
    >;
  };

  export type UserCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<
      UserCreateWithoutTemplatesInput,
      UserUncheckedCreateWithoutTemplatesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTemplatesInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<
      OrganizationCreateWithoutTemplatesInput,
      OrganizationUncheckedCreateWithoutTemplatesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutTemplatesInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<
      UserCreateWithoutTemplatesInput,
      UserUncheckedCreateWithoutTemplatesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTemplatesInput;
    upsert?: UserUpsertWithoutTemplatesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTemplatesInput,
        UserUpdateWithoutTemplatesInput
      >,
      UserUncheckedUpdateWithoutTemplatesInput
    >;
  };

  export type OrganizationUpdateOneWithoutTemplatesNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutTemplatesInput,
      OrganizationUncheckedCreateWithoutTemplatesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutTemplatesInput;
    upsert?: OrganizationUpsertWithoutTemplatesInput;
    disconnect?: OrganizationWhereInput | boolean;
    delete?: OrganizationWhereInput | boolean;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutTemplatesInput,
        OrganizationUpdateWithoutTemplatesInput
      >,
      OrganizationUncheckedUpdateWithoutTemplatesInput
    >;
  };

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?:
      | XOR<
          SubscriptionCreateWithoutPlanInput,
          SubscriptionUncheckedCreateWithoutPlanInput
        >
      | SubscriptionCreateWithoutPlanInput[]
      | SubscriptionUncheckedCreateWithoutPlanInput[];
    connectOrCreate?:
      | SubscriptionCreateOrConnectWithoutPlanInput
      | SubscriptionCreateOrConnectWithoutPlanInput[];
    createMany?: SubscriptionCreateManyPlanInputEnvelope;
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
  };

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?:
      | XOR<
          SubscriptionCreateWithoutPlanInput,
          SubscriptionUncheckedCreateWithoutPlanInput
        >
      | SubscriptionCreateWithoutPlanInput[]
      | SubscriptionUncheckedCreateWithoutPlanInput[];
    connectOrCreate?:
      | SubscriptionCreateOrConnectWithoutPlanInput
      | SubscriptionCreateOrConnectWithoutPlanInput[];
    createMany?: SubscriptionCreateManyPlanInputEnvelope;
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?:
      | XOR<
          SubscriptionCreateWithoutPlanInput,
          SubscriptionUncheckedCreateWithoutPlanInput
        >
      | SubscriptionCreateWithoutPlanInput[]
      | SubscriptionUncheckedCreateWithoutPlanInput[];
    connectOrCreate?:
      | SubscriptionCreateOrConnectWithoutPlanInput
      | SubscriptionCreateOrConnectWithoutPlanInput[];
    upsert?:
      | SubscriptionUpsertWithWhereUniqueWithoutPlanInput
      | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[];
    createMany?: SubscriptionCreateManyPlanInputEnvelope;
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
    update?:
      | SubscriptionUpdateWithWhereUniqueWithoutPlanInput
      | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[];
    updateMany?:
      | SubscriptionUpdateManyWithWhereWithoutPlanInput
      | SubscriptionUpdateManyWithWhereWithoutPlanInput[];
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[];
  };

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?:
      | XOR<
          SubscriptionCreateWithoutPlanInput,
          SubscriptionUncheckedCreateWithoutPlanInput
        >
      | SubscriptionCreateWithoutPlanInput[]
      | SubscriptionUncheckedCreateWithoutPlanInput[];
    connectOrCreate?:
      | SubscriptionCreateOrConnectWithoutPlanInput
      | SubscriptionCreateOrConnectWithoutPlanInput[];
    upsert?:
      | SubscriptionUpsertWithWhereUniqueWithoutPlanInput
      | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[];
    createMany?: SubscriptionCreateManyPlanInputEnvelope;
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[];
    update?:
      | SubscriptionUpdateWithWhereUniqueWithoutPlanInput
      | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[];
    updateMany?:
      | SubscriptionUpdateManyWithWhereWithoutPlanInput
      | SubscriptionUpdateManyWithWhereWithoutPlanInput[];
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[];
  };

  export type PlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<
      PlanCreateWithoutSubscriptionsInput,
      PlanUncheckedCreateWithoutSubscriptionsInput
    >;
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput;
    connect?: PlanWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<
      UserCreateWithoutSubscriptionInput,
      UserUncheckedCreateWithoutSubscriptionInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput;
    connect?: UserWhereUniqueInput;
  };

  export type WeeklyUsageCreateNestedManyWithoutSubscriptionInput = {
    create?:
      | XOR<
          WeeklyUsageCreateWithoutSubscriptionInput,
          WeeklyUsageUncheckedCreateWithoutSubscriptionInput
        >
      | WeeklyUsageCreateWithoutSubscriptionInput[]
      | WeeklyUsageUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | WeeklyUsageCreateOrConnectWithoutSubscriptionInput
      | WeeklyUsageCreateOrConnectWithoutSubscriptionInput[];
    createMany?: WeeklyUsageCreateManySubscriptionInputEnvelope;
    connect?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
  };

  export type WeeklyUsageUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?:
      | XOR<
          WeeklyUsageCreateWithoutSubscriptionInput,
          WeeklyUsageUncheckedCreateWithoutSubscriptionInput
        >
      | WeeklyUsageCreateWithoutSubscriptionInput[]
      | WeeklyUsageUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | WeeklyUsageCreateOrConnectWithoutSubscriptionInput
      | WeeklyUsageCreateOrConnectWithoutSubscriptionInput[];
    createMany?: WeeklyUsageCreateManySubscriptionInputEnvelope;
    connect?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type PlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<
      PlanCreateWithoutSubscriptionsInput,
      PlanUncheckedCreateWithoutSubscriptionsInput
    >;
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput;
    upsert?: PlanUpsertWithoutSubscriptionsInput;
    connect?: PlanWhereUniqueInput;
    update?: XOR<
      XOR<
        PlanUpdateToOneWithWhereWithoutSubscriptionsInput,
        PlanUpdateWithoutSubscriptionsInput
      >,
      PlanUncheckedUpdateWithoutSubscriptionsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<
      UserCreateWithoutSubscriptionInput,
      UserUncheckedCreateWithoutSubscriptionInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput;
    upsert?: UserUpsertWithoutSubscriptionInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSubscriptionInput,
        UserUpdateWithoutSubscriptionInput
      >,
      UserUncheckedUpdateWithoutSubscriptionInput
    >;
  };

  export type WeeklyUsageUpdateManyWithoutSubscriptionNestedInput = {
    create?:
      | XOR<
          WeeklyUsageCreateWithoutSubscriptionInput,
          WeeklyUsageUncheckedCreateWithoutSubscriptionInput
        >
      | WeeklyUsageCreateWithoutSubscriptionInput[]
      | WeeklyUsageUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | WeeklyUsageCreateOrConnectWithoutSubscriptionInput
      | WeeklyUsageCreateOrConnectWithoutSubscriptionInput[];
    upsert?:
      | WeeklyUsageUpsertWithWhereUniqueWithoutSubscriptionInput
      | WeeklyUsageUpsertWithWhereUniqueWithoutSubscriptionInput[];
    createMany?: WeeklyUsageCreateManySubscriptionInputEnvelope;
    set?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
    disconnect?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
    delete?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
    connect?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
    update?:
      | WeeklyUsageUpdateWithWhereUniqueWithoutSubscriptionInput
      | WeeklyUsageUpdateWithWhereUniqueWithoutSubscriptionInput[];
    updateMany?:
      | WeeklyUsageUpdateManyWithWhereWithoutSubscriptionInput
      | WeeklyUsageUpdateManyWithWhereWithoutSubscriptionInput[];
    deleteMany?: WeeklyUsageScalarWhereInput | WeeklyUsageScalarWhereInput[];
  };

  export type WeeklyUsageUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?:
      | XOR<
          WeeklyUsageCreateWithoutSubscriptionInput,
          WeeklyUsageUncheckedCreateWithoutSubscriptionInput
        >
      | WeeklyUsageCreateWithoutSubscriptionInput[]
      | WeeklyUsageUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | WeeklyUsageCreateOrConnectWithoutSubscriptionInput
      | WeeklyUsageCreateOrConnectWithoutSubscriptionInput[];
    upsert?:
      | WeeklyUsageUpsertWithWhereUniqueWithoutSubscriptionInput
      | WeeklyUsageUpsertWithWhereUniqueWithoutSubscriptionInput[];
    createMany?: WeeklyUsageCreateManySubscriptionInputEnvelope;
    set?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
    disconnect?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
    delete?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
    connect?: WeeklyUsageWhereUniqueInput | WeeklyUsageWhereUniqueInput[];
    update?:
      | WeeklyUsageUpdateWithWhereUniqueWithoutSubscriptionInput
      | WeeklyUsageUpdateWithWhereUniqueWithoutSubscriptionInput[];
    updateMany?:
      | WeeklyUsageUpdateManyWithWhereWithoutSubscriptionInput
      | WeeklyUsageUpdateManyWithWhereWithoutSubscriptionInput[];
    deleteMany?: WeeklyUsageScalarWhereInput | WeeklyUsageScalarWhereInput[];
  };

  export type SubscriptionCreateNestedOneWithoutUsageInput = {
    create?: XOR<
      SubscriptionCreateWithoutUsageInput,
      SubscriptionUncheckedCreateWithoutUsageInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageInput;
    connect?: SubscriptionWhereUniqueInput;
  };

  export type SubscriptionUpdateOneRequiredWithoutUsageNestedInput = {
    create?: XOR<
      SubscriptionCreateWithoutUsageInput,
      SubscriptionUncheckedCreateWithoutUsageInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageInput;
    upsert?: SubscriptionUpsertWithoutUsageInput;
    connect?: SubscriptionWhereUniqueInput;
    update?: XOR<
      XOR<
        SubscriptionUpdateToOneWithWhereWithoutUsageInput,
        SubscriptionUpdateWithoutUsageInput
      >,
      SubscriptionUncheckedUpdateWithoutUsageInput
    >;
  };

  export type KeyMomentCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          KeyMomentCreateWithoutMeetingInput,
          KeyMomentUncheckedCreateWithoutMeetingInput
        >
      | KeyMomentCreateWithoutMeetingInput[]
      | KeyMomentUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | KeyMomentCreateOrConnectWithoutMeetingInput
      | KeyMomentCreateOrConnectWithoutMeetingInput[];
    createMany?: KeyMomentCreateManyMeetingInputEnvelope;
    connect?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<
      UserCreateWithoutMeetingsInput,
      UserUncheckedCreateWithoutMeetingsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<
      OrganizationCreateWithoutMeetingsInput,
      OrganizationUncheckedCreateWithoutMeetingsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMeetingsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type CalendarConnectionCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<
      CalendarConnectionCreateWithoutMeetingsInput,
      CalendarConnectionUncheckedCreateWithoutMeetingsInput
    >;
    connectOrCreate?: CalendarConnectionCreateOrConnectWithoutMeetingsInput;
    connect?: CalendarConnectionWhereUniqueInput;
  };

  export type MeetingTagCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          MeetingTagCreateWithoutMeetingInput,
          MeetingTagUncheckedCreateWithoutMeetingInput
        >
      | MeetingTagCreateWithoutMeetingInput[]
      | MeetingTagUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | MeetingTagCreateOrConnectWithoutMeetingInput
      | MeetingTagCreateOrConnectWithoutMeetingInput[];
    createMany?: MeetingTagCreateManyMeetingInputEnvelope;
    connect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
  };

  export type MinutesCreateNestedOneWithoutMeetingInput = {
    create?: XOR<
      MinutesCreateWithoutMeetingInput,
      MinutesUncheckedCreateWithoutMeetingInput
    >;
    connectOrCreate?: MinutesCreateOrConnectWithoutMeetingInput;
    connect?: MinutesWhereUniqueInput;
  };

  export type ShareLinkCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          ShareLinkCreateWithoutMeetingInput,
          ShareLinkUncheckedCreateWithoutMeetingInput
        >
      | ShareLinkCreateWithoutMeetingInput[]
      | ShareLinkUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | ShareLinkCreateOrConnectWithoutMeetingInput
      | ShareLinkCreateOrConnectWithoutMeetingInput[];
    createMany?: ShareLinkCreateManyMeetingInputEnvelope;
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
  };

  export type SpeakerCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          SpeakerCreateWithoutMeetingInput,
          SpeakerUncheckedCreateWithoutMeetingInput
        >
      | SpeakerCreateWithoutMeetingInput[]
      | SpeakerUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | SpeakerCreateOrConnectWithoutMeetingInput
      | SpeakerCreateOrConnectWithoutMeetingInput[];
    createMany?: SpeakerCreateManyMeetingInputEnvelope;
    connect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
  };

  export type TranscriptSegmentCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          TranscriptSegmentCreateWithoutMeetingInput,
          TranscriptSegmentUncheckedCreateWithoutMeetingInput
        >
      | TranscriptSegmentCreateWithoutMeetingInput[]
      | TranscriptSegmentUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | TranscriptSegmentCreateOrConnectWithoutMeetingInput
      | TranscriptSegmentCreateOrConnectWithoutMeetingInput[];
    createMany?: TranscriptSegmentCreateManyMeetingInputEnvelope;
    connect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
  };

  export type KeyMomentUncheckedCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          KeyMomentCreateWithoutMeetingInput,
          KeyMomentUncheckedCreateWithoutMeetingInput
        >
      | KeyMomentCreateWithoutMeetingInput[]
      | KeyMomentUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | KeyMomentCreateOrConnectWithoutMeetingInput
      | KeyMomentCreateOrConnectWithoutMeetingInput[];
    createMany?: KeyMomentCreateManyMeetingInputEnvelope;
    connect?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
  };

  export type MeetingTagUncheckedCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          MeetingTagCreateWithoutMeetingInput,
          MeetingTagUncheckedCreateWithoutMeetingInput
        >
      | MeetingTagCreateWithoutMeetingInput[]
      | MeetingTagUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | MeetingTagCreateOrConnectWithoutMeetingInput
      | MeetingTagCreateOrConnectWithoutMeetingInput[];
    createMany?: MeetingTagCreateManyMeetingInputEnvelope;
    connect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
  };

  export type MinutesUncheckedCreateNestedOneWithoutMeetingInput = {
    create?: XOR<
      MinutesCreateWithoutMeetingInput,
      MinutesUncheckedCreateWithoutMeetingInput
    >;
    connectOrCreate?: MinutesCreateOrConnectWithoutMeetingInput;
    connect?: MinutesWhereUniqueInput;
  };

  export type ShareLinkUncheckedCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          ShareLinkCreateWithoutMeetingInput,
          ShareLinkUncheckedCreateWithoutMeetingInput
        >
      | ShareLinkCreateWithoutMeetingInput[]
      | ShareLinkUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | ShareLinkCreateOrConnectWithoutMeetingInput
      | ShareLinkCreateOrConnectWithoutMeetingInput[];
    createMany?: ShareLinkCreateManyMeetingInputEnvelope;
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
  };

  export type SpeakerUncheckedCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          SpeakerCreateWithoutMeetingInput,
          SpeakerUncheckedCreateWithoutMeetingInput
        >
      | SpeakerCreateWithoutMeetingInput[]
      | SpeakerUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | SpeakerCreateOrConnectWithoutMeetingInput
      | SpeakerCreateOrConnectWithoutMeetingInput[];
    createMany?: SpeakerCreateManyMeetingInputEnvelope;
    connect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
  };

  export type TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput = {
    create?:
      | XOR<
          TranscriptSegmentCreateWithoutMeetingInput,
          TranscriptSegmentUncheckedCreateWithoutMeetingInput
        >
      | TranscriptSegmentCreateWithoutMeetingInput[]
      | TranscriptSegmentUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | TranscriptSegmentCreateOrConnectWithoutMeetingInput
      | TranscriptSegmentCreateOrConnectWithoutMeetingInput[];
    createMany?: TranscriptSegmentCreateManyMeetingInputEnvelope;
    connect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
  };

  export type EnumMeetingStatusFieldUpdateOperationsInput = {
    set?: $Enums.MeetingStatus;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type KeyMomentUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          KeyMomentCreateWithoutMeetingInput,
          KeyMomentUncheckedCreateWithoutMeetingInput
        >
      | KeyMomentCreateWithoutMeetingInput[]
      | KeyMomentUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | KeyMomentCreateOrConnectWithoutMeetingInput
      | KeyMomentCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | KeyMomentUpsertWithWhereUniqueWithoutMeetingInput
      | KeyMomentUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: KeyMomentCreateManyMeetingInputEnvelope;
    set?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
    disconnect?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
    delete?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
    connect?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
    update?:
      | KeyMomentUpdateWithWhereUniqueWithoutMeetingInput
      | KeyMomentUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | KeyMomentUpdateManyWithWhereWithoutMeetingInput
      | KeyMomentUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?: KeyMomentScalarWhereInput | KeyMomentScalarWhereInput[];
  };

  export type UserUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<
      UserCreateWithoutMeetingsInput,
      UserUncheckedCreateWithoutMeetingsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsInput;
    upsert?: UserUpsertWithoutMeetingsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutMeetingsInput,
        UserUpdateWithoutMeetingsInput
      >,
      UserUncheckedUpdateWithoutMeetingsInput
    >;
  };

  export type OrganizationUpdateOneWithoutMeetingsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutMeetingsInput,
      OrganizationUncheckedCreateWithoutMeetingsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMeetingsInput;
    upsert?: OrganizationUpsertWithoutMeetingsInput;
    disconnect?: OrganizationWhereInput | boolean;
    delete?: OrganizationWhereInput | boolean;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutMeetingsInput,
        OrganizationUpdateWithoutMeetingsInput
      >,
      OrganizationUncheckedUpdateWithoutMeetingsInput
    >;
  };

  export type CalendarConnectionUpdateOneWithoutMeetingsNestedInput = {
    create?: XOR<
      CalendarConnectionCreateWithoutMeetingsInput,
      CalendarConnectionUncheckedCreateWithoutMeetingsInput
    >;
    connectOrCreate?: CalendarConnectionCreateOrConnectWithoutMeetingsInput;
    upsert?: CalendarConnectionUpsertWithoutMeetingsInput;
    disconnect?: CalendarConnectionWhereInput | boolean;
    delete?: CalendarConnectionWhereInput | boolean;
    connect?: CalendarConnectionWhereUniqueInput;
    update?: XOR<
      XOR<
        CalendarConnectionUpdateToOneWithWhereWithoutMeetingsInput,
        CalendarConnectionUpdateWithoutMeetingsInput
      >,
      CalendarConnectionUncheckedUpdateWithoutMeetingsInput
    >;
  };

  export type MeetingTagUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          MeetingTagCreateWithoutMeetingInput,
          MeetingTagUncheckedCreateWithoutMeetingInput
        >
      | MeetingTagCreateWithoutMeetingInput[]
      | MeetingTagUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | MeetingTagCreateOrConnectWithoutMeetingInput
      | MeetingTagCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | MeetingTagUpsertWithWhereUniqueWithoutMeetingInput
      | MeetingTagUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: MeetingTagCreateManyMeetingInputEnvelope;
    set?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    disconnect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    delete?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    connect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    update?:
      | MeetingTagUpdateWithWhereUniqueWithoutMeetingInput
      | MeetingTagUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | MeetingTagUpdateManyWithWhereWithoutMeetingInput
      | MeetingTagUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?: MeetingTagScalarWhereInput | MeetingTagScalarWhereInput[];
  };

  export type MinutesUpdateOneWithoutMeetingNestedInput = {
    create?: XOR<
      MinutesCreateWithoutMeetingInput,
      MinutesUncheckedCreateWithoutMeetingInput
    >;
    connectOrCreate?: MinutesCreateOrConnectWithoutMeetingInput;
    upsert?: MinutesUpsertWithoutMeetingInput;
    disconnect?: MinutesWhereInput | boolean;
    delete?: MinutesWhereInput | boolean;
    connect?: MinutesWhereUniqueInput;
    update?: XOR<
      XOR<
        MinutesUpdateToOneWithWhereWithoutMeetingInput,
        MinutesUpdateWithoutMeetingInput
      >,
      MinutesUncheckedUpdateWithoutMeetingInput
    >;
  };

  export type ShareLinkUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          ShareLinkCreateWithoutMeetingInput,
          ShareLinkUncheckedCreateWithoutMeetingInput
        >
      | ShareLinkCreateWithoutMeetingInput[]
      | ShareLinkUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | ShareLinkCreateOrConnectWithoutMeetingInput
      | ShareLinkCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | ShareLinkUpsertWithWhereUniqueWithoutMeetingInput
      | ShareLinkUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: ShareLinkCreateManyMeetingInputEnvelope;
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
    update?:
      | ShareLinkUpdateWithWhereUniqueWithoutMeetingInput
      | ShareLinkUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | ShareLinkUpdateManyWithWhereWithoutMeetingInput
      | ShareLinkUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[];
  };

  export type SpeakerUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          SpeakerCreateWithoutMeetingInput,
          SpeakerUncheckedCreateWithoutMeetingInput
        >
      | SpeakerCreateWithoutMeetingInput[]
      | SpeakerUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | SpeakerCreateOrConnectWithoutMeetingInput
      | SpeakerCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | SpeakerUpsertWithWhereUniqueWithoutMeetingInput
      | SpeakerUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: SpeakerCreateManyMeetingInputEnvelope;
    set?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
    disconnect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
    delete?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
    connect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
    update?:
      | SpeakerUpdateWithWhereUniqueWithoutMeetingInput
      | SpeakerUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | SpeakerUpdateManyWithWhereWithoutMeetingInput
      | SpeakerUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?: SpeakerScalarWhereInput | SpeakerScalarWhereInput[];
  };

  export type TranscriptSegmentUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          TranscriptSegmentCreateWithoutMeetingInput,
          TranscriptSegmentUncheckedCreateWithoutMeetingInput
        >
      | TranscriptSegmentCreateWithoutMeetingInput[]
      | TranscriptSegmentUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | TranscriptSegmentCreateOrConnectWithoutMeetingInput
      | TranscriptSegmentCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | TranscriptSegmentUpsertWithWhereUniqueWithoutMeetingInput
      | TranscriptSegmentUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: TranscriptSegmentCreateManyMeetingInputEnvelope;
    set?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    disconnect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    delete?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    connect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    update?:
      | TranscriptSegmentUpdateWithWhereUniqueWithoutMeetingInput
      | TranscriptSegmentUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | TranscriptSegmentUpdateManyWithWhereWithoutMeetingInput
      | TranscriptSegmentUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?:
      | TranscriptSegmentScalarWhereInput
      | TranscriptSegmentScalarWhereInput[];
  };

  export type KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          KeyMomentCreateWithoutMeetingInput,
          KeyMomentUncheckedCreateWithoutMeetingInput
        >
      | KeyMomentCreateWithoutMeetingInput[]
      | KeyMomentUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | KeyMomentCreateOrConnectWithoutMeetingInput
      | KeyMomentCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | KeyMomentUpsertWithWhereUniqueWithoutMeetingInput
      | KeyMomentUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: KeyMomentCreateManyMeetingInputEnvelope;
    set?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
    disconnect?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
    delete?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
    connect?: KeyMomentWhereUniqueInput | KeyMomentWhereUniqueInput[];
    update?:
      | KeyMomentUpdateWithWhereUniqueWithoutMeetingInput
      | KeyMomentUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | KeyMomentUpdateManyWithWhereWithoutMeetingInput
      | KeyMomentUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?: KeyMomentScalarWhereInput | KeyMomentScalarWhereInput[];
  };

  export type MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          MeetingTagCreateWithoutMeetingInput,
          MeetingTagUncheckedCreateWithoutMeetingInput
        >
      | MeetingTagCreateWithoutMeetingInput[]
      | MeetingTagUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | MeetingTagCreateOrConnectWithoutMeetingInput
      | MeetingTagCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | MeetingTagUpsertWithWhereUniqueWithoutMeetingInput
      | MeetingTagUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: MeetingTagCreateManyMeetingInputEnvelope;
    set?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    disconnect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    delete?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    connect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    update?:
      | MeetingTagUpdateWithWhereUniqueWithoutMeetingInput
      | MeetingTagUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | MeetingTagUpdateManyWithWhereWithoutMeetingInput
      | MeetingTagUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?: MeetingTagScalarWhereInput | MeetingTagScalarWhereInput[];
  };

  export type MinutesUncheckedUpdateOneWithoutMeetingNestedInput = {
    create?: XOR<
      MinutesCreateWithoutMeetingInput,
      MinutesUncheckedCreateWithoutMeetingInput
    >;
    connectOrCreate?: MinutesCreateOrConnectWithoutMeetingInput;
    upsert?: MinutesUpsertWithoutMeetingInput;
    disconnect?: MinutesWhereInput | boolean;
    delete?: MinutesWhereInput | boolean;
    connect?: MinutesWhereUniqueInput;
    update?: XOR<
      XOR<
        MinutesUpdateToOneWithWhereWithoutMeetingInput,
        MinutesUpdateWithoutMeetingInput
      >,
      MinutesUncheckedUpdateWithoutMeetingInput
    >;
  };

  export type ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          ShareLinkCreateWithoutMeetingInput,
          ShareLinkUncheckedCreateWithoutMeetingInput
        >
      | ShareLinkCreateWithoutMeetingInput[]
      | ShareLinkUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | ShareLinkCreateOrConnectWithoutMeetingInput
      | ShareLinkCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | ShareLinkUpsertWithWhereUniqueWithoutMeetingInput
      | ShareLinkUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: ShareLinkCreateManyMeetingInputEnvelope;
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[];
    update?:
      | ShareLinkUpdateWithWhereUniqueWithoutMeetingInput
      | ShareLinkUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | ShareLinkUpdateManyWithWhereWithoutMeetingInput
      | ShareLinkUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[];
  };

  export type SpeakerUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          SpeakerCreateWithoutMeetingInput,
          SpeakerUncheckedCreateWithoutMeetingInput
        >
      | SpeakerCreateWithoutMeetingInput[]
      | SpeakerUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | SpeakerCreateOrConnectWithoutMeetingInput
      | SpeakerCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | SpeakerUpsertWithWhereUniqueWithoutMeetingInput
      | SpeakerUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: SpeakerCreateManyMeetingInputEnvelope;
    set?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
    disconnect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
    delete?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
    connect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[];
    update?:
      | SpeakerUpdateWithWhereUniqueWithoutMeetingInput
      | SpeakerUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | SpeakerUpdateManyWithWhereWithoutMeetingInput
      | SpeakerUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?: SpeakerScalarWhereInput | SpeakerScalarWhereInput[];
  };

  export type TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?:
      | XOR<
          TranscriptSegmentCreateWithoutMeetingInput,
          TranscriptSegmentUncheckedCreateWithoutMeetingInput
        >
      | TranscriptSegmentCreateWithoutMeetingInput[]
      | TranscriptSegmentUncheckedCreateWithoutMeetingInput[];
    connectOrCreate?:
      | TranscriptSegmentCreateOrConnectWithoutMeetingInput
      | TranscriptSegmentCreateOrConnectWithoutMeetingInput[];
    upsert?:
      | TranscriptSegmentUpsertWithWhereUniqueWithoutMeetingInput
      | TranscriptSegmentUpsertWithWhereUniqueWithoutMeetingInput[];
    createMany?: TranscriptSegmentCreateManyMeetingInputEnvelope;
    set?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    disconnect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    delete?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    connect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    update?:
      | TranscriptSegmentUpdateWithWhereUniqueWithoutMeetingInput
      | TranscriptSegmentUpdateWithWhereUniqueWithoutMeetingInput[];
    updateMany?:
      | TranscriptSegmentUpdateManyWithWhereWithoutMeetingInput
      | TranscriptSegmentUpdateManyWithWhereWithoutMeetingInput[];
    deleteMany?:
      | TranscriptSegmentScalarWhereInput
      | TranscriptSegmentScalarWhereInput[];
  };

  export type MeetingCreateNestedOneWithoutKeyMomentsInput = {
    create?: XOR<
      MeetingCreateWithoutKeyMomentsInput,
      MeetingUncheckedCreateWithoutKeyMomentsInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutKeyMomentsInput;
    connect?: MeetingWhereUniqueInput;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumMomentTypeFieldUpdateOperationsInput = {
    set?: $Enums.MomentType;
  };

  export type MeetingUpdateOneRequiredWithoutKeyMomentsNestedInput = {
    create?: XOR<
      MeetingCreateWithoutKeyMomentsInput,
      MeetingUncheckedCreateWithoutKeyMomentsInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutKeyMomentsInput;
    upsert?: MeetingUpsertWithoutKeyMomentsInput;
    connect?: MeetingWhereUniqueInput;
    update?: XOR<
      XOR<
        MeetingUpdateToOneWithWhereWithoutKeyMomentsInput,
        MeetingUpdateWithoutKeyMomentsInput
      >,
      MeetingUncheckedUpdateWithoutKeyMomentsInput
    >;
  };

  export type TranscriptSegmentCreatelanguagesUsedInput = {
    set: string[];
  };

  export type SegmentEditCreateNestedManyWithoutSegmentInput = {
    create?:
      | XOR<
          SegmentEditCreateWithoutSegmentInput,
          SegmentEditUncheckedCreateWithoutSegmentInput
        >
      | SegmentEditCreateWithoutSegmentInput[]
      | SegmentEditUncheckedCreateWithoutSegmentInput[];
    connectOrCreate?:
      | SegmentEditCreateOrConnectWithoutSegmentInput
      | SegmentEditCreateOrConnectWithoutSegmentInput[];
    createMany?: SegmentEditCreateManySegmentInputEnvelope;
    connect?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
  };

  export type TranscriptCorrectionCreateNestedManyWithoutSegmentInput = {
    create?:
      | XOR<
          TranscriptCorrectionCreateWithoutSegmentInput,
          TranscriptCorrectionUncheckedCreateWithoutSegmentInput
        >
      | TranscriptCorrectionCreateWithoutSegmentInput[]
      | TranscriptCorrectionUncheckedCreateWithoutSegmentInput[];
    connectOrCreate?:
      | TranscriptCorrectionCreateOrConnectWithoutSegmentInput
      | TranscriptCorrectionCreateOrConnectWithoutSegmentInput[];
    createMany?: TranscriptCorrectionCreateManySegmentInputEnvelope;
    connect?:
      | TranscriptCorrectionWhereUniqueInput
      | TranscriptCorrectionWhereUniqueInput[];
  };

  export type MeetingCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<
      MeetingCreateWithoutTranscriptInput,
      MeetingUncheckedCreateWithoutTranscriptInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutTranscriptInput;
    connect?: MeetingWhereUniqueInput;
  };

  export type SpeakerCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<
      SpeakerCreateWithoutSegmentsInput,
      SpeakerUncheckedCreateWithoutSegmentsInput
    >;
    connectOrCreate?: SpeakerCreateOrConnectWithoutSegmentsInput;
    connect?: SpeakerWhereUniqueInput;
  };

  export type SegmentEditUncheckedCreateNestedManyWithoutSegmentInput = {
    create?:
      | XOR<
          SegmentEditCreateWithoutSegmentInput,
          SegmentEditUncheckedCreateWithoutSegmentInput
        >
      | SegmentEditCreateWithoutSegmentInput[]
      | SegmentEditUncheckedCreateWithoutSegmentInput[];
    connectOrCreate?:
      | SegmentEditCreateOrConnectWithoutSegmentInput
      | SegmentEditCreateOrConnectWithoutSegmentInput[];
    createMany?: SegmentEditCreateManySegmentInputEnvelope;
    connect?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
  };

  export type TranscriptCorrectionUncheckedCreateNestedManyWithoutSegmentInput =
    {
      create?:
        | XOR<
            TranscriptCorrectionCreateWithoutSegmentInput,
            TranscriptCorrectionUncheckedCreateWithoutSegmentInput
          >
        | TranscriptCorrectionCreateWithoutSegmentInput[]
        | TranscriptCorrectionUncheckedCreateWithoutSegmentInput[];
      connectOrCreate?:
        | TranscriptCorrectionCreateOrConnectWithoutSegmentInput
        | TranscriptCorrectionCreateOrConnectWithoutSegmentInput[];
      createMany?: TranscriptCorrectionCreateManySegmentInputEnvelope;
      connect?:
        | TranscriptCorrectionWhereUniqueInput
        | TranscriptCorrectionWhereUniqueInput[];
    };

  export type TranscriptSegmentUpdatelanguagesUsedInput = {
    set?: string[];
    push?: string | string[];
  };

  export type SegmentEditUpdateManyWithoutSegmentNestedInput = {
    create?:
      | XOR<
          SegmentEditCreateWithoutSegmentInput,
          SegmentEditUncheckedCreateWithoutSegmentInput
        >
      | SegmentEditCreateWithoutSegmentInput[]
      | SegmentEditUncheckedCreateWithoutSegmentInput[];
    connectOrCreate?:
      | SegmentEditCreateOrConnectWithoutSegmentInput
      | SegmentEditCreateOrConnectWithoutSegmentInput[];
    upsert?:
      | SegmentEditUpsertWithWhereUniqueWithoutSegmentInput
      | SegmentEditUpsertWithWhereUniqueWithoutSegmentInput[];
    createMany?: SegmentEditCreateManySegmentInputEnvelope;
    set?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
    disconnect?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
    delete?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
    connect?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
    update?:
      | SegmentEditUpdateWithWhereUniqueWithoutSegmentInput
      | SegmentEditUpdateWithWhereUniqueWithoutSegmentInput[];
    updateMany?:
      | SegmentEditUpdateManyWithWhereWithoutSegmentInput
      | SegmentEditUpdateManyWithWhereWithoutSegmentInput[];
    deleteMany?: SegmentEditScalarWhereInput | SegmentEditScalarWhereInput[];
  };

  export type TranscriptCorrectionUpdateManyWithoutSegmentNestedInput = {
    create?:
      | XOR<
          TranscriptCorrectionCreateWithoutSegmentInput,
          TranscriptCorrectionUncheckedCreateWithoutSegmentInput
        >
      | TranscriptCorrectionCreateWithoutSegmentInput[]
      | TranscriptCorrectionUncheckedCreateWithoutSegmentInput[];
    connectOrCreate?:
      | TranscriptCorrectionCreateOrConnectWithoutSegmentInput
      | TranscriptCorrectionCreateOrConnectWithoutSegmentInput[];
    upsert?:
      | TranscriptCorrectionUpsertWithWhereUniqueWithoutSegmentInput
      | TranscriptCorrectionUpsertWithWhereUniqueWithoutSegmentInput[];
    createMany?: TranscriptCorrectionCreateManySegmentInputEnvelope;
    set?:
      | TranscriptCorrectionWhereUniqueInput
      | TranscriptCorrectionWhereUniqueInput[];
    disconnect?:
      | TranscriptCorrectionWhereUniqueInput
      | TranscriptCorrectionWhereUniqueInput[];
    delete?:
      | TranscriptCorrectionWhereUniqueInput
      | TranscriptCorrectionWhereUniqueInput[];
    connect?:
      | TranscriptCorrectionWhereUniqueInput
      | TranscriptCorrectionWhereUniqueInput[];
    update?:
      | TranscriptCorrectionUpdateWithWhereUniqueWithoutSegmentInput
      | TranscriptCorrectionUpdateWithWhereUniqueWithoutSegmentInput[];
    updateMany?:
      | TranscriptCorrectionUpdateManyWithWhereWithoutSegmentInput
      | TranscriptCorrectionUpdateManyWithWhereWithoutSegmentInput[];
    deleteMany?:
      | TranscriptCorrectionScalarWhereInput
      | TranscriptCorrectionScalarWhereInput[];
  };

  export type MeetingUpdateOneRequiredWithoutTranscriptNestedInput = {
    create?: XOR<
      MeetingCreateWithoutTranscriptInput,
      MeetingUncheckedCreateWithoutTranscriptInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutTranscriptInput;
    upsert?: MeetingUpsertWithoutTranscriptInput;
    connect?: MeetingWhereUniqueInput;
    update?: XOR<
      XOR<
        MeetingUpdateToOneWithWhereWithoutTranscriptInput,
        MeetingUpdateWithoutTranscriptInput
      >,
      MeetingUncheckedUpdateWithoutTranscriptInput
    >;
  };

  export type SpeakerUpdateOneWithoutSegmentsNestedInput = {
    create?: XOR<
      SpeakerCreateWithoutSegmentsInput,
      SpeakerUncheckedCreateWithoutSegmentsInput
    >;
    connectOrCreate?: SpeakerCreateOrConnectWithoutSegmentsInput;
    upsert?: SpeakerUpsertWithoutSegmentsInput;
    disconnect?: SpeakerWhereInput | boolean;
    delete?: SpeakerWhereInput | boolean;
    connect?: SpeakerWhereUniqueInput;
    update?: XOR<
      XOR<
        SpeakerUpdateToOneWithWhereWithoutSegmentsInput,
        SpeakerUpdateWithoutSegmentsInput
      >,
      SpeakerUncheckedUpdateWithoutSegmentsInput
    >;
  };

  export type SegmentEditUncheckedUpdateManyWithoutSegmentNestedInput = {
    create?:
      | XOR<
          SegmentEditCreateWithoutSegmentInput,
          SegmentEditUncheckedCreateWithoutSegmentInput
        >
      | SegmentEditCreateWithoutSegmentInput[]
      | SegmentEditUncheckedCreateWithoutSegmentInput[];
    connectOrCreate?:
      | SegmentEditCreateOrConnectWithoutSegmentInput
      | SegmentEditCreateOrConnectWithoutSegmentInput[];
    upsert?:
      | SegmentEditUpsertWithWhereUniqueWithoutSegmentInput
      | SegmentEditUpsertWithWhereUniqueWithoutSegmentInput[];
    createMany?: SegmentEditCreateManySegmentInputEnvelope;
    set?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
    disconnect?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
    delete?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
    connect?: SegmentEditWhereUniqueInput | SegmentEditWhereUniqueInput[];
    update?:
      | SegmentEditUpdateWithWhereUniqueWithoutSegmentInput
      | SegmentEditUpdateWithWhereUniqueWithoutSegmentInput[];
    updateMany?:
      | SegmentEditUpdateManyWithWhereWithoutSegmentInput
      | SegmentEditUpdateManyWithWhereWithoutSegmentInput[];
    deleteMany?: SegmentEditScalarWhereInput | SegmentEditScalarWhereInput[];
  };

  export type TranscriptCorrectionUncheckedUpdateManyWithoutSegmentNestedInput =
    {
      create?:
        | XOR<
            TranscriptCorrectionCreateWithoutSegmentInput,
            TranscriptCorrectionUncheckedCreateWithoutSegmentInput
          >
        | TranscriptCorrectionCreateWithoutSegmentInput[]
        | TranscriptCorrectionUncheckedCreateWithoutSegmentInput[];
      connectOrCreate?:
        | TranscriptCorrectionCreateOrConnectWithoutSegmentInput
        | TranscriptCorrectionCreateOrConnectWithoutSegmentInput[];
      upsert?:
        | TranscriptCorrectionUpsertWithWhereUniqueWithoutSegmentInput
        | TranscriptCorrectionUpsertWithWhereUniqueWithoutSegmentInput[];
      createMany?: TranscriptCorrectionCreateManySegmentInputEnvelope;
      set?:
        | TranscriptCorrectionWhereUniqueInput
        | TranscriptCorrectionWhereUniqueInput[];
      disconnect?:
        | TranscriptCorrectionWhereUniqueInput
        | TranscriptCorrectionWhereUniqueInput[];
      delete?:
        | TranscriptCorrectionWhereUniqueInput
        | TranscriptCorrectionWhereUniqueInput[];
      connect?:
        | TranscriptCorrectionWhereUniqueInput
        | TranscriptCorrectionWhereUniqueInput[];
      update?:
        | TranscriptCorrectionUpdateWithWhereUniqueWithoutSegmentInput
        | TranscriptCorrectionUpdateWithWhereUniqueWithoutSegmentInput[];
      updateMany?:
        | TranscriptCorrectionUpdateManyWithWhereWithoutSegmentInput
        | TranscriptCorrectionUpdateManyWithWhereWithoutSegmentInput[];
      deleteMany?:
        | TranscriptCorrectionScalarWhereInput
        | TranscriptCorrectionScalarWhereInput[];
    };

  export type TranscriptSegmentCreateNestedOneWithoutCorrectionsInput = {
    create?: XOR<
      TranscriptSegmentCreateWithoutCorrectionsInput,
      TranscriptSegmentUncheckedCreateWithoutCorrectionsInput
    >;
    connectOrCreate?: TranscriptSegmentCreateOrConnectWithoutCorrectionsInput;
    connect?: TranscriptSegmentWhereUniqueInput;
  };

  export type TranscriptSegmentUpdateOneRequiredWithoutCorrectionsNestedInput =
    {
      create?: XOR<
        TranscriptSegmentCreateWithoutCorrectionsInput,
        TranscriptSegmentUncheckedCreateWithoutCorrectionsInput
      >;
      connectOrCreate?: TranscriptSegmentCreateOrConnectWithoutCorrectionsInput;
      upsert?: TranscriptSegmentUpsertWithoutCorrectionsInput;
      connect?: TranscriptSegmentWhereUniqueInput;
      update?: XOR<
        XOR<
          TranscriptSegmentUpdateToOneWithWhereWithoutCorrectionsInput,
          TranscriptSegmentUpdateWithoutCorrectionsInput
        >,
        TranscriptSegmentUncheckedUpdateWithoutCorrectionsInput
      >;
    };

  export type TranscriptSegmentCreateNestedOneWithoutEditsInput = {
    create?: XOR<
      TranscriptSegmentCreateWithoutEditsInput,
      TranscriptSegmentUncheckedCreateWithoutEditsInput
    >;
    connectOrCreate?: TranscriptSegmentCreateOrConnectWithoutEditsInput;
    connect?: TranscriptSegmentWhereUniqueInput;
  };

  export type TranscriptSegmentUpdateOneRequiredWithoutEditsNestedInput = {
    create?: XOR<
      TranscriptSegmentCreateWithoutEditsInput,
      TranscriptSegmentUncheckedCreateWithoutEditsInput
    >;
    connectOrCreate?: TranscriptSegmentCreateOrConnectWithoutEditsInput;
    upsert?: TranscriptSegmentUpsertWithoutEditsInput;
    connect?: TranscriptSegmentWhereUniqueInput;
    update?: XOR<
      XOR<
        TranscriptSegmentUpdateToOneWithWhereWithoutEditsInput,
        TranscriptSegmentUpdateWithoutEditsInput
      >,
      TranscriptSegmentUncheckedUpdateWithoutEditsInput
    >;
  };

  export type MeetingCreateNestedOneWithoutSpeakersInput = {
    create?: XOR<
      MeetingCreateWithoutSpeakersInput,
      MeetingUncheckedCreateWithoutSpeakersInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutSpeakersInput;
    connect?: MeetingWhereUniqueInput;
  };

  export type TranscriptSegmentCreateNestedManyWithoutSpeakerInput = {
    create?:
      | XOR<
          TranscriptSegmentCreateWithoutSpeakerInput,
          TranscriptSegmentUncheckedCreateWithoutSpeakerInput
        >
      | TranscriptSegmentCreateWithoutSpeakerInput[]
      | TranscriptSegmentUncheckedCreateWithoutSpeakerInput[];
    connectOrCreate?:
      | TranscriptSegmentCreateOrConnectWithoutSpeakerInput
      | TranscriptSegmentCreateOrConnectWithoutSpeakerInput[];
    createMany?: TranscriptSegmentCreateManySpeakerInputEnvelope;
    connect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
  };

  export type TranscriptSegmentUncheckedCreateNestedManyWithoutSpeakerInput = {
    create?:
      | XOR<
          TranscriptSegmentCreateWithoutSpeakerInput,
          TranscriptSegmentUncheckedCreateWithoutSpeakerInput
        >
      | TranscriptSegmentCreateWithoutSpeakerInput[]
      | TranscriptSegmentUncheckedCreateWithoutSpeakerInput[];
    connectOrCreate?:
      | TranscriptSegmentCreateOrConnectWithoutSpeakerInput
      | TranscriptSegmentCreateOrConnectWithoutSpeakerInput[];
    createMany?: TranscriptSegmentCreateManySpeakerInputEnvelope;
    connect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
  };

  export type MeetingUpdateOneRequiredWithoutSpeakersNestedInput = {
    create?: XOR<
      MeetingCreateWithoutSpeakersInput,
      MeetingUncheckedCreateWithoutSpeakersInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutSpeakersInput;
    upsert?: MeetingUpsertWithoutSpeakersInput;
    connect?: MeetingWhereUniqueInput;
    update?: XOR<
      XOR<
        MeetingUpdateToOneWithWhereWithoutSpeakersInput,
        MeetingUpdateWithoutSpeakersInput
      >,
      MeetingUncheckedUpdateWithoutSpeakersInput
    >;
  };

  export type TranscriptSegmentUpdateManyWithoutSpeakerNestedInput = {
    create?:
      | XOR<
          TranscriptSegmentCreateWithoutSpeakerInput,
          TranscriptSegmentUncheckedCreateWithoutSpeakerInput
        >
      | TranscriptSegmentCreateWithoutSpeakerInput[]
      | TranscriptSegmentUncheckedCreateWithoutSpeakerInput[];
    connectOrCreate?:
      | TranscriptSegmentCreateOrConnectWithoutSpeakerInput
      | TranscriptSegmentCreateOrConnectWithoutSpeakerInput[];
    upsert?:
      | TranscriptSegmentUpsertWithWhereUniqueWithoutSpeakerInput
      | TranscriptSegmentUpsertWithWhereUniqueWithoutSpeakerInput[];
    createMany?: TranscriptSegmentCreateManySpeakerInputEnvelope;
    set?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    disconnect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    delete?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    connect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    update?:
      | TranscriptSegmentUpdateWithWhereUniqueWithoutSpeakerInput
      | TranscriptSegmentUpdateWithWhereUniqueWithoutSpeakerInput[];
    updateMany?:
      | TranscriptSegmentUpdateManyWithWhereWithoutSpeakerInput
      | TranscriptSegmentUpdateManyWithWhereWithoutSpeakerInput[];
    deleteMany?:
      | TranscriptSegmentScalarWhereInput
      | TranscriptSegmentScalarWhereInput[];
  };

  export type TranscriptSegmentUncheckedUpdateManyWithoutSpeakerNestedInput = {
    create?:
      | XOR<
          TranscriptSegmentCreateWithoutSpeakerInput,
          TranscriptSegmentUncheckedCreateWithoutSpeakerInput
        >
      | TranscriptSegmentCreateWithoutSpeakerInput[]
      | TranscriptSegmentUncheckedCreateWithoutSpeakerInput[];
    connectOrCreate?:
      | TranscriptSegmentCreateOrConnectWithoutSpeakerInput
      | TranscriptSegmentCreateOrConnectWithoutSpeakerInput[];
    upsert?:
      | TranscriptSegmentUpsertWithWhereUniqueWithoutSpeakerInput
      | TranscriptSegmentUpsertWithWhereUniqueWithoutSpeakerInput[];
    createMany?: TranscriptSegmentCreateManySpeakerInputEnvelope;
    set?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    disconnect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    delete?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    connect?:
      | TranscriptSegmentWhereUniqueInput
      | TranscriptSegmentWhereUniqueInput[];
    update?:
      | TranscriptSegmentUpdateWithWhereUniqueWithoutSpeakerInput
      | TranscriptSegmentUpdateWithWhereUniqueWithoutSpeakerInput[];
    updateMany?:
      | TranscriptSegmentUpdateManyWithWhereWithoutSpeakerInput
      | TranscriptSegmentUpdateManyWithWhereWithoutSpeakerInput[];
    deleteMany?:
      | TranscriptSegmentScalarWhereInput
      | TranscriptSegmentScalarWhereInput[];
  };

  export type MeetingCreateNestedOneWithoutMinutesInput = {
    create?: XOR<
      MeetingCreateWithoutMinutesInput,
      MeetingUncheckedCreateWithoutMinutesInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutMinutesInput;
    connect?: MeetingWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutReviewedMinutesInput = {
    create?: XOR<
      UserCreateWithoutReviewedMinutesInput,
      UserUncheckedCreateWithoutReviewedMinutesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReviewedMinutesInput;
    connect?: UserWhereUniqueInput;
  };

  export type MinutesVersionCreateNestedManyWithoutMinutesInput = {
    create?:
      | XOR<
          MinutesVersionCreateWithoutMinutesInput,
          MinutesVersionUncheckedCreateWithoutMinutesInput
        >
      | MinutesVersionCreateWithoutMinutesInput[]
      | MinutesVersionUncheckedCreateWithoutMinutesInput[];
    connectOrCreate?:
      | MinutesVersionCreateOrConnectWithoutMinutesInput
      | MinutesVersionCreateOrConnectWithoutMinutesInput[];
    createMany?: MinutesVersionCreateManyMinutesInputEnvelope;
    connect?: MinutesVersionWhereUniqueInput | MinutesVersionWhereUniqueInput[];
  };

  export type MinutesVersionUncheckedCreateNestedManyWithoutMinutesInput = {
    create?:
      | XOR<
          MinutesVersionCreateWithoutMinutesInput,
          MinutesVersionUncheckedCreateWithoutMinutesInput
        >
      | MinutesVersionCreateWithoutMinutesInput[]
      | MinutesVersionUncheckedCreateWithoutMinutesInput[];
    connectOrCreate?:
      | MinutesVersionCreateOrConnectWithoutMinutesInput
      | MinutesVersionCreateOrConnectWithoutMinutesInput[];
    createMany?: MinutesVersionCreateManyMinutesInputEnvelope;
    connect?: MinutesVersionWhereUniqueInput | MinutesVersionWhereUniqueInput[];
  };

  export type EnumMinutesStatusFieldUpdateOperationsInput = {
    set?: $Enums.MinutesStatus;
  };

  export type MeetingUpdateOneRequiredWithoutMinutesNestedInput = {
    create?: XOR<
      MeetingCreateWithoutMinutesInput,
      MeetingUncheckedCreateWithoutMinutesInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutMinutesInput;
    upsert?: MeetingUpsertWithoutMinutesInput;
    connect?: MeetingWhereUniqueInput;
    update?: XOR<
      XOR<
        MeetingUpdateToOneWithWhereWithoutMinutesInput,
        MeetingUpdateWithoutMinutesInput
      >,
      MeetingUncheckedUpdateWithoutMinutesInput
    >;
  };

  export type UserUpdateOneWithoutReviewedMinutesNestedInput = {
    create?: XOR<
      UserCreateWithoutReviewedMinutesInput,
      UserUncheckedCreateWithoutReviewedMinutesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReviewedMinutesInput;
    upsert?: UserUpsertWithoutReviewedMinutesInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutReviewedMinutesInput,
        UserUpdateWithoutReviewedMinutesInput
      >,
      UserUncheckedUpdateWithoutReviewedMinutesInput
    >;
  };

  export type MinutesVersionUpdateManyWithoutMinutesNestedInput = {
    create?:
      | XOR<
          MinutesVersionCreateWithoutMinutesInput,
          MinutesVersionUncheckedCreateWithoutMinutesInput
        >
      | MinutesVersionCreateWithoutMinutesInput[]
      | MinutesVersionUncheckedCreateWithoutMinutesInput[];
    connectOrCreate?:
      | MinutesVersionCreateOrConnectWithoutMinutesInput
      | MinutesVersionCreateOrConnectWithoutMinutesInput[];
    upsert?:
      | MinutesVersionUpsertWithWhereUniqueWithoutMinutesInput
      | MinutesVersionUpsertWithWhereUniqueWithoutMinutesInput[];
    createMany?: MinutesVersionCreateManyMinutesInputEnvelope;
    set?: MinutesVersionWhereUniqueInput | MinutesVersionWhereUniqueInput[];
    disconnect?:
      | MinutesVersionWhereUniqueInput
      | MinutesVersionWhereUniqueInput[];
    delete?: MinutesVersionWhereUniqueInput | MinutesVersionWhereUniqueInput[];
    connect?: MinutesVersionWhereUniqueInput | MinutesVersionWhereUniqueInput[];
    update?:
      | MinutesVersionUpdateWithWhereUniqueWithoutMinutesInput
      | MinutesVersionUpdateWithWhereUniqueWithoutMinutesInput[];
    updateMany?:
      | MinutesVersionUpdateManyWithWhereWithoutMinutesInput
      | MinutesVersionUpdateManyWithWhereWithoutMinutesInput[];
    deleteMany?:
      | MinutesVersionScalarWhereInput
      | MinutesVersionScalarWhereInput[];
  };

  export type MinutesVersionUncheckedUpdateManyWithoutMinutesNestedInput = {
    create?:
      | XOR<
          MinutesVersionCreateWithoutMinutesInput,
          MinutesVersionUncheckedCreateWithoutMinutesInput
        >
      | MinutesVersionCreateWithoutMinutesInput[]
      | MinutesVersionUncheckedCreateWithoutMinutesInput[];
    connectOrCreate?:
      | MinutesVersionCreateOrConnectWithoutMinutesInput
      | MinutesVersionCreateOrConnectWithoutMinutesInput[];
    upsert?:
      | MinutesVersionUpsertWithWhereUniqueWithoutMinutesInput
      | MinutesVersionUpsertWithWhereUniqueWithoutMinutesInput[];
    createMany?: MinutesVersionCreateManyMinutesInputEnvelope;
    set?: MinutesVersionWhereUniqueInput | MinutesVersionWhereUniqueInput[];
    disconnect?:
      | MinutesVersionWhereUniqueInput
      | MinutesVersionWhereUniqueInput[];
    delete?: MinutesVersionWhereUniqueInput | MinutesVersionWhereUniqueInput[];
    connect?: MinutesVersionWhereUniqueInput | MinutesVersionWhereUniqueInput[];
    update?:
      | MinutesVersionUpdateWithWhereUniqueWithoutMinutesInput
      | MinutesVersionUpdateWithWhereUniqueWithoutMinutesInput[];
    updateMany?:
      | MinutesVersionUpdateManyWithWhereWithoutMinutesInput
      | MinutesVersionUpdateManyWithWhereWithoutMinutesInput[];
    deleteMany?:
      | MinutesVersionScalarWhereInput
      | MinutesVersionScalarWhereInput[];
  };

  export type MinutesCreateNestedOneWithoutVersionsInput = {
    create?: XOR<
      MinutesCreateWithoutVersionsInput,
      MinutesUncheckedCreateWithoutVersionsInput
    >;
    connectOrCreate?: MinutesCreateOrConnectWithoutVersionsInput;
    connect?: MinutesWhereUniqueInput;
  };

  export type MinutesUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<
      MinutesCreateWithoutVersionsInput,
      MinutesUncheckedCreateWithoutVersionsInput
    >;
    connectOrCreate?: MinutesCreateOrConnectWithoutVersionsInput;
    upsert?: MinutesUpsertWithoutVersionsInput;
    connect?: MinutesWhereUniqueInput;
    update?: XOR<
      XOR<
        MinutesUpdateToOneWithWhereWithoutVersionsInput,
        MinutesUpdateWithoutVersionsInput
      >,
      MinutesUncheckedUpdateWithoutVersionsInput
    >;
  };

  export type UserCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<
      UserCreateWithoutNotificationSettingsInput,
      UserUncheckedCreateWithoutNotificationSettingsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<
      UserCreateWithoutNotificationSettingsInput,
      UserUncheckedCreateWithoutNotificationSettingsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput;
    upsert?: UserUpsertWithoutNotificationSettingsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutNotificationSettingsInput,
        UserUpdateWithoutNotificationSettingsInput
      >,
      UserUncheckedUpdateWithoutNotificationSettingsInput
    >;
  };

  export type MeetingTagCreateNestedManyWithoutTagInput = {
    create?:
      | XOR<
          MeetingTagCreateWithoutTagInput,
          MeetingTagUncheckedCreateWithoutTagInput
        >
      | MeetingTagCreateWithoutTagInput[]
      | MeetingTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | MeetingTagCreateOrConnectWithoutTagInput
      | MeetingTagCreateOrConnectWithoutTagInput[];
    createMany?: MeetingTagCreateManyTagInputEnvelope;
    connect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutTagsInput = {
    create?: XOR<
      UserCreateWithoutTagsInput,
      UserUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutTagsInput = {
    create?: XOR<
      OrganizationCreateWithoutTagsInput,
      OrganizationUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutTagsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type MeetingTagUncheckedCreateNestedManyWithoutTagInput = {
    create?:
      | XOR<
          MeetingTagCreateWithoutTagInput,
          MeetingTagUncheckedCreateWithoutTagInput
        >
      | MeetingTagCreateWithoutTagInput[]
      | MeetingTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | MeetingTagCreateOrConnectWithoutTagInput
      | MeetingTagCreateOrConnectWithoutTagInput[];
    createMany?: MeetingTagCreateManyTagInputEnvelope;
    connect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
  };

  export type MeetingTagUpdateManyWithoutTagNestedInput = {
    create?:
      | XOR<
          MeetingTagCreateWithoutTagInput,
          MeetingTagUncheckedCreateWithoutTagInput
        >
      | MeetingTagCreateWithoutTagInput[]
      | MeetingTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | MeetingTagCreateOrConnectWithoutTagInput
      | MeetingTagCreateOrConnectWithoutTagInput[];
    upsert?:
      | MeetingTagUpsertWithWhereUniqueWithoutTagInput
      | MeetingTagUpsertWithWhereUniqueWithoutTagInput[];
    createMany?: MeetingTagCreateManyTagInputEnvelope;
    set?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    disconnect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    delete?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    connect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    update?:
      | MeetingTagUpdateWithWhereUniqueWithoutTagInput
      | MeetingTagUpdateWithWhereUniqueWithoutTagInput[];
    updateMany?:
      | MeetingTagUpdateManyWithWhereWithoutTagInput
      | MeetingTagUpdateManyWithWhereWithoutTagInput[];
    deleteMany?: MeetingTagScalarWhereInput | MeetingTagScalarWhereInput[];
  };

  export type UserUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<
      UserCreateWithoutTagsInput,
      UserUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput;
    upsert?: UserUpsertWithoutTagsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutTagsInput, UserUpdateWithoutTagsInput>,
      UserUncheckedUpdateWithoutTagsInput
    >;
  };

  export type OrganizationUpdateOneWithoutTagsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutTagsInput,
      OrganizationUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutTagsInput;
    upsert?: OrganizationUpsertWithoutTagsInput;
    disconnect?: OrganizationWhereInput | boolean;
    delete?: OrganizationWhereInput | boolean;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutTagsInput,
        OrganizationUpdateWithoutTagsInput
      >,
      OrganizationUncheckedUpdateWithoutTagsInput
    >;
  };

  export type MeetingTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?:
      | XOR<
          MeetingTagCreateWithoutTagInput,
          MeetingTagUncheckedCreateWithoutTagInput
        >
      | MeetingTagCreateWithoutTagInput[]
      | MeetingTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | MeetingTagCreateOrConnectWithoutTagInput
      | MeetingTagCreateOrConnectWithoutTagInput[];
    upsert?:
      | MeetingTagUpsertWithWhereUniqueWithoutTagInput
      | MeetingTagUpsertWithWhereUniqueWithoutTagInput[];
    createMany?: MeetingTagCreateManyTagInputEnvelope;
    set?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    disconnect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    delete?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    connect?: MeetingTagWhereUniqueInput | MeetingTagWhereUniqueInput[];
    update?:
      | MeetingTagUpdateWithWhereUniqueWithoutTagInput
      | MeetingTagUpdateWithWhereUniqueWithoutTagInput[];
    updateMany?:
      | MeetingTagUpdateManyWithWhereWithoutTagInput
      | MeetingTagUpdateManyWithWhereWithoutTagInput[];
    deleteMany?: MeetingTagScalarWhereInput | MeetingTagScalarWhereInput[];
  };

  export type MeetingCreateNestedOneWithoutTagsInput = {
    create?: XOR<
      MeetingCreateWithoutTagsInput,
      MeetingUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutTagsInput;
    connect?: MeetingWhereUniqueInput;
  };

  export type TagCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<
      TagCreateWithoutMeetingsInput,
      TagUncheckedCreateWithoutMeetingsInput
    >;
    connectOrCreate?: TagCreateOrConnectWithoutMeetingsInput;
    connect?: TagWhereUniqueInput;
  };

  export type MeetingUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<
      MeetingCreateWithoutTagsInput,
      MeetingUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutTagsInput;
    upsert?: MeetingUpsertWithoutTagsInput;
    connect?: MeetingWhereUniqueInput;
    update?: XOR<
      XOR<
        MeetingUpdateToOneWithWhereWithoutTagsInput,
        MeetingUpdateWithoutTagsInput
      >,
      MeetingUncheckedUpdateWithoutTagsInput
    >;
  };

  export type TagUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<
      TagCreateWithoutMeetingsInput,
      TagUncheckedCreateWithoutMeetingsInput
    >;
    connectOrCreate?: TagCreateOrConnectWithoutMeetingsInput;
    upsert?: TagUpsertWithoutMeetingsInput;
    connect?: TagWhereUniqueInput;
    update?: XOR<
      XOR<
        TagUpdateToOneWithWhereWithoutMeetingsInput,
        TagUpdateWithoutMeetingsInput
      >,
      TagUncheckedUpdateWithoutMeetingsInput
    >;
  };

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType;
  };

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    upsert?: UserUpsertWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutNotificationsInput,
        UserUpdateWithoutNotificationsInput
      >,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type MeetingCreateNestedOneWithoutShareLinksInput = {
    create?: XOR<
      MeetingCreateWithoutShareLinksInput,
      MeetingUncheckedCreateWithoutShareLinksInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutShareLinksInput;
    connect?: MeetingWhereUniqueInput;
  };

  export type EnumShareTypeFieldUpdateOperationsInput = {
    set?: $Enums.ShareType;
  };

  export type MeetingUpdateOneRequiredWithoutShareLinksNestedInput = {
    create?: XOR<
      MeetingCreateWithoutShareLinksInput,
      MeetingUncheckedCreateWithoutShareLinksInput
    >;
    connectOrCreate?: MeetingCreateOrConnectWithoutShareLinksInput;
    upsert?: MeetingUpsertWithoutShareLinksInput;
    connect?: MeetingWhereUniqueInput;
    update?: XOR<
      XOR<
        MeetingUpdateToOneWithWhereWithoutShareLinksInput,
        MeetingUpdateWithoutShareLinksInput
      >,
      MeetingUncheckedUpdateWithoutShareLinksInput
    >;
  };

  export type UserCreateNestedOneWithoutCalendarConnectionsInput = {
    create?: XOR<
      UserCreateWithoutCalendarConnectionsInput,
      UserUncheckedCreateWithoutCalendarConnectionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCalendarConnectionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type MeetingCreateNestedManyWithoutCalendarConnectionInput = {
    create?:
      | XOR<
          MeetingCreateWithoutCalendarConnectionInput,
          MeetingUncheckedCreateWithoutCalendarConnectionInput
        >
      | MeetingCreateWithoutCalendarConnectionInput[]
      | MeetingUncheckedCreateWithoutCalendarConnectionInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutCalendarConnectionInput
      | MeetingCreateOrConnectWithoutCalendarConnectionInput[];
    createMany?: MeetingCreateManyCalendarConnectionInputEnvelope;
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
  };

  export type MeetingUncheckedCreateNestedManyWithoutCalendarConnectionInput = {
    create?:
      | XOR<
          MeetingCreateWithoutCalendarConnectionInput,
          MeetingUncheckedCreateWithoutCalendarConnectionInput
        >
      | MeetingCreateWithoutCalendarConnectionInput[]
      | MeetingUncheckedCreateWithoutCalendarConnectionInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutCalendarConnectionInput
      | MeetingCreateOrConnectWithoutCalendarConnectionInput[];
    createMany?: MeetingCreateManyCalendarConnectionInputEnvelope;
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
  };

  export type EnumCalendarProviderFieldUpdateOperationsInput = {
    set?: $Enums.CalendarProvider;
  };

  export type EnumConnectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConnectionStatus;
  };

  export type UserUpdateOneRequiredWithoutCalendarConnectionsNestedInput = {
    create?: XOR<
      UserCreateWithoutCalendarConnectionsInput,
      UserUncheckedCreateWithoutCalendarConnectionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCalendarConnectionsInput;
    upsert?: UserUpsertWithoutCalendarConnectionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCalendarConnectionsInput,
        UserUpdateWithoutCalendarConnectionsInput
      >,
      UserUncheckedUpdateWithoutCalendarConnectionsInput
    >;
  };

  export type MeetingUpdateManyWithoutCalendarConnectionNestedInput = {
    create?:
      | XOR<
          MeetingCreateWithoutCalendarConnectionInput,
          MeetingUncheckedCreateWithoutCalendarConnectionInput
        >
      | MeetingCreateWithoutCalendarConnectionInput[]
      | MeetingUncheckedCreateWithoutCalendarConnectionInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutCalendarConnectionInput
      | MeetingCreateOrConnectWithoutCalendarConnectionInput[];
    upsert?:
      | MeetingUpsertWithWhereUniqueWithoutCalendarConnectionInput
      | MeetingUpsertWithWhereUniqueWithoutCalendarConnectionInput[];
    createMany?: MeetingCreateManyCalendarConnectionInputEnvelope;
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    update?:
      | MeetingUpdateWithWhereUniqueWithoutCalendarConnectionInput
      | MeetingUpdateWithWhereUniqueWithoutCalendarConnectionInput[];
    updateMany?:
      | MeetingUpdateManyWithWhereWithoutCalendarConnectionInput
      | MeetingUpdateManyWithWhereWithoutCalendarConnectionInput[];
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[];
  };

  export type MeetingUncheckedUpdateManyWithoutCalendarConnectionNestedInput = {
    create?:
      | XOR<
          MeetingCreateWithoutCalendarConnectionInput,
          MeetingUncheckedCreateWithoutCalendarConnectionInput
        >
      | MeetingCreateWithoutCalendarConnectionInput[]
      | MeetingUncheckedCreateWithoutCalendarConnectionInput[];
    connectOrCreate?:
      | MeetingCreateOrConnectWithoutCalendarConnectionInput
      | MeetingCreateOrConnectWithoutCalendarConnectionInput[];
    upsert?:
      | MeetingUpsertWithWhereUniqueWithoutCalendarConnectionInput
      | MeetingUpsertWithWhereUniqueWithoutCalendarConnectionInput[];
    createMany?: MeetingCreateManyCalendarConnectionInputEnvelope;
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[];
    update?:
      | MeetingUpdateWithWhereUniqueWithoutCalendarConnectionInput
      | MeetingUpdateWithWhereUniqueWithoutCalendarConnectionInput[];
    updateMany?:
      | MeetingUpdateManyWithWhereWithoutCalendarConnectionInput
      | MeetingUpdateManyWithWhereWithoutCalendarConnectionInput[];
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[];
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRoleFilter<$PrismaModel>;
    _max?: NestedEnumRoleFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole;
  };

  export type NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.MemberRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>;
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedEnumMeetingStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.MeetingStatus
      | EnumMeetingStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.MeetingStatus[]
      | ListEnumMeetingStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MeetingStatus[]
      | ListEnumMeetingStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumMeetingStatusFilter<$PrismaModel> | $Enums.MeetingStatus;
  };

  export type NestedEnumMeetingStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.MeetingStatus
      | EnumMeetingStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.MeetingStatus[]
      | ListEnumMeetingStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MeetingStatus[]
      | ListEnumMeetingStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumMeetingStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.MeetingStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMeetingStatusFilter<$PrismaModel>;
    _max?: NestedEnumMeetingStatusFilter<$PrismaModel>;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedEnumMomentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MomentType | EnumMomentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.MomentType[] | ListEnumMomentTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MomentType[] | ListEnumMomentTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumMomentTypeFilter<$PrismaModel> | $Enums.MomentType;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedEnumMomentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MomentType | EnumMomentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.MomentType[] | ListEnumMomentTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MomentType[] | ListEnumMomentTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumMomentTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.MomentType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMomentTypeFilter<$PrismaModel>;
    _max?: NestedEnumMomentTypeFilter<$PrismaModel>;
  };

  export type NestedEnumMinutesStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.MinutesStatus
      | EnumMinutesStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.MinutesStatus[]
      | ListEnumMinutesStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MinutesStatus[]
      | ListEnumMinutesStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumMinutesStatusFilter<$PrismaModel> | $Enums.MinutesStatus;
  };

  export type NestedEnumMinutesStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.MinutesStatus
      | EnumMinutesStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.MinutesStatus[]
      | ListEnumMinutesStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MinutesStatus[]
      | ListEnumMinutesStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumMinutesStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.MinutesStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMinutesStatusFilter<$PrismaModel>;
    _max?: NestedEnumMinutesStatusFilter<$PrismaModel>;
  };

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationType
      | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationTypeFilter<$PrismaModel>
      | $Enums.NotificationType;
  };

  export type NestedEnumNotificationTypeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.NotificationType
      | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>;
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>;
  };

  export type NestedEnumShareTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareType | EnumShareTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ShareType[] | ListEnumShareTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ShareType[] | ListEnumShareTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumShareTypeFilter<$PrismaModel> | $Enums.ShareType;
  };

  export type NestedEnumShareTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareType | EnumShareTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ShareType[] | ListEnumShareTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ShareType[] | ListEnumShareTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumShareTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.ShareType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumShareTypeFilter<$PrismaModel>;
    _max?: NestedEnumShareTypeFilter<$PrismaModel>;
  };

  export type NestedEnumCalendarProviderFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.CalendarProvider
      | EnumCalendarProviderFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CalendarProvider[]
      | ListEnumCalendarProviderFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CalendarProvider[]
      | ListEnumCalendarProviderFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCalendarProviderFilter<$PrismaModel>
      | $Enums.CalendarProvider;
  };

  export type NestedEnumConnectionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ConnectionStatus
      | EnumConnectionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ConnectionStatus[]
      | ListEnumConnectionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ConnectionStatus[]
      | ListEnumConnectionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumConnectionStatusFilter<$PrismaModel>
      | $Enums.ConnectionStatus;
  };

  export type NestedEnumCalendarProviderWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.CalendarProvider
      | EnumCalendarProviderFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CalendarProvider[]
      | ListEnumCalendarProviderFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CalendarProvider[]
      | ListEnumCalendarProviderFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCalendarProviderWithAggregatesFilter<$PrismaModel>
      | $Enums.CalendarProvider;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCalendarProviderFilter<$PrismaModel>;
    _max?: NestedEnumCalendarProviderFilter<$PrismaModel>;
  };

  export type NestedEnumConnectionStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ConnectionStatus
      | EnumConnectionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ConnectionStatus[]
      | ListEnumConnectionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ConnectionStatus[]
      | ListEnumConnectionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumConnectionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ConnectionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumConnectionStatusFilter<$PrismaModel>;
    _max?: NestedEnumConnectionStatusFilter<$PrismaModel>;
  };

  export type MeetingCreateWithoutUserInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentCreateNestedManyWithoutMeetingInput;
    organization?: OrganizationCreateNestedOneWithoutMeetingsInput;
    calendarConnection?: CalendarConnectionCreateNestedOneWithoutMeetingsInput;
    tags?: MeetingTagCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateWithoutUserInput = {
    id?: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentUncheckedCreateNestedManyWithoutMeetingInput;
    tags?: MeetingTagUncheckedCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesUncheckedCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerUncheckedCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingCreateOrConnectWithoutUserInput = {
    where: MeetingWhereUniqueInput;
    create: XOR<
      MeetingCreateWithoutUserInput,
      MeetingUncheckedCreateWithoutUserInput
    >;
  };

  export type MeetingCreateManyUserInputEnvelope = {
    data: MeetingCreateManyUserInput | MeetingCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type MinutesTemplateCreateWithoutUserInput = {
    id?: string;
    name: string;
    description?: string | null;
    format: string;
    sections: JsonNullValueInput | InputJsonValue;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organization?: OrganizationCreateNestedOneWithoutTemplatesInput;
  };

  export type MinutesTemplateUncheckedCreateWithoutUserInput = {
    id?: string;
    organizationId?: string | null;
    name: string;
    description?: string | null;
    format: string;
    sections: JsonNullValueInput | InputJsonValue;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MinutesTemplateCreateOrConnectWithoutUserInput = {
    where: MinutesTemplateWhereUniqueInput;
    create: XOR<
      MinutesTemplateCreateWithoutUserInput,
      MinutesTemplateUncheckedCreateWithoutUserInput
    >;
  };

  export type MinutesTemplateCreateManyUserInputEnvelope = {
    data:
      | MinutesTemplateCreateManyUserInput
      | MinutesTemplateCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationCreateWithoutUserInput = {
    id?: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    read?: boolean;
    meetingId?: string | null;
    createdAt?: Date | string;
  };

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    read?: boolean;
    meetingId?: string | null;
    createdAt?: Date | string;
  };

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<
      NotificationCreateWithoutUserInput,
      NotificationUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string;
    email?: boolean;
    push?: boolean;
    deviceToken?: string | null;
  };

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string;
    email?: boolean;
    push?: boolean;
    deviceToken?: string | null;
  };

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput;
    create: XOR<
      NotificationPreferenceCreateWithoutUserInput,
      NotificationPreferenceUncheckedCreateWithoutUserInput
    >;
  };

  export type SubscriptionCreateWithoutUserInput = {
    id?: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
    plan: PlanCreateNestedOneWithoutSubscriptionsInput;
    usage?: WeeklyUsageCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string;
    planId: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
    usage?: WeeklyUsageUncheckedCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput;
    create: XOR<
      SubscriptionCreateWithoutUserInput,
      SubscriptionUncheckedCreateWithoutUserInput
    >;
  };

  export type TagCreateWithoutUserInput = {
    id?: string;
    name: string;
    color?: string;
    createdAt?: Date | string;
    meetings?: MeetingTagCreateNestedManyWithoutTagInput;
    organization?: OrganizationCreateNestedOneWithoutTagsInput;
  };

  export type TagUncheckedCreateWithoutUserInput = {
    id?: string;
    organizationId?: string | null;
    name: string;
    color?: string;
    createdAt?: Date | string;
    meetings?: MeetingTagUncheckedCreateNestedManyWithoutTagInput;
  };

  export type TagCreateOrConnectWithoutUserInput = {
    where: TagWhereUniqueInput;
    create: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>;
  };

  export type TagCreateManyUserInputEnvelope = {
    data: TagCreateManyUserInput | TagCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type MembershipCreateWithoutUserInput = {
    id?: string;
    role?: $Enums.MemberRole;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutMembersInput;
  };

  export type MembershipUncheckedCreateWithoutUserInput = {
    id?: string;
    organizationId: string;
    role?: $Enums.MemberRole;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MembershipCreateOrConnectWithoutUserInput = {
    where: MembershipWhereUniqueInput;
    create: XOR<
      MembershipCreateWithoutUserInput,
      MembershipUncheckedCreateWithoutUserInput
    >;
  };

  export type MembershipCreateManyUserInputEnvelope = {
    data: MembershipCreateManyUserInput | MembershipCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type MinutesCreateWithoutReviewerInput = {
    id?: string;
    content: string;
    status?: $Enums.MinutesStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    meeting: MeetingCreateNestedOneWithoutMinutesInput;
    versions?: MinutesVersionCreateNestedManyWithoutMinutesInput;
  };

  export type MinutesUncheckedCreateWithoutReviewerInput = {
    id?: string;
    meetingId: string;
    content: string;
    status?: $Enums.MinutesStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    versions?: MinutesVersionUncheckedCreateNestedManyWithoutMinutesInput;
  };

  export type MinutesCreateOrConnectWithoutReviewerInput = {
    where: MinutesWhereUniqueInput;
    create: XOR<
      MinutesCreateWithoutReviewerInput,
      MinutesUncheckedCreateWithoutReviewerInput
    >;
  };

  export type MinutesCreateManyReviewerInputEnvelope = {
    data: MinutesCreateManyReviewerInput | MinutesCreateManyReviewerInput[];
    skipDuplicates?: boolean;
  };

  export type CalendarConnectionCreateWithoutUserInput = {
    id?: string;
    provider: $Enums.CalendarProvider;
    accessToken: string;
    refreshToken: string;
    expiresAt: Date | string;
    lastSyncAt?: Date | string | null;
    status?: $Enums.ConnectionStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    meetings?: MeetingCreateNestedManyWithoutCalendarConnectionInput;
  };

  export type CalendarConnectionUncheckedCreateWithoutUserInput = {
    id?: string;
    provider: $Enums.CalendarProvider;
    accessToken: string;
    refreshToken: string;
    expiresAt: Date | string;
    lastSyncAt?: Date | string | null;
    status?: $Enums.ConnectionStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    meetings?: MeetingUncheckedCreateNestedManyWithoutCalendarConnectionInput;
  };

  export type CalendarConnectionCreateOrConnectWithoutUserInput = {
    where: CalendarConnectionWhereUniqueInput;
    create: XOR<
      CalendarConnectionCreateWithoutUserInput,
      CalendarConnectionUncheckedCreateWithoutUserInput
    >;
  };

  export type CalendarConnectionCreateManyUserInputEnvelope = {
    data:
      | CalendarConnectionCreateManyUserInput
      | CalendarConnectionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type MeetingUpsertWithWhereUniqueWithoutUserInput = {
    where: MeetingWhereUniqueInput;
    update: XOR<
      MeetingUpdateWithoutUserInput,
      MeetingUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      MeetingCreateWithoutUserInput,
      MeetingUncheckedCreateWithoutUserInput
    >;
  };

  export type MeetingUpdateWithWhereUniqueWithoutUserInput = {
    where: MeetingWhereUniqueInput;
    data: XOR<
      MeetingUpdateWithoutUserInput,
      MeetingUncheckedUpdateWithoutUserInput
    >;
  };

  export type MeetingUpdateManyWithWhereWithoutUserInput = {
    where: MeetingScalarWhereInput;
    data: XOR<
      MeetingUpdateManyMutationInput,
      MeetingUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[];
    OR?: MeetingScalarWhereInput[];
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[];
    id?: StringFilter<'Meeting'> | string;
    userId?: StringFilter<'Meeting'> | string;
    organizationId?: StringNullableFilter<'Meeting'> | string | null;
    calendarConnectionId?: StringNullableFilter<'Meeting'> | string | null;
    title?: StringFilter<'Meeting'> | string;
    originalFileName?: StringFilter<'Meeting'> | string;
    durationSeconds?: IntFilter<'Meeting'> | number;
    fileUrl?: StringNullableFilter<'Meeting'> | string | null;
    status?: EnumMeetingStatusFilter<'Meeting'> | $Enums.MeetingStatus;
    languageCode?: StringNullableFilter<'Meeting'> | string | null;
    transcriptLang?: StringNullableFilter<'Meeting'> | string | null;
    minutesLang?: StringNullableFilter<'Meeting'> | string | null;
    createdAt?: DateTimeFilter<'Meeting'> | Date | string;
    updatedAt?: DateTimeFilter<'Meeting'> | Date | string;
    avgSpeakerConfidence?: FloatNullableFilter<'Meeting'> | number | null;
    inaudibleCount?: IntFilter<'Meeting'> | number;
    qualityScore?: FloatNullableFilter<'Meeting'> | number | null;
    lastProcessedAt?: DateTimeNullableFilter<'Meeting'> | Date | string | null;
  };

  export type MinutesTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: MinutesTemplateWhereUniqueInput;
    update: XOR<
      MinutesTemplateUpdateWithoutUserInput,
      MinutesTemplateUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      MinutesTemplateCreateWithoutUserInput,
      MinutesTemplateUncheckedCreateWithoutUserInput
    >;
  };

  export type MinutesTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: MinutesTemplateWhereUniqueInput;
    data: XOR<
      MinutesTemplateUpdateWithoutUserInput,
      MinutesTemplateUncheckedUpdateWithoutUserInput
    >;
  };

  export type MinutesTemplateUpdateManyWithWhereWithoutUserInput = {
    where: MinutesTemplateScalarWhereInput;
    data: XOR<
      MinutesTemplateUpdateManyMutationInput,
      MinutesTemplateUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type MinutesTemplateScalarWhereInput = {
    AND?: MinutesTemplateScalarWhereInput | MinutesTemplateScalarWhereInput[];
    OR?: MinutesTemplateScalarWhereInput[];
    NOT?: MinutesTemplateScalarWhereInput | MinutesTemplateScalarWhereInput[];
    id?: StringFilter<'MinutesTemplate'> | string;
    userId?: StringFilter<'MinutesTemplate'> | string;
    organizationId?: StringNullableFilter<'MinutesTemplate'> | string | null;
    name?: StringFilter<'MinutesTemplate'> | string;
    description?: StringNullableFilter<'MinutesTemplate'> | string | null;
    format?: StringFilter<'MinutesTemplate'> | string;
    sections?: JsonFilter<'MinutesTemplate'>;
    isDefault?: BoolFilter<'MinutesTemplate'> | boolean;
    createdAt?: DateTimeFilter<'MinutesTemplate'> | Date | string;
    updatedAt?: DateTimeFilter<'MinutesTemplate'> | Date | string;
  };

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<
      NotificationUpdateWithoutUserInput,
      NotificationUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      NotificationCreateWithoutUserInput,
      NotificationUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<
      NotificationUpdateWithoutUserInput,
      NotificationUncheckedUpdateWithoutUserInput
    >;
  };

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput;
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    read?: BoolFilter<'Notification'> | boolean;
    meetingId?: StringNullableFilter<'Notification'> | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
  };

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<
      NotificationPreferenceUpdateWithoutUserInput,
      NotificationPreferenceUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      NotificationPreferenceCreateWithoutUserInput,
      NotificationPreferenceUncheckedCreateWithoutUserInput
    >;
    where?: NotificationPreferenceWhereInput;
  };

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput;
    data: XOR<
      NotificationPreferenceUpdateWithoutUserInput,
      NotificationPreferenceUncheckedUpdateWithoutUserInput
    >;
  };

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: BoolFieldUpdateOperationsInput | boolean;
    push?: BoolFieldUpdateOperationsInput | boolean;
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: BoolFieldUpdateOperationsInput | boolean;
    push?: BoolFieldUpdateOperationsInput | boolean;
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<
      SubscriptionUpdateWithoutUserInput,
      SubscriptionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      SubscriptionCreateWithoutUserInput,
      SubscriptionUncheckedCreateWithoutUserInput
    >;
    where?: SubscriptionWhereInput;
  };

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput;
    data: XOR<
      SubscriptionUpdateWithoutUserInput,
      SubscriptionUncheckedUpdateWithoutUserInput
    >;
  };

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput;
    usage?: WeeklyUsageUpdateManyWithoutSubscriptionNestedInput;
  };

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usage?: WeeklyUsageUncheckedUpdateManyWithoutSubscriptionNestedInput;
  };

  export type TagUpsertWithWhereUniqueWithoutUserInput = {
    where: TagWhereUniqueInput;
    update: XOR<TagUpdateWithoutUserInput, TagUncheckedUpdateWithoutUserInput>;
    create: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>;
  };

  export type TagUpdateWithWhereUniqueWithoutUserInput = {
    where: TagWhereUniqueInput;
    data: XOR<TagUpdateWithoutUserInput, TagUncheckedUpdateWithoutUserInput>;
  };

  export type TagUpdateManyWithWhereWithoutUserInput = {
    where: TagScalarWhereInput;
    data: XOR<
      TagUpdateManyMutationInput,
      TagUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[];
    OR?: TagScalarWhereInput[];
    NOT?: TagScalarWhereInput | TagScalarWhereInput[];
    id?: StringFilter<'Tag'> | string;
    userId?: StringFilter<'Tag'> | string;
    organizationId?: StringNullableFilter<'Tag'> | string | null;
    name?: StringFilter<'Tag'> | string;
    color?: StringFilter<'Tag'> | string;
    createdAt?: DateTimeFilter<'Tag'> | Date | string;
  };

  export type MembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput;
    update: XOR<
      MembershipUpdateWithoutUserInput,
      MembershipUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      MembershipCreateWithoutUserInput,
      MembershipUncheckedCreateWithoutUserInput
    >;
  };

  export type MembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput;
    data: XOR<
      MembershipUpdateWithoutUserInput,
      MembershipUncheckedUpdateWithoutUserInput
    >;
  };

  export type MembershipUpdateManyWithWhereWithoutUserInput = {
    where: MembershipScalarWhereInput;
    data: XOR<
      MembershipUpdateManyMutationInput,
      MembershipUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type MembershipScalarWhereInput = {
    AND?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
    OR?: MembershipScalarWhereInput[];
    NOT?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
    id?: StringFilter<'Membership'> | string;
    userId?: StringFilter<'Membership'> | string;
    organizationId?: StringFilter<'Membership'> | string;
    role?: EnumMemberRoleFilter<'Membership'> | $Enums.MemberRole;
    createdAt?: DateTimeFilter<'Membership'> | Date | string;
    updatedAt?: DateTimeFilter<'Membership'> | Date | string;
  };

  export type MinutesUpsertWithWhereUniqueWithoutReviewerInput = {
    where: MinutesWhereUniqueInput;
    update: XOR<
      MinutesUpdateWithoutReviewerInput,
      MinutesUncheckedUpdateWithoutReviewerInput
    >;
    create: XOR<
      MinutesCreateWithoutReviewerInput,
      MinutesUncheckedCreateWithoutReviewerInput
    >;
  };

  export type MinutesUpdateWithWhereUniqueWithoutReviewerInput = {
    where: MinutesWhereUniqueInput;
    data: XOR<
      MinutesUpdateWithoutReviewerInput,
      MinutesUncheckedUpdateWithoutReviewerInput
    >;
  };

  export type MinutesUpdateManyWithWhereWithoutReviewerInput = {
    where: MinutesScalarWhereInput;
    data: XOR<
      MinutesUpdateManyMutationInput,
      MinutesUncheckedUpdateManyWithoutReviewerInput
    >;
  };

  export type MinutesScalarWhereInput = {
    AND?: MinutesScalarWhereInput | MinutesScalarWhereInput[];
    OR?: MinutesScalarWhereInput[];
    NOT?: MinutesScalarWhereInput | MinutesScalarWhereInput[];
    id?: StringFilter<'Minutes'> | string;
    meetingId?: StringFilter<'Minutes'> | string;
    content?: StringFilter<'Minutes'> | string;
    status?: EnumMinutesStatusFilter<'Minutes'> | $Enums.MinutesStatus;
    reviewerId?: StringNullableFilter<'Minutes'> | string | null;
    createdAt?: DateTimeFilter<'Minutes'> | Date | string;
    updatedAt?: DateTimeFilter<'Minutes'> | Date | string;
  };

  export type CalendarConnectionUpsertWithWhereUniqueWithoutUserInput = {
    where: CalendarConnectionWhereUniqueInput;
    update: XOR<
      CalendarConnectionUpdateWithoutUserInput,
      CalendarConnectionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      CalendarConnectionCreateWithoutUserInput,
      CalendarConnectionUncheckedCreateWithoutUserInput
    >;
  };

  export type CalendarConnectionUpdateWithWhereUniqueWithoutUserInput = {
    where: CalendarConnectionWhereUniqueInput;
    data: XOR<
      CalendarConnectionUpdateWithoutUserInput,
      CalendarConnectionUncheckedUpdateWithoutUserInput
    >;
  };

  export type CalendarConnectionUpdateManyWithWhereWithoutUserInput = {
    where: CalendarConnectionScalarWhereInput;
    data: XOR<
      CalendarConnectionUpdateManyMutationInput,
      CalendarConnectionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type CalendarConnectionScalarWhereInput = {
    AND?:
      | CalendarConnectionScalarWhereInput
      | CalendarConnectionScalarWhereInput[];
    OR?: CalendarConnectionScalarWhereInput[];
    NOT?:
      | CalendarConnectionScalarWhereInput
      | CalendarConnectionScalarWhereInput[];
    id?: StringFilter<'CalendarConnection'> | string;
    userId?: StringFilter<'CalendarConnection'> | string;
    provider?:
      | EnumCalendarProviderFilter<'CalendarConnection'>
      | $Enums.CalendarProvider;
    accessToken?: StringFilter<'CalendarConnection'> | string;
    refreshToken?: StringFilter<'CalendarConnection'> | string;
    expiresAt?: DateTimeFilter<'CalendarConnection'> | Date | string;
    lastSyncAt?:
      | DateTimeNullableFilter<'CalendarConnection'>
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFilter<'CalendarConnection'>
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFilter<'CalendarConnection'> | Date | string;
    updatedAt?: DateTimeFilter<'CalendarConnection'> | Date | string;
  };

  export type MembershipCreateWithoutOrganizationInput = {
    id?: string;
    role?: $Enums.MemberRole;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutMembershipsInput;
  };

  export type MembershipUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    userId: string;
    role?: $Enums.MemberRole;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MembershipCreateOrConnectWithoutOrganizationInput = {
    where: MembershipWhereUniqueInput;
    create: XOR<
      MembershipCreateWithoutOrganizationInput,
      MembershipUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MembershipCreateManyOrganizationInputEnvelope = {
    data:
      | MembershipCreateManyOrganizationInput
      | MembershipCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type MeetingCreateWithoutOrganizationInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentCreateNestedManyWithoutMeetingInput;
    user: UserCreateNestedOneWithoutMeetingsInput;
    calendarConnection?: CalendarConnectionCreateNestedOneWithoutMeetingsInput;
    tags?: MeetingTagCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    userId: string;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentUncheckedCreateNestedManyWithoutMeetingInput;
    tags?: MeetingTagUncheckedCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesUncheckedCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerUncheckedCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingCreateOrConnectWithoutOrganizationInput = {
    where: MeetingWhereUniqueInput;
    create: XOR<
      MeetingCreateWithoutOrganizationInput,
      MeetingUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MeetingCreateManyOrganizationInputEnvelope = {
    data:
      | MeetingCreateManyOrganizationInput
      | MeetingCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type MinutesTemplateCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    format: string;
    sections: JsonNullValueInput | InputJsonValue;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutTemplatesInput;
  };

  export type MinutesTemplateUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    userId: string;
    name: string;
    description?: string | null;
    format: string;
    sections: JsonNullValueInput | InputJsonValue;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MinutesTemplateCreateOrConnectWithoutOrganizationInput = {
    where: MinutesTemplateWhereUniqueInput;
    create: XOR<
      MinutesTemplateCreateWithoutOrganizationInput,
      MinutesTemplateUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MinutesTemplateCreateManyOrganizationInputEnvelope = {
    data:
      | MinutesTemplateCreateManyOrganizationInput
      | MinutesTemplateCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type TagCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    color?: string;
    createdAt?: Date | string;
    meetings?: MeetingTagCreateNestedManyWithoutTagInput;
    user: UserCreateNestedOneWithoutTagsInput;
  };

  export type TagUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    userId: string;
    name: string;
    color?: string;
    createdAt?: Date | string;
    meetings?: MeetingTagUncheckedCreateNestedManyWithoutTagInput;
  };

  export type TagCreateOrConnectWithoutOrganizationInput = {
    where: TagWhereUniqueInput;
    create: XOR<
      TagCreateWithoutOrganizationInput,
      TagUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type TagCreateManyOrganizationInputEnvelope = {
    data: TagCreateManyOrganizationInput | TagCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type MembershipUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MembershipWhereUniqueInput;
    update: XOR<
      MembershipUpdateWithoutOrganizationInput,
      MembershipUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      MembershipCreateWithoutOrganizationInput,
      MembershipUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MembershipUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MembershipWhereUniqueInput;
    data: XOR<
      MembershipUpdateWithoutOrganizationInput,
      MembershipUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type MembershipUpdateManyWithWhereWithoutOrganizationInput = {
    where: MembershipScalarWhereInput;
    data: XOR<
      MembershipUpdateManyMutationInput,
      MembershipUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type MeetingUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MeetingWhereUniqueInput;
    update: XOR<
      MeetingUpdateWithoutOrganizationInput,
      MeetingUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      MeetingCreateWithoutOrganizationInput,
      MeetingUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MeetingUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MeetingWhereUniqueInput;
    data: XOR<
      MeetingUpdateWithoutOrganizationInput,
      MeetingUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type MeetingUpdateManyWithWhereWithoutOrganizationInput = {
    where: MeetingScalarWhereInput;
    data: XOR<
      MeetingUpdateManyMutationInput,
      MeetingUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type MinutesTemplateUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MinutesTemplateWhereUniqueInput;
    update: XOR<
      MinutesTemplateUpdateWithoutOrganizationInput,
      MinutesTemplateUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      MinutesTemplateCreateWithoutOrganizationInput,
      MinutesTemplateUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MinutesTemplateUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MinutesTemplateWhereUniqueInput;
    data: XOR<
      MinutesTemplateUpdateWithoutOrganizationInput,
      MinutesTemplateUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type MinutesTemplateUpdateManyWithWhereWithoutOrganizationInput = {
    where: MinutesTemplateScalarWhereInput;
    data: XOR<
      MinutesTemplateUpdateManyMutationInput,
      MinutesTemplateUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type TagUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TagWhereUniqueInput;
    update: XOR<
      TagUpdateWithoutOrganizationInput,
      TagUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      TagCreateWithoutOrganizationInput,
      TagUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type TagUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TagWhereUniqueInput;
    data: XOR<
      TagUpdateWithoutOrganizationInput,
      TagUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type TagUpdateManyWithWhereWithoutOrganizationInput = {
    where: TagScalarWhereInput;
    data: XOR<
      TagUpdateManyMutationInput,
      TagUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type UserCreateWithoutMembershipsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionCreateNestedOneWithoutUserInput;
    tags?: TagCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput;
    tags?: TagUncheckedCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesUncheckedCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutMembershipsInput,
      UserUncheckedCreateWithoutMembershipsInput
    >;
  };

  export type OrganizationCreateWithoutMembersInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput;
    templates?: MinutesTemplateCreateNestedManyWithoutOrganizationInput;
    tags?: TagCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutOrganizationInput;
    tags?: TagUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutMembersInput,
      OrganizationUncheckedCreateWithoutMembersInput
    >;
  };

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<
      UserUpdateWithoutMembershipsInput,
      UserUncheckedUpdateWithoutMembershipsInput
    >;
    create: XOR<
      UserCreateWithoutMembershipsInput,
      UserUncheckedCreateWithoutMembershipsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutMembershipsInput,
      UserUncheckedUpdateWithoutMembershipsInput
    >;
  };

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput;
    tags?: TagUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput;
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUncheckedUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<
      OrganizationUpdateWithoutMembersInput,
      OrganizationUncheckedUpdateWithoutMembersInput
    >;
    create: XOR<
      OrganizationCreateWithoutMembersInput,
      OrganizationUncheckedCreateWithoutMembersInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutMembersInput,
      OrganizationUncheckedUpdateWithoutMembersInput
    >;
  };

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutOrganizationNestedInput;
    tags?: TagUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutOrganizationNestedInput;
    tags?: TagUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserCreateWithoutTemplatesInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionCreateNestedOneWithoutUserInput;
    tags?: TagCreateNestedManyWithoutUserInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTemplatesInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput;
    tags?: TagUncheckedCreateNestedManyWithoutUserInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesUncheckedCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTemplatesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTemplatesInput,
      UserUncheckedCreateWithoutTemplatesInput
    >;
  };

  export type OrganizationCreateWithoutTemplatesInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    members?: MembershipCreateNestedManyWithoutOrganizationInput;
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput;
    tags?: TagCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutTemplatesInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    members?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput;
    tags?: TagUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutTemplatesInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutTemplatesInput,
      OrganizationUncheckedCreateWithoutTemplatesInput
    >;
  };

  export type UserUpsertWithoutTemplatesInput = {
    update: XOR<
      UserUpdateWithoutTemplatesInput,
      UserUncheckedUpdateWithoutTemplatesInput
    >;
    create: XOR<
      UserCreateWithoutTemplatesInput,
      UserUncheckedCreateWithoutTemplatesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTemplatesInput,
      UserUncheckedUpdateWithoutTemplatesInput
    >;
  };

  export type UserUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput;
    tags?: TagUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput;
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUncheckedUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutTemplatesInput = {
    update: XOR<
      OrganizationUpdateWithoutTemplatesInput,
      OrganizationUncheckedUpdateWithoutTemplatesInput
    >;
    create: XOR<
      OrganizationCreateWithoutTemplatesInput,
      OrganizationUncheckedCreateWithoutTemplatesInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutTemplatesInput,
      OrganizationUncheckedUpdateWithoutTemplatesInput
    >;
  };

  export type OrganizationUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    members?: MembershipUpdateManyWithoutOrganizationNestedInput;
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput;
    tags?: TagUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    members?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput;
    tags?: TagUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
    user: UserCreateNestedOneWithoutSubscriptionInput;
    usage?: WeeklyUsageCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string;
    userId: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
    usage?: WeeklyUsageUncheckedCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput;
    create: XOR<
      SubscriptionCreateWithoutPlanInput,
      SubscriptionUncheckedCreateWithoutPlanInput
    >;
  };

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[];
    skipDuplicates?: boolean;
  };

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput;
    update: XOR<
      SubscriptionUpdateWithoutPlanInput,
      SubscriptionUncheckedUpdateWithoutPlanInput
    >;
    create: XOR<
      SubscriptionCreateWithoutPlanInput,
      SubscriptionUncheckedCreateWithoutPlanInput
    >;
  };

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput;
    data: XOR<
      SubscriptionUpdateWithoutPlanInput,
      SubscriptionUncheckedUpdateWithoutPlanInput
    >;
  };

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput;
    data: XOR<
      SubscriptionUpdateManyMutationInput,
      SubscriptionUncheckedUpdateManyWithoutPlanInput
    >;
  };

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[];
    OR?: SubscriptionScalarWhereInput[];
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[];
    id?: StringFilter<'Subscription'> | string;
    userId?: StringFilter<'Subscription'> | string;
    planId?: StringFilter<'Subscription'> | string;
    active?: BoolFilter<'Subscription'> | boolean;
    startsAt?: DateTimeFilter<'Subscription'> | Date | string;
    endsAt?: DateTimeNullableFilter<'Subscription'> | Date | string | null;
  };

  export type PlanCreateWithoutSubscriptionsInput = {
    id?: string;
    name: string;
    maxMinutesPerUpload?: number;
    maxUploadsPerWeek?: number;
    monthlyMinutesLimit?: number;
    price?: Decimal | DecimalJsLike | number | string;
    currency?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string;
    name: string;
    maxMinutesPerUpload?: number;
    maxUploadsPerWeek?: number;
    monthlyMinutesLimit?: number;
    price?: Decimal | DecimalJsLike | number | string;
    currency?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PlanCreateOrConnectWithoutSubscriptionsInput = {
    where: PlanWhereUniqueInput;
    create: XOR<
      PlanCreateWithoutSubscriptionsInput,
      PlanUncheckedCreateWithoutSubscriptionsInput
    >;
  };

  export type UserCreateWithoutSubscriptionInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceCreateNestedOneWithoutUserInput;
    tags?: TagCreateNestedManyWithoutUserInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput;
    tags?: TagUncheckedCreateNestedManyWithoutUserInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesUncheckedCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSubscriptionInput,
      UserUncheckedCreateWithoutSubscriptionInput
    >;
  };

  export type WeeklyUsageCreateWithoutSubscriptionInput = {
    id?: string;
    weekStartDate: Date | string;
    uploadCount?: number;
    minutesProcessed?: number;
  };

  export type WeeklyUsageUncheckedCreateWithoutSubscriptionInput = {
    id?: string;
    weekStartDate: Date | string;
    uploadCount?: number;
    minutesProcessed?: number;
  };

  export type WeeklyUsageCreateOrConnectWithoutSubscriptionInput = {
    where: WeeklyUsageWhereUniqueInput;
    create: XOR<
      WeeklyUsageCreateWithoutSubscriptionInput,
      WeeklyUsageUncheckedCreateWithoutSubscriptionInput
    >;
  };

  export type WeeklyUsageCreateManySubscriptionInputEnvelope = {
    data:
      | WeeklyUsageCreateManySubscriptionInput
      | WeeklyUsageCreateManySubscriptionInput[];
    skipDuplicates?: boolean;
  };

  export type PlanUpsertWithoutSubscriptionsInput = {
    update: XOR<
      PlanUpdateWithoutSubscriptionsInput,
      PlanUncheckedUpdateWithoutSubscriptionsInput
    >;
    create: XOR<
      PlanCreateWithoutSubscriptionsInput,
      PlanUncheckedCreateWithoutSubscriptionsInput
    >;
    where?: PlanWhereInput;
  };

  export type PlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PlanWhereInput;
    data: XOR<
      PlanUpdateWithoutSubscriptionsInput,
      PlanUncheckedUpdateWithoutSubscriptionsInput
    >;
  };

  export type PlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    maxMinutesPerUpload?: IntFieldUpdateOperationsInput | number;
    maxUploadsPerWeek?: IntFieldUpdateOperationsInput | number;
    monthlyMinutesLimit?: IntFieldUpdateOperationsInput | number;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    maxMinutesPerUpload?: IntFieldUpdateOperationsInput | number;
    maxUploadsPerWeek?: IntFieldUpdateOperationsInput | number;
    monthlyMinutesLimit?: IntFieldUpdateOperationsInput | number;
    price?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    currency?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<
      UserUpdateWithoutSubscriptionInput,
      UserUncheckedUpdateWithoutSubscriptionInput
    >;
    create: XOR<
      UserCreateWithoutSubscriptionInput,
      UserUncheckedCreateWithoutSubscriptionInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSubscriptionInput,
      UserUncheckedUpdateWithoutSubscriptionInput
    >;
  };

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUpdateOneWithoutUserNestedInput;
    tags?: TagUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput;
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUncheckedUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type WeeklyUsageUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: WeeklyUsageWhereUniqueInput;
    update: XOR<
      WeeklyUsageUpdateWithoutSubscriptionInput,
      WeeklyUsageUncheckedUpdateWithoutSubscriptionInput
    >;
    create: XOR<
      WeeklyUsageCreateWithoutSubscriptionInput,
      WeeklyUsageUncheckedCreateWithoutSubscriptionInput
    >;
  };

  export type WeeklyUsageUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: WeeklyUsageWhereUniqueInput;
    data: XOR<
      WeeklyUsageUpdateWithoutSubscriptionInput,
      WeeklyUsageUncheckedUpdateWithoutSubscriptionInput
    >;
  };

  export type WeeklyUsageUpdateManyWithWhereWithoutSubscriptionInput = {
    where: WeeklyUsageScalarWhereInput;
    data: XOR<
      WeeklyUsageUpdateManyMutationInput,
      WeeklyUsageUncheckedUpdateManyWithoutSubscriptionInput
    >;
  };

  export type WeeklyUsageScalarWhereInput = {
    AND?: WeeklyUsageScalarWhereInput | WeeklyUsageScalarWhereInput[];
    OR?: WeeklyUsageScalarWhereInput[];
    NOT?: WeeklyUsageScalarWhereInput | WeeklyUsageScalarWhereInput[];
    id?: StringFilter<'WeeklyUsage'> | string;
    subscriptionId?: StringFilter<'WeeklyUsage'> | string;
    weekStartDate?: DateTimeFilter<'WeeklyUsage'> | Date | string;
    uploadCount?: IntFilter<'WeeklyUsage'> | number;
    minutesProcessed?: IntFilter<'WeeklyUsage'> | number;
  };

  export type SubscriptionCreateWithoutUsageInput = {
    id?: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
    plan: PlanCreateNestedOneWithoutSubscriptionsInput;
    user: UserCreateNestedOneWithoutSubscriptionInput;
  };

  export type SubscriptionUncheckedCreateWithoutUsageInput = {
    id?: string;
    userId: string;
    planId: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
  };

  export type SubscriptionCreateOrConnectWithoutUsageInput = {
    where: SubscriptionWhereUniqueInput;
    create: XOR<
      SubscriptionCreateWithoutUsageInput,
      SubscriptionUncheckedCreateWithoutUsageInput
    >;
  };

  export type SubscriptionUpsertWithoutUsageInput = {
    update: XOR<
      SubscriptionUpdateWithoutUsageInput,
      SubscriptionUncheckedUpdateWithoutUsageInput
    >;
    create: XOR<
      SubscriptionCreateWithoutUsageInput,
      SubscriptionUncheckedCreateWithoutUsageInput
    >;
    where?: SubscriptionWhereInput;
  };

  export type SubscriptionUpdateToOneWithWhereWithoutUsageInput = {
    where?: SubscriptionWhereInput;
    data: XOR<
      SubscriptionUpdateWithoutUsageInput,
      SubscriptionUncheckedUpdateWithoutUsageInput
    >;
  };

  export type SubscriptionUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput;
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput;
  };

  export type SubscriptionUncheckedUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type KeyMomentCreateWithoutMeetingInput = {
    id?: string;
    timestamp: number;
    label: string;
    description?: string | null;
    type?: $Enums.MomentType;
    isAutomatic?: boolean;
    createdBy?: string | null;
    createdAt?: Date | string;
  };

  export type KeyMomentUncheckedCreateWithoutMeetingInput = {
    id?: string;
    timestamp: number;
    label: string;
    description?: string | null;
    type?: $Enums.MomentType;
    isAutomatic?: boolean;
    createdBy?: string | null;
    createdAt?: Date | string;
  };

  export type KeyMomentCreateOrConnectWithoutMeetingInput = {
    where: KeyMomentWhereUniqueInput;
    create: XOR<
      KeyMomentCreateWithoutMeetingInput,
      KeyMomentUncheckedCreateWithoutMeetingInput
    >;
  };

  export type KeyMomentCreateManyMeetingInputEnvelope = {
    data: KeyMomentCreateManyMeetingInput | KeyMomentCreateManyMeetingInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutMeetingsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    templates?: MinutesTemplateCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionCreateNestedOneWithoutUserInput;
    tags?: TagCreateNestedManyWithoutUserInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutMeetingsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput;
    tags?: TagUncheckedCreateNestedManyWithoutUserInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesUncheckedCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutMeetingsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutMeetingsInput,
      UserUncheckedCreateWithoutMeetingsInput
    >;
  };

  export type OrganizationCreateWithoutMeetingsInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    members?: MembershipCreateNestedManyWithoutOrganizationInput;
    templates?: MinutesTemplateCreateNestedManyWithoutOrganizationInput;
    tags?: TagCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutMeetingsInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    members?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutOrganizationInput;
    tags?: TagUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutMeetingsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutMeetingsInput,
      OrganizationUncheckedCreateWithoutMeetingsInput
    >;
  };

  export type CalendarConnectionCreateWithoutMeetingsInput = {
    id?: string;
    provider: $Enums.CalendarProvider;
    accessToken: string;
    refreshToken: string;
    expiresAt: Date | string;
    lastSyncAt?: Date | string | null;
    status?: $Enums.ConnectionStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutCalendarConnectionsInput;
  };

  export type CalendarConnectionUncheckedCreateWithoutMeetingsInput = {
    id?: string;
    userId: string;
    provider: $Enums.CalendarProvider;
    accessToken: string;
    refreshToken: string;
    expiresAt: Date | string;
    lastSyncAt?: Date | string | null;
    status?: $Enums.ConnectionStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CalendarConnectionCreateOrConnectWithoutMeetingsInput = {
    where: CalendarConnectionWhereUniqueInput;
    create: XOR<
      CalendarConnectionCreateWithoutMeetingsInput,
      CalendarConnectionUncheckedCreateWithoutMeetingsInput
    >;
  };

  export type MeetingTagCreateWithoutMeetingInput = {
    id?: string;
    createdAt?: Date | string;
    tag: TagCreateNestedOneWithoutMeetingsInput;
  };

  export type MeetingTagUncheckedCreateWithoutMeetingInput = {
    id?: string;
    tagId: string;
    createdAt?: Date | string;
  };

  export type MeetingTagCreateOrConnectWithoutMeetingInput = {
    where: MeetingTagWhereUniqueInput;
    create: XOR<
      MeetingTagCreateWithoutMeetingInput,
      MeetingTagUncheckedCreateWithoutMeetingInput
    >;
  };

  export type MeetingTagCreateManyMeetingInputEnvelope = {
    data: MeetingTagCreateManyMeetingInput | MeetingTagCreateManyMeetingInput[];
    skipDuplicates?: boolean;
  };

  export type MinutesCreateWithoutMeetingInput = {
    id?: string;
    content: string;
    status?: $Enums.MinutesStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    reviewer?: UserCreateNestedOneWithoutReviewedMinutesInput;
    versions?: MinutesVersionCreateNestedManyWithoutMinutesInput;
  };

  export type MinutesUncheckedCreateWithoutMeetingInput = {
    id?: string;
    content: string;
    status?: $Enums.MinutesStatus;
    reviewerId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    versions?: MinutesVersionUncheckedCreateNestedManyWithoutMinutesInput;
  };

  export type MinutesCreateOrConnectWithoutMeetingInput = {
    where: MinutesWhereUniqueInput;
    create: XOR<
      MinutesCreateWithoutMeetingInput,
      MinutesUncheckedCreateWithoutMeetingInput
    >;
  };

  export type ShareLinkCreateWithoutMeetingInput = {
    id?: string;
    token: string;
    expiresAt?: Date | string | null;
    shareType?: $Enums.ShareType;
    createdAt?: Date | string;
  };

  export type ShareLinkUncheckedCreateWithoutMeetingInput = {
    id?: string;
    token: string;
    expiresAt?: Date | string | null;
    shareType?: $Enums.ShareType;
    createdAt?: Date | string;
  };

  export type ShareLinkCreateOrConnectWithoutMeetingInput = {
    where: ShareLinkWhereUniqueInput;
    create: XOR<
      ShareLinkCreateWithoutMeetingInput,
      ShareLinkUncheckedCreateWithoutMeetingInput
    >;
  };

  export type ShareLinkCreateManyMeetingInputEnvelope = {
    data: ShareLinkCreateManyMeetingInput | ShareLinkCreateManyMeetingInput[];
    skipDuplicates?: boolean;
  };

  export type SpeakerCreateWithoutMeetingInput = {
    id?: string;
    name: string;
    isUnknown?: boolean;
    isConfirmed?: boolean;
    nameConfidence?: number;
    segments?: TranscriptSegmentCreateNestedManyWithoutSpeakerInput;
  };

  export type SpeakerUncheckedCreateWithoutMeetingInput = {
    id?: string;
    name: string;
    isUnknown?: boolean;
    isConfirmed?: boolean;
    nameConfidence?: number;
    segments?: TranscriptSegmentUncheckedCreateNestedManyWithoutSpeakerInput;
  };

  export type SpeakerCreateOrConnectWithoutMeetingInput = {
    where: SpeakerWhereUniqueInput;
    create: XOR<
      SpeakerCreateWithoutMeetingInput,
      SpeakerUncheckedCreateWithoutMeetingInput
    >;
  };

  export type SpeakerCreateManyMeetingInputEnvelope = {
    data: SpeakerCreateManyMeetingInput | SpeakerCreateManyMeetingInput[];
    skipDuplicates?: boolean;
  };

  export type TranscriptSegmentCreateWithoutMeetingInput = {
    id?: string;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    edits?: SegmentEditCreateNestedManyWithoutSegmentInput;
    corrections?: TranscriptCorrectionCreateNestedManyWithoutSegmentInput;
    speaker?: SpeakerCreateNestedOneWithoutSegmentsInput;
  };

  export type TranscriptSegmentUncheckedCreateWithoutMeetingInput = {
    id?: string;
    speakerId?: string | null;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    edits?: SegmentEditUncheckedCreateNestedManyWithoutSegmentInput;
    corrections?: TranscriptCorrectionUncheckedCreateNestedManyWithoutSegmentInput;
  };

  export type TranscriptSegmentCreateOrConnectWithoutMeetingInput = {
    where: TranscriptSegmentWhereUniqueInput;
    create: XOR<
      TranscriptSegmentCreateWithoutMeetingInput,
      TranscriptSegmentUncheckedCreateWithoutMeetingInput
    >;
  };

  export type TranscriptSegmentCreateManyMeetingInputEnvelope = {
    data:
      | TranscriptSegmentCreateManyMeetingInput
      | TranscriptSegmentCreateManyMeetingInput[];
    skipDuplicates?: boolean;
  };

  export type KeyMomentUpsertWithWhereUniqueWithoutMeetingInput = {
    where: KeyMomentWhereUniqueInput;
    update: XOR<
      KeyMomentUpdateWithoutMeetingInput,
      KeyMomentUncheckedUpdateWithoutMeetingInput
    >;
    create: XOR<
      KeyMomentCreateWithoutMeetingInput,
      KeyMomentUncheckedCreateWithoutMeetingInput
    >;
  };

  export type KeyMomentUpdateWithWhereUniqueWithoutMeetingInput = {
    where: KeyMomentWhereUniqueInput;
    data: XOR<
      KeyMomentUpdateWithoutMeetingInput,
      KeyMomentUncheckedUpdateWithoutMeetingInput
    >;
  };

  export type KeyMomentUpdateManyWithWhereWithoutMeetingInput = {
    where: KeyMomentScalarWhereInput;
    data: XOR<
      KeyMomentUpdateManyMutationInput,
      KeyMomentUncheckedUpdateManyWithoutMeetingInput
    >;
  };

  export type KeyMomentScalarWhereInput = {
    AND?: KeyMomentScalarWhereInput | KeyMomentScalarWhereInput[];
    OR?: KeyMomentScalarWhereInput[];
    NOT?: KeyMomentScalarWhereInput | KeyMomentScalarWhereInput[];
    id?: StringFilter<'KeyMoment'> | string;
    meetingId?: StringFilter<'KeyMoment'> | string;
    timestamp?: FloatFilter<'KeyMoment'> | number;
    label?: StringFilter<'KeyMoment'> | string;
    description?: StringNullableFilter<'KeyMoment'> | string | null;
    type?: EnumMomentTypeFilter<'KeyMoment'> | $Enums.MomentType;
    isAutomatic?: BoolFilter<'KeyMoment'> | boolean;
    createdBy?: StringNullableFilter<'KeyMoment'> | string | null;
    createdAt?: DateTimeFilter<'KeyMoment'> | Date | string;
  };

  export type UserUpsertWithoutMeetingsInput = {
    update: XOR<
      UserUpdateWithoutMeetingsInput,
      UserUncheckedUpdateWithoutMeetingsInput
    >;
    create: XOR<
      UserCreateWithoutMeetingsInput,
      UserUncheckedCreateWithoutMeetingsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutMeetingsInput,
      UserUncheckedUpdateWithoutMeetingsInput
    >;
  };

  export type UserUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    templates?: MinutesTemplateUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput;
    tags?: TagUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput;
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUncheckedUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutMeetingsInput = {
    update: XOR<
      OrganizationUpdateWithoutMeetingsInput,
      OrganizationUncheckedUpdateWithoutMeetingsInput
    >;
    create: XOR<
      OrganizationCreateWithoutMeetingsInput,
      OrganizationUncheckedCreateWithoutMeetingsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutMeetingsInput,
      OrganizationUncheckedUpdateWithoutMeetingsInput
    >;
  };

  export type OrganizationUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    members?: MembershipUpdateManyWithoutOrganizationNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutOrganizationNestedInput;
    tags?: TagUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    members?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutOrganizationNestedInput;
    tags?: TagUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type CalendarConnectionUpsertWithoutMeetingsInput = {
    update: XOR<
      CalendarConnectionUpdateWithoutMeetingsInput,
      CalendarConnectionUncheckedUpdateWithoutMeetingsInput
    >;
    create: XOR<
      CalendarConnectionCreateWithoutMeetingsInput,
      CalendarConnectionUncheckedCreateWithoutMeetingsInput
    >;
    where?: CalendarConnectionWhereInput;
  };

  export type CalendarConnectionUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: CalendarConnectionWhereInput;
    data: XOR<
      CalendarConnectionUpdateWithoutMeetingsInput,
      CalendarConnectionUncheckedUpdateWithoutMeetingsInput
    >;
  };

  export type CalendarConnectionUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?:
      | EnumCalendarProviderFieldUpdateOperationsInput
      | $Enums.CalendarProvider;
    accessToken?: StringFieldUpdateOperationsInput | string;
    refreshToken?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastSyncAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFieldUpdateOperationsInput
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCalendarConnectionsNestedInput;
  };

  export type CalendarConnectionUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    provider?:
      | EnumCalendarProviderFieldUpdateOperationsInput
      | $Enums.CalendarProvider;
    accessToken?: StringFieldUpdateOperationsInput | string;
    refreshToken?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastSyncAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFieldUpdateOperationsInput
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingTagUpsertWithWhereUniqueWithoutMeetingInput = {
    where: MeetingTagWhereUniqueInput;
    update: XOR<
      MeetingTagUpdateWithoutMeetingInput,
      MeetingTagUncheckedUpdateWithoutMeetingInput
    >;
    create: XOR<
      MeetingTagCreateWithoutMeetingInput,
      MeetingTagUncheckedCreateWithoutMeetingInput
    >;
  };

  export type MeetingTagUpdateWithWhereUniqueWithoutMeetingInput = {
    where: MeetingTagWhereUniqueInput;
    data: XOR<
      MeetingTagUpdateWithoutMeetingInput,
      MeetingTagUncheckedUpdateWithoutMeetingInput
    >;
  };

  export type MeetingTagUpdateManyWithWhereWithoutMeetingInput = {
    where: MeetingTagScalarWhereInput;
    data: XOR<
      MeetingTagUpdateManyMutationInput,
      MeetingTagUncheckedUpdateManyWithoutMeetingInput
    >;
  };

  export type MeetingTagScalarWhereInput = {
    AND?: MeetingTagScalarWhereInput | MeetingTagScalarWhereInput[];
    OR?: MeetingTagScalarWhereInput[];
    NOT?: MeetingTagScalarWhereInput | MeetingTagScalarWhereInput[];
    id?: StringFilter<'MeetingTag'> | string;
    meetingId?: StringFilter<'MeetingTag'> | string;
    tagId?: StringFilter<'MeetingTag'> | string;
    createdAt?: DateTimeFilter<'MeetingTag'> | Date | string;
  };

  export type MinutesUpsertWithoutMeetingInput = {
    update: XOR<
      MinutesUpdateWithoutMeetingInput,
      MinutesUncheckedUpdateWithoutMeetingInput
    >;
    create: XOR<
      MinutesCreateWithoutMeetingInput,
      MinutesUncheckedCreateWithoutMeetingInput
    >;
    where?: MinutesWhereInput;
  };

  export type MinutesUpdateToOneWithWhereWithoutMeetingInput = {
    where?: MinutesWhereInput;
    data: XOR<
      MinutesUpdateWithoutMeetingInput,
      MinutesUncheckedUpdateWithoutMeetingInput
    >;
  };

  export type MinutesUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewer?: UserUpdateOneWithoutReviewedMinutesNestedInput;
    versions?: MinutesVersionUpdateManyWithoutMinutesNestedInput;
  };

  export type MinutesUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    versions?: MinutesVersionUncheckedUpdateManyWithoutMinutesNestedInput;
  };

  export type ShareLinkUpsertWithWhereUniqueWithoutMeetingInput = {
    where: ShareLinkWhereUniqueInput;
    update: XOR<
      ShareLinkUpdateWithoutMeetingInput,
      ShareLinkUncheckedUpdateWithoutMeetingInput
    >;
    create: XOR<
      ShareLinkCreateWithoutMeetingInput,
      ShareLinkUncheckedCreateWithoutMeetingInput
    >;
  };

  export type ShareLinkUpdateWithWhereUniqueWithoutMeetingInput = {
    where: ShareLinkWhereUniqueInput;
    data: XOR<
      ShareLinkUpdateWithoutMeetingInput,
      ShareLinkUncheckedUpdateWithoutMeetingInput
    >;
  };

  export type ShareLinkUpdateManyWithWhereWithoutMeetingInput = {
    where: ShareLinkScalarWhereInput;
    data: XOR<
      ShareLinkUpdateManyMutationInput,
      ShareLinkUncheckedUpdateManyWithoutMeetingInput
    >;
  };

  export type ShareLinkScalarWhereInput = {
    AND?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[];
    OR?: ShareLinkScalarWhereInput[];
    NOT?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[];
    id?: StringFilter<'ShareLink'> | string;
    meetingId?: StringFilter<'ShareLink'> | string;
    token?: StringFilter<'ShareLink'> | string;
    expiresAt?: DateTimeNullableFilter<'ShareLink'> | Date | string | null;
    shareType?: EnumShareTypeFilter<'ShareLink'> | $Enums.ShareType;
    createdAt?: DateTimeFilter<'ShareLink'> | Date | string;
  };

  export type SpeakerUpsertWithWhereUniqueWithoutMeetingInput = {
    where: SpeakerWhereUniqueInput;
    update: XOR<
      SpeakerUpdateWithoutMeetingInput,
      SpeakerUncheckedUpdateWithoutMeetingInput
    >;
    create: XOR<
      SpeakerCreateWithoutMeetingInput,
      SpeakerUncheckedCreateWithoutMeetingInput
    >;
  };

  export type SpeakerUpdateWithWhereUniqueWithoutMeetingInput = {
    where: SpeakerWhereUniqueInput;
    data: XOR<
      SpeakerUpdateWithoutMeetingInput,
      SpeakerUncheckedUpdateWithoutMeetingInput
    >;
  };

  export type SpeakerUpdateManyWithWhereWithoutMeetingInput = {
    where: SpeakerScalarWhereInput;
    data: XOR<
      SpeakerUpdateManyMutationInput,
      SpeakerUncheckedUpdateManyWithoutMeetingInput
    >;
  };

  export type SpeakerScalarWhereInput = {
    AND?: SpeakerScalarWhereInput | SpeakerScalarWhereInput[];
    OR?: SpeakerScalarWhereInput[];
    NOT?: SpeakerScalarWhereInput | SpeakerScalarWhereInput[];
    id?: StringFilter<'Speaker'> | string;
    meetingId?: StringFilter<'Speaker'> | string;
    name?: StringFilter<'Speaker'> | string;
    isUnknown?: BoolFilter<'Speaker'> | boolean;
    isConfirmed?: BoolFilter<'Speaker'> | boolean;
    nameConfidence?: FloatFilter<'Speaker'> | number;
  };

  export type TranscriptSegmentUpsertWithWhereUniqueWithoutMeetingInput = {
    where: TranscriptSegmentWhereUniqueInput;
    update: XOR<
      TranscriptSegmentUpdateWithoutMeetingInput,
      TranscriptSegmentUncheckedUpdateWithoutMeetingInput
    >;
    create: XOR<
      TranscriptSegmentCreateWithoutMeetingInput,
      TranscriptSegmentUncheckedCreateWithoutMeetingInput
    >;
  };

  export type TranscriptSegmentUpdateWithWhereUniqueWithoutMeetingInput = {
    where: TranscriptSegmentWhereUniqueInput;
    data: XOR<
      TranscriptSegmentUpdateWithoutMeetingInput,
      TranscriptSegmentUncheckedUpdateWithoutMeetingInput
    >;
  };

  export type TranscriptSegmentUpdateManyWithWhereWithoutMeetingInput = {
    where: TranscriptSegmentScalarWhereInput;
    data: XOR<
      TranscriptSegmentUpdateManyMutationInput,
      TranscriptSegmentUncheckedUpdateManyWithoutMeetingInput
    >;
  };

  export type TranscriptSegmentScalarWhereInput = {
    AND?:
      | TranscriptSegmentScalarWhereInput
      | TranscriptSegmentScalarWhereInput[];
    OR?: TranscriptSegmentScalarWhereInput[];
    NOT?:
      | TranscriptSegmentScalarWhereInput
      | TranscriptSegmentScalarWhereInput[];
    id?: StringFilter<'TranscriptSegment'> | string;
    meetingId?: StringFilter<'TranscriptSegment'> | string;
    speakerId?: StringNullableFilter<'TranscriptSegment'> | string | null;
    startTime?: FloatFilter<'TranscriptSegment'> | number;
    endTime?: FloatFilter<'TranscriptSegment'> | number;
    text?: StringFilter<'TranscriptSegment'> | string;
    languagesUsed?: StringNullableListFilter<'TranscriptSegment'>;
    originalText?: StringNullableFilter<'TranscriptSegment'> | string | null;
  };

  export type MeetingCreateWithoutKeyMomentsInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    user: UserCreateNestedOneWithoutMeetingsInput;
    organization?: OrganizationCreateNestedOneWithoutMeetingsInput;
    calendarConnection?: CalendarConnectionCreateNestedOneWithoutMeetingsInput;
    tags?: MeetingTagCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateWithoutKeyMomentsInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    tags?: MeetingTagUncheckedCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesUncheckedCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerUncheckedCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingCreateOrConnectWithoutKeyMomentsInput = {
    where: MeetingWhereUniqueInput;
    create: XOR<
      MeetingCreateWithoutKeyMomentsInput,
      MeetingUncheckedCreateWithoutKeyMomentsInput
    >;
  };

  export type MeetingUpsertWithoutKeyMomentsInput = {
    update: XOR<
      MeetingUpdateWithoutKeyMomentsInput,
      MeetingUncheckedUpdateWithoutKeyMomentsInput
    >;
    create: XOR<
      MeetingCreateWithoutKeyMomentsInput,
      MeetingUncheckedCreateWithoutKeyMomentsInput
    >;
    where?: MeetingWhereInput;
  };

  export type MeetingUpdateToOneWithWhereWithoutKeyMomentsInput = {
    where?: MeetingWhereInput;
    data: XOR<
      MeetingUpdateWithoutKeyMomentsInput,
      MeetingUncheckedUpdateWithoutKeyMomentsInput
    >;
  };

  export type MeetingUpdateWithoutKeyMomentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput;
    organization?: OrganizationUpdateOneWithoutMeetingsNestedInput;
    calendarConnection?: CalendarConnectionUpdateOneWithoutMeetingsNestedInput;
    tags?: MeetingTagUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateWithoutKeyMomentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    tags?: MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUncheckedUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUncheckedUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type SegmentEditCreateWithoutSegmentInput = {
    id?: string;
    previousText: string;
    newText: string;
    editedBy: string;
    editReason?: string | null;
    createdAt?: Date | string;
  };

  export type SegmentEditUncheckedCreateWithoutSegmentInput = {
    id?: string;
    previousText: string;
    newText: string;
    editedBy: string;
    editReason?: string | null;
    createdAt?: Date | string;
  };

  export type SegmentEditCreateOrConnectWithoutSegmentInput = {
    where: SegmentEditWhereUniqueInput;
    create: XOR<
      SegmentEditCreateWithoutSegmentInput,
      SegmentEditUncheckedCreateWithoutSegmentInput
    >;
  };

  export type SegmentEditCreateManySegmentInputEnvelope = {
    data:
      | SegmentEditCreateManySegmentInput
      | SegmentEditCreateManySegmentInput[];
    skipDuplicates?: boolean;
  };

  export type TranscriptCorrectionCreateWithoutSegmentInput = {
    id?: string;
    originalText: string;
    correctedText: string;
    correctedBy: string;
    createdAt?: Date | string;
  };

  export type TranscriptCorrectionUncheckedCreateWithoutSegmentInput = {
    id?: string;
    originalText: string;
    correctedText: string;
    correctedBy: string;
    createdAt?: Date | string;
  };

  export type TranscriptCorrectionCreateOrConnectWithoutSegmentInput = {
    where: TranscriptCorrectionWhereUniqueInput;
    create: XOR<
      TranscriptCorrectionCreateWithoutSegmentInput,
      TranscriptCorrectionUncheckedCreateWithoutSegmentInput
    >;
  };

  export type TranscriptCorrectionCreateManySegmentInputEnvelope = {
    data:
      | TranscriptCorrectionCreateManySegmentInput
      | TranscriptCorrectionCreateManySegmentInput[];
    skipDuplicates?: boolean;
  };

  export type MeetingCreateWithoutTranscriptInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentCreateNestedManyWithoutMeetingInput;
    user: UserCreateNestedOneWithoutMeetingsInput;
    organization?: OrganizationCreateNestedOneWithoutMeetingsInput;
    calendarConnection?: CalendarConnectionCreateNestedOneWithoutMeetingsInput;
    tags?: MeetingTagCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateWithoutTranscriptInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentUncheckedCreateNestedManyWithoutMeetingInput;
    tags?: MeetingTagUncheckedCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesUncheckedCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingCreateOrConnectWithoutTranscriptInput = {
    where: MeetingWhereUniqueInput;
    create: XOR<
      MeetingCreateWithoutTranscriptInput,
      MeetingUncheckedCreateWithoutTranscriptInput
    >;
  };

  export type SpeakerCreateWithoutSegmentsInput = {
    id?: string;
    name: string;
    isUnknown?: boolean;
    isConfirmed?: boolean;
    nameConfidence?: number;
    meeting: MeetingCreateNestedOneWithoutSpeakersInput;
  };

  export type SpeakerUncheckedCreateWithoutSegmentsInput = {
    id?: string;
    meetingId: string;
    name: string;
    isUnknown?: boolean;
    isConfirmed?: boolean;
    nameConfidence?: number;
  };

  export type SpeakerCreateOrConnectWithoutSegmentsInput = {
    where: SpeakerWhereUniqueInput;
    create: XOR<
      SpeakerCreateWithoutSegmentsInput,
      SpeakerUncheckedCreateWithoutSegmentsInput
    >;
  };

  export type SegmentEditUpsertWithWhereUniqueWithoutSegmentInput = {
    where: SegmentEditWhereUniqueInput;
    update: XOR<
      SegmentEditUpdateWithoutSegmentInput,
      SegmentEditUncheckedUpdateWithoutSegmentInput
    >;
    create: XOR<
      SegmentEditCreateWithoutSegmentInput,
      SegmentEditUncheckedCreateWithoutSegmentInput
    >;
  };

  export type SegmentEditUpdateWithWhereUniqueWithoutSegmentInput = {
    where: SegmentEditWhereUniqueInput;
    data: XOR<
      SegmentEditUpdateWithoutSegmentInput,
      SegmentEditUncheckedUpdateWithoutSegmentInput
    >;
  };

  export type SegmentEditUpdateManyWithWhereWithoutSegmentInput = {
    where: SegmentEditScalarWhereInput;
    data: XOR<
      SegmentEditUpdateManyMutationInput,
      SegmentEditUncheckedUpdateManyWithoutSegmentInput
    >;
  };

  export type SegmentEditScalarWhereInput = {
    AND?: SegmentEditScalarWhereInput | SegmentEditScalarWhereInput[];
    OR?: SegmentEditScalarWhereInput[];
    NOT?: SegmentEditScalarWhereInput | SegmentEditScalarWhereInput[];
    id?: StringFilter<'SegmentEdit'> | string;
    segmentId?: StringFilter<'SegmentEdit'> | string;
    previousText?: StringFilter<'SegmentEdit'> | string;
    newText?: StringFilter<'SegmentEdit'> | string;
    editedBy?: StringFilter<'SegmentEdit'> | string;
    editReason?: StringNullableFilter<'SegmentEdit'> | string | null;
    createdAt?: DateTimeFilter<'SegmentEdit'> | Date | string;
  };

  export type TranscriptCorrectionUpsertWithWhereUniqueWithoutSegmentInput = {
    where: TranscriptCorrectionWhereUniqueInput;
    update: XOR<
      TranscriptCorrectionUpdateWithoutSegmentInput,
      TranscriptCorrectionUncheckedUpdateWithoutSegmentInput
    >;
    create: XOR<
      TranscriptCorrectionCreateWithoutSegmentInput,
      TranscriptCorrectionUncheckedCreateWithoutSegmentInput
    >;
  };

  export type TranscriptCorrectionUpdateWithWhereUniqueWithoutSegmentInput = {
    where: TranscriptCorrectionWhereUniqueInput;
    data: XOR<
      TranscriptCorrectionUpdateWithoutSegmentInput,
      TranscriptCorrectionUncheckedUpdateWithoutSegmentInput
    >;
  };

  export type TranscriptCorrectionUpdateManyWithWhereWithoutSegmentInput = {
    where: TranscriptCorrectionScalarWhereInput;
    data: XOR<
      TranscriptCorrectionUpdateManyMutationInput,
      TranscriptCorrectionUncheckedUpdateManyWithoutSegmentInput
    >;
  };

  export type TranscriptCorrectionScalarWhereInput = {
    AND?:
      | TranscriptCorrectionScalarWhereInput
      | TranscriptCorrectionScalarWhereInput[];
    OR?: TranscriptCorrectionScalarWhereInput[];
    NOT?:
      | TranscriptCorrectionScalarWhereInput
      | TranscriptCorrectionScalarWhereInput[];
    id?: StringFilter<'TranscriptCorrection'> | string;
    segmentId?: StringFilter<'TranscriptCorrection'> | string;
    originalText?: StringFilter<'TranscriptCorrection'> | string;
    correctedText?: StringFilter<'TranscriptCorrection'> | string;
    correctedBy?: StringFilter<'TranscriptCorrection'> | string;
    createdAt?: DateTimeFilter<'TranscriptCorrection'> | Date | string;
  };

  export type MeetingUpsertWithoutTranscriptInput = {
    update: XOR<
      MeetingUpdateWithoutTranscriptInput,
      MeetingUncheckedUpdateWithoutTranscriptInput
    >;
    create: XOR<
      MeetingCreateWithoutTranscriptInput,
      MeetingUncheckedCreateWithoutTranscriptInput
    >;
    where?: MeetingWhereInput;
  };

  export type MeetingUpdateToOneWithWhereWithoutTranscriptInput = {
    where?: MeetingWhereInput;
    data: XOR<
      MeetingUpdateWithoutTranscriptInput,
      MeetingUncheckedUpdateWithoutTranscriptInput
    >;
  };

  export type MeetingUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUpdateManyWithoutMeetingNestedInput;
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput;
    organization?: OrganizationUpdateOneWithoutMeetingsNestedInput;
    calendarConnection?: CalendarConnectionUpdateOneWithoutMeetingsNestedInput;
    tags?: MeetingTagUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput;
    tags?: MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUncheckedUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type SpeakerUpsertWithoutSegmentsInput = {
    update: XOR<
      SpeakerUpdateWithoutSegmentsInput,
      SpeakerUncheckedUpdateWithoutSegmentsInput
    >;
    create: XOR<
      SpeakerCreateWithoutSegmentsInput,
      SpeakerUncheckedCreateWithoutSegmentsInput
    >;
    where?: SpeakerWhereInput;
  };

  export type SpeakerUpdateToOneWithWhereWithoutSegmentsInput = {
    where?: SpeakerWhereInput;
    data: XOR<
      SpeakerUpdateWithoutSegmentsInput,
      SpeakerUncheckedUpdateWithoutSegmentsInput
    >;
  };

  export type SpeakerUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isUnknown?: BoolFieldUpdateOperationsInput | boolean;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    nameConfidence?: FloatFieldUpdateOperationsInput | number;
    meeting?: MeetingUpdateOneRequiredWithoutSpeakersNestedInput;
  };

  export type SpeakerUncheckedUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isUnknown?: BoolFieldUpdateOperationsInput | boolean;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    nameConfidence?: FloatFieldUpdateOperationsInput | number;
  };

  export type TranscriptSegmentCreateWithoutCorrectionsInput = {
    id?: string;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    edits?: SegmentEditCreateNestedManyWithoutSegmentInput;
    meeting: MeetingCreateNestedOneWithoutTranscriptInput;
    speaker?: SpeakerCreateNestedOneWithoutSegmentsInput;
  };

  export type TranscriptSegmentUncheckedCreateWithoutCorrectionsInput = {
    id?: string;
    meetingId: string;
    speakerId?: string | null;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    edits?: SegmentEditUncheckedCreateNestedManyWithoutSegmentInput;
  };

  export type TranscriptSegmentCreateOrConnectWithoutCorrectionsInput = {
    where: TranscriptSegmentWhereUniqueInput;
    create: XOR<
      TranscriptSegmentCreateWithoutCorrectionsInput,
      TranscriptSegmentUncheckedCreateWithoutCorrectionsInput
    >;
  };

  export type TranscriptSegmentUpsertWithoutCorrectionsInput = {
    update: XOR<
      TranscriptSegmentUpdateWithoutCorrectionsInput,
      TranscriptSegmentUncheckedUpdateWithoutCorrectionsInput
    >;
    create: XOR<
      TranscriptSegmentCreateWithoutCorrectionsInput,
      TranscriptSegmentUncheckedCreateWithoutCorrectionsInput
    >;
    where?: TranscriptSegmentWhereInput;
  };

  export type TranscriptSegmentUpdateToOneWithWhereWithoutCorrectionsInput = {
    where?: TranscriptSegmentWhereInput;
    data: XOR<
      TranscriptSegmentUpdateWithoutCorrectionsInput,
      TranscriptSegmentUncheckedUpdateWithoutCorrectionsInput
    >;
  };

  export type TranscriptSegmentUpdateWithoutCorrectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    edits?: SegmentEditUpdateManyWithoutSegmentNestedInput;
    meeting?: MeetingUpdateOneRequiredWithoutTranscriptNestedInput;
    speaker?: SpeakerUpdateOneWithoutSegmentsNestedInput;
  };

  export type TranscriptSegmentUncheckedUpdateWithoutCorrectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    edits?: SegmentEditUncheckedUpdateManyWithoutSegmentNestedInput;
  };

  export type TranscriptSegmentCreateWithoutEditsInput = {
    id?: string;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    corrections?: TranscriptCorrectionCreateNestedManyWithoutSegmentInput;
    meeting: MeetingCreateNestedOneWithoutTranscriptInput;
    speaker?: SpeakerCreateNestedOneWithoutSegmentsInput;
  };

  export type TranscriptSegmentUncheckedCreateWithoutEditsInput = {
    id?: string;
    meetingId: string;
    speakerId?: string | null;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    corrections?: TranscriptCorrectionUncheckedCreateNestedManyWithoutSegmentInput;
  };

  export type TranscriptSegmentCreateOrConnectWithoutEditsInput = {
    where: TranscriptSegmentWhereUniqueInput;
    create: XOR<
      TranscriptSegmentCreateWithoutEditsInput,
      TranscriptSegmentUncheckedCreateWithoutEditsInput
    >;
  };

  export type TranscriptSegmentUpsertWithoutEditsInput = {
    update: XOR<
      TranscriptSegmentUpdateWithoutEditsInput,
      TranscriptSegmentUncheckedUpdateWithoutEditsInput
    >;
    create: XOR<
      TranscriptSegmentCreateWithoutEditsInput,
      TranscriptSegmentUncheckedCreateWithoutEditsInput
    >;
    where?: TranscriptSegmentWhereInput;
  };

  export type TranscriptSegmentUpdateToOneWithWhereWithoutEditsInput = {
    where?: TranscriptSegmentWhereInput;
    data: XOR<
      TranscriptSegmentUpdateWithoutEditsInput,
      TranscriptSegmentUncheckedUpdateWithoutEditsInput
    >;
  };

  export type TranscriptSegmentUpdateWithoutEditsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    corrections?: TranscriptCorrectionUpdateManyWithoutSegmentNestedInput;
    meeting?: MeetingUpdateOneRequiredWithoutTranscriptNestedInput;
    speaker?: SpeakerUpdateOneWithoutSegmentsNestedInput;
  };

  export type TranscriptSegmentUncheckedUpdateWithoutEditsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    corrections?: TranscriptCorrectionUncheckedUpdateManyWithoutSegmentNestedInput;
  };

  export type MeetingCreateWithoutSpeakersInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentCreateNestedManyWithoutMeetingInput;
    user: UserCreateNestedOneWithoutMeetingsInput;
    organization?: OrganizationCreateNestedOneWithoutMeetingsInput;
    calendarConnection?: CalendarConnectionCreateNestedOneWithoutMeetingsInput;
    tags?: MeetingTagCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateWithoutSpeakersInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentUncheckedCreateNestedManyWithoutMeetingInput;
    tags?: MeetingTagUncheckedCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesUncheckedCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingCreateOrConnectWithoutSpeakersInput = {
    where: MeetingWhereUniqueInput;
    create: XOR<
      MeetingCreateWithoutSpeakersInput,
      MeetingUncheckedCreateWithoutSpeakersInput
    >;
  };

  export type TranscriptSegmentCreateWithoutSpeakerInput = {
    id?: string;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    edits?: SegmentEditCreateNestedManyWithoutSegmentInput;
    corrections?: TranscriptCorrectionCreateNestedManyWithoutSegmentInput;
    meeting: MeetingCreateNestedOneWithoutTranscriptInput;
  };

  export type TranscriptSegmentUncheckedCreateWithoutSpeakerInput = {
    id?: string;
    meetingId: string;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
    edits?: SegmentEditUncheckedCreateNestedManyWithoutSegmentInput;
    corrections?: TranscriptCorrectionUncheckedCreateNestedManyWithoutSegmentInput;
  };

  export type TranscriptSegmentCreateOrConnectWithoutSpeakerInput = {
    where: TranscriptSegmentWhereUniqueInput;
    create: XOR<
      TranscriptSegmentCreateWithoutSpeakerInput,
      TranscriptSegmentUncheckedCreateWithoutSpeakerInput
    >;
  };

  export type TranscriptSegmentCreateManySpeakerInputEnvelope = {
    data:
      | TranscriptSegmentCreateManySpeakerInput
      | TranscriptSegmentCreateManySpeakerInput[];
    skipDuplicates?: boolean;
  };

  export type MeetingUpsertWithoutSpeakersInput = {
    update: XOR<
      MeetingUpdateWithoutSpeakersInput,
      MeetingUncheckedUpdateWithoutSpeakersInput
    >;
    create: XOR<
      MeetingCreateWithoutSpeakersInput,
      MeetingUncheckedCreateWithoutSpeakersInput
    >;
    where?: MeetingWhereInput;
  };

  export type MeetingUpdateToOneWithWhereWithoutSpeakersInput = {
    where?: MeetingWhereInput;
    data: XOR<
      MeetingUpdateWithoutSpeakersInput,
      MeetingUncheckedUpdateWithoutSpeakersInput
    >;
  };

  export type MeetingUpdateWithoutSpeakersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUpdateManyWithoutMeetingNestedInput;
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput;
    organization?: OrganizationUpdateOneWithoutMeetingsNestedInput;
    calendarConnection?: CalendarConnectionUpdateOneWithoutMeetingsNestedInput;
    tags?: MeetingTagUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateWithoutSpeakersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput;
    tags?: MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUncheckedUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type TranscriptSegmentUpsertWithWhereUniqueWithoutSpeakerInput = {
    where: TranscriptSegmentWhereUniqueInput;
    update: XOR<
      TranscriptSegmentUpdateWithoutSpeakerInput,
      TranscriptSegmentUncheckedUpdateWithoutSpeakerInput
    >;
    create: XOR<
      TranscriptSegmentCreateWithoutSpeakerInput,
      TranscriptSegmentUncheckedCreateWithoutSpeakerInput
    >;
  };

  export type TranscriptSegmentUpdateWithWhereUniqueWithoutSpeakerInput = {
    where: TranscriptSegmentWhereUniqueInput;
    data: XOR<
      TranscriptSegmentUpdateWithoutSpeakerInput,
      TranscriptSegmentUncheckedUpdateWithoutSpeakerInput
    >;
  };

  export type TranscriptSegmentUpdateManyWithWhereWithoutSpeakerInput = {
    where: TranscriptSegmentScalarWhereInput;
    data: XOR<
      TranscriptSegmentUpdateManyMutationInput,
      TranscriptSegmentUncheckedUpdateManyWithoutSpeakerInput
    >;
  };

  export type MeetingCreateWithoutMinutesInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentCreateNestedManyWithoutMeetingInput;
    user: UserCreateNestedOneWithoutMeetingsInput;
    organization?: OrganizationCreateNestedOneWithoutMeetingsInput;
    calendarConnection?: CalendarConnectionCreateNestedOneWithoutMeetingsInput;
    tags?: MeetingTagCreateNestedManyWithoutMeetingInput;
    shareLinks?: ShareLinkCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateWithoutMinutesInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentUncheckedCreateNestedManyWithoutMeetingInput;
    tags?: MeetingTagUncheckedCreateNestedManyWithoutMeetingInput;
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerUncheckedCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingCreateOrConnectWithoutMinutesInput = {
    where: MeetingWhereUniqueInput;
    create: XOR<
      MeetingCreateWithoutMinutesInput,
      MeetingUncheckedCreateWithoutMinutesInput
    >;
  };

  export type UserCreateWithoutReviewedMinutesInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionCreateNestedOneWithoutUserInput;
    tags?: TagCreateNestedManyWithoutUserInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    calendarConnections?: CalendarConnectionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutReviewedMinutesInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput;
    tags?: TagUncheckedCreateNestedManyWithoutUserInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    calendarConnections?: CalendarConnectionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutReviewedMinutesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutReviewedMinutesInput,
      UserUncheckedCreateWithoutReviewedMinutesInput
    >;
  };

  export type MinutesVersionCreateWithoutMinutesInput = {
    id?: string;
    content: string;
    version: number;
    createdAt?: Date | string;
  };

  export type MinutesVersionUncheckedCreateWithoutMinutesInput = {
    id?: string;
    content: string;
    version: number;
    createdAt?: Date | string;
  };

  export type MinutesVersionCreateOrConnectWithoutMinutesInput = {
    where: MinutesVersionWhereUniqueInput;
    create: XOR<
      MinutesVersionCreateWithoutMinutesInput,
      MinutesVersionUncheckedCreateWithoutMinutesInput
    >;
  };

  export type MinutesVersionCreateManyMinutesInputEnvelope = {
    data:
      | MinutesVersionCreateManyMinutesInput
      | MinutesVersionCreateManyMinutesInput[];
    skipDuplicates?: boolean;
  };

  export type MeetingUpsertWithoutMinutesInput = {
    update: XOR<
      MeetingUpdateWithoutMinutesInput,
      MeetingUncheckedUpdateWithoutMinutesInput
    >;
    create: XOR<
      MeetingCreateWithoutMinutesInput,
      MeetingUncheckedCreateWithoutMinutesInput
    >;
    where?: MeetingWhereInput;
  };

  export type MeetingUpdateToOneWithWhereWithoutMinutesInput = {
    where?: MeetingWhereInput;
    data: XOR<
      MeetingUpdateWithoutMinutesInput,
      MeetingUncheckedUpdateWithoutMinutesInput
    >;
  };

  export type MeetingUpdateWithoutMinutesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUpdateManyWithoutMeetingNestedInput;
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput;
    organization?: OrganizationUpdateOneWithoutMeetingsNestedInput;
    calendarConnection?: CalendarConnectionUpdateOneWithoutMeetingsNestedInput;
    tags?: MeetingTagUpdateManyWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateWithoutMinutesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput;
    tags?: MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUncheckedUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type UserUpsertWithoutReviewedMinutesInput = {
    update: XOR<
      UserUpdateWithoutReviewedMinutesInput,
      UserUncheckedUpdateWithoutReviewedMinutesInput
    >;
    create: XOR<
      UserCreateWithoutReviewedMinutesInput,
      UserUncheckedCreateWithoutReviewedMinutesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutReviewedMinutesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutReviewedMinutesInput,
      UserUncheckedUpdateWithoutReviewedMinutesInput
    >;
  };

  export type UserUpdateWithoutReviewedMinutesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput;
    tags?: TagUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    calendarConnections?: CalendarConnectionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutReviewedMinutesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput;
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    calendarConnections?: CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type MinutesVersionUpsertWithWhereUniqueWithoutMinutesInput = {
    where: MinutesVersionWhereUniqueInput;
    update: XOR<
      MinutesVersionUpdateWithoutMinutesInput,
      MinutesVersionUncheckedUpdateWithoutMinutesInput
    >;
    create: XOR<
      MinutesVersionCreateWithoutMinutesInput,
      MinutesVersionUncheckedCreateWithoutMinutesInput
    >;
  };

  export type MinutesVersionUpdateWithWhereUniqueWithoutMinutesInput = {
    where: MinutesVersionWhereUniqueInput;
    data: XOR<
      MinutesVersionUpdateWithoutMinutesInput,
      MinutesVersionUncheckedUpdateWithoutMinutesInput
    >;
  };

  export type MinutesVersionUpdateManyWithWhereWithoutMinutesInput = {
    where: MinutesVersionScalarWhereInput;
    data: XOR<
      MinutesVersionUpdateManyMutationInput,
      MinutesVersionUncheckedUpdateManyWithoutMinutesInput
    >;
  };

  export type MinutesVersionScalarWhereInput = {
    AND?: MinutesVersionScalarWhereInput | MinutesVersionScalarWhereInput[];
    OR?: MinutesVersionScalarWhereInput[];
    NOT?: MinutesVersionScalarWhereInput | MinutesVersionScalarWhereInput[];
    id?: StringFilter<'MinutesVersion'> | string;
    minutesId?: StringFilter<'MinutesVersion'> | string;
    content?: StringFilter<'MinutesVersion'> | string;
    version?: IntFilter<'MinutesVersion'> | number;
    createdAt?: DateTimeFilter<'MinutesVersion'> | Date | string;
  };

  export type MinutesCreateWithoutVersionsInput = {
    id?: string;
    content: string;
    status?: $Enums.MinutesStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    meeting: MeetingCreateNestedOneWithoutMinutesInput;
    reviewer?: UserCreateNestedOneWithoutReviewedMinutesInput;
  };

  export type MinutesUncheckedCreateWithoutVersionsInput = {
    id?: string;
    meetingId: string;
    content: string;
    status?: $Enums.MinutesStatus;
    reviewerId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MinutesCreateOrConnectWithoutVersionsInput = {
    where: MinutesWhereUniqueInput;
    create: XOR<
      MinutesCreateWithoutVersionsInput,
      MinutesUncheckedCreateWithoutVersionsInput
    >;
  };

  export type MinutesUpsertWithoutVersionsInput = {
    update: XOR<
      MinutesUpdateWithoutVersionsInput,
      MinutesUncheckedUpdateWithoutVersionsInput
    >;
    create: XOR<
      MinutesCreateWithoutVersionsInput,
      MinutesUncheckedCreateWithoutVersionsInput
    >;
    where?: MinutesWhereInput;
  };

  export type MinutesUpdateToOneWithWhereWithoutVersionsInput = {
    where?: MinutesWhereInput;
    data: XOR<
      MinutesUpdateWithoutVersionsInput,
      MinutesUncheckedUpdateWithoutVersionsInput
    >;
  };

  export type MinutesUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meeting?: MeetingUpdateOneRequiredWithoutMinutesNestedInput;
    reviewer?: UserUpdateOneWithoutReviewedMinutesNestedInput;
  };

  export type MinutesUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateWithoutNotificationSettingsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    subscription?: SubscriptionCreateNestedOneWithoutUserInput;
    tags?: TagCreateNestedManyWithoutUserInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutNotificationSettingsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput;
    tags?: TagUncheckedCreateNestedManyWithoutUserInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesUncheckedCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutNotificationSettingsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutNotificationSettingsInput,
      UserUncheckedCreateWithoutNotificationSettingsInput
    >;
  };

  export type UserUpsertWithoutNotificationSettingsInput = {
    update: XOR<
      UserUpdateWithoutNotificationSettingsInput,
      UserUncheckedUpdateWithoutNotificationSettingsInput
    >;
    create: XOR<
      UserCreateWithoutNotificationSettingsInput,
      UserUncheckedCreateWithoutNotificationSettingsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutNotificationSettingsInput,
      UserUncheckedUpdateWithoutNotificationSettingsInput
    >;
  };

  export type UserUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput;
    tags?: TagUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput;
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUncheckedUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type MeetingTagCreateWithoutTagInput = {
    id?: string;
    createdAt?: Date | string;
    meeting: MeetingCreateNestedOneWithoutTagsInput;
  };

  export type MeetingTagUncheckedCreateWithoutTagInput = {
    id?: string;
    meetingId: string;
    createdAt?: Date | string;
  };

  export type MeetingTagCreateOrConnectWithoutTagInput = {
    where: MeetingTagWhereUniqueInput;
    create: XOR<
      MeetingTagCreateWithoutTagInput,
      MeetingTagUncheckedCreateWithoutTagInput
    >;
  };

  export type MeetingTagCreateManyTagInputEnvelope = {
    data: MeetingTagCreateManyTagInput | MeetingTagCreateManyTagInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutTagsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionCreateNestedOneWithoutUserInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTagsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesUncheckedCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTagsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTagsInput,
      UserUncheckedCreateWithoutTagsInput
    >;
  };

  export type OrganizationCreateWithoutTagsInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    members?: MembershipCreateNestedManyWithoutOrganizationInput;
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput;
    templates?: MinutesTemplateCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutTagsInput = {
    id?: string;
    name: string;
    slug: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isPersonal?: boolean;
    autoRedact?: boolean;
    retentionDays?: number | null;
    members?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutTagsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutTagsInput,
      OrganizationUncheckedCreateWithoutTagsInput
    >;
  };

  export type MeetingTagUpsertWithWhereUniqueWithoutTagInput = {
    where: MeetingTagWhereUniqueInput;
    update: XOR<
      MeetingTagUpdateWithoutTagInput,
      MeetingTagUncheckedUpdateWithoutTagInput
    >;
    create: XOR<
      MeetingTagCreateWithoutTagInput,
      MeetingTagUncheckedCreateWithoutTagInput
    >;
  };

  export type MeetingTagUpdateWithWhereUniqueWithoutTagInput = {
    where: MeetingTagWhereUniqueInput;
    data: XOR<
      MeetingTagUpdateWithoutTagInput,
      MeetingTagUncheckedUpdateWithoutTagInput
    >;
  };

  export type MeetingTagUpdateManyWithWhereWithoutTagInput = {
    where: MeetingTagScalarWhereInput;
    data: XOR<
      MeetingTagUpdateManyMutationInput,
      MeetingTagUncheckedUpdateManyWithoutTagInput
    >;
  };

  export type UserUpsertWithoutTagsInput = {
    update: XOR<
      UserUpdateWithoutTagsInput,
      UserUncheckedUpdateWithoutTagsInput
    >;
    create: XOR<
      UserCreateWithoutTagsInput,
      UserUncheckedCreateWithoutTagsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTagsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>;
  };

  export type UserUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUncheckedUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutTagsInput = {
    update: XOR<
      OrganizationUpdateWithoutTagsInput,
      OrganizationUncheckedUpdateWithoutTagsInput
    >;
    create: XOR<
      OrganizationCreateWithoutTagsInput,
      OrganizationUncheckedCreateWithoutTagsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutTagsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutTagsInput,
      OrganizationUncheckedUpdateWithoutTagsInput
    >;
  };

  export type OrganizationUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    members?: MembershipUpdateManyWithoutOrganizationNestedInput;
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isPersonal?: BoolFieldUpdateOperationsInput | boolean;
    autoRedact?: BoolFieldUpdateOperationsInput | boolean;
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null;
    members?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type MeetingCreateWithoutTagsInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentCreateNestedManyWithoutMeetingInput;
    user: UserCreateNestedOneWithoutMeetingsInput;
    organization?: OrganizationCreateNestedOneWithoutMeetingsInput;
    calendarConnection?: CalendarConnectionCreateNestedOneWithoutMeetingsInput;
    minutes?: MinutesCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateWithoutTagsInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentUncheckedCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesUncheckedCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerUncheckedCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingCreateOrConnectWithoutTagsInput = {
    where: MeetingWhereUniqueInput;
    create: XOR<
      MeetingCreateWithoutTagsInput,
      MeetingUncheckedCreateWithoutTagsInput
    >;
  };

  export type TagCreateWithoutMeetingsInput = {
    id?: string;
    name: string;
    color?: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutTagsInput;
    organization?: OrganizationCreateNestedOneWithoutTagsInput;
  };

  export type TagUncheckedCreateWithoutMeetingsInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    name: string;
    color?: string;
    createdAt?: Date | string;
  };

  export type TagCreateOrConnectWithoutMeetingsInput = {
    where: TagWhereUniqueInput;
    create: XOR<
      TagCreateWithoutMeetingsInput,
      TagUncheckedCreateWithoutMeetingsInput
    >;
  };

  export type MeetingUpsertWithoutTagsInput = {
    update: XOR<
      MeetingUpdateWithoutTagsInput,
      MeetingUncheckedUpdateWithoutTagsInput
    >;
    create: XOR<
      MeetingCreateWithoutTagsInput,
      MeetingUncheckedCreateWithoutTagsInput
    >;
    where?: MeetingWhereInput;
  };

  export type MeetingUpdateToOneWithWhereWithoutTagsInput = {
    where?: MeetingWhereInput;
    data: XOR<
      MeetingUpdateWithoutTagsInput,
      MeetingUncheckedUpdateWithoutTagsInput
    >;
  };

  export type MeetingUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUpdateManyWithoutMeetingNestedInput;
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput;
    organization?: OrganizationUpdateOneWithoutMeetingsNestedInput;
    calendarConnection?: CalendarConnectionUpdateOneWithoutMeetingsNestedInput;
    minutes?: MinutesUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUncheckedUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUncheckedUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type TagUpsertWithoutMeetingsInput = {
    update: XOR<
      TagUpdateWithoutMeetingsInput,
      TagUncheckedUpdateWithoutMeetingsInput
    >;
    create: XOR<
      TagCreateWithoutMeetingsInput,
      TagUncheckedCreateWithoutMeetingsInput
    >;
    where?: TagWhereInput;
  };

  export type TagUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: TagWhereInput;
    data: XOR<
      TagUpdateWithoutMeetingsInput,
      TagUncheckedUpdateWithoutMeetingsInput
    >;
  };

  export type TagUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutTagsNestedInput;
    organization?: OrganizationUpdateOneWithoutTagsNestedInput;
  };

  export type TagUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionCreateNestedOneWithoutUserInput;
    tags?: TagCreateNestedManyWithoutUserInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput;
    tags?: TagUncheckedCreateNestedManyWithoutUserInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesUncheckedCreateNestedManyWithoutReviewerInput;
    calendarConnections?: CalendarConnectionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
  };

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<
      UserUpdateWithoutNotificationsInput,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
    create: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutNotificationsInput,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput;
    tags?: TagUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput;
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUncheckedUpdateManyWithoutReviewerNestedInput;
    calendarConnections?: CalendarConnectionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type MeetingCreateWithoutShareLinksInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentCreateNestedManyWithoutMeetingInput;
    user: UserCreateNestedOneWithoutMeetingsInput;
    organization?: OrganizationCreateNestedOneWithoutMeetingsInput;
    calendarConnection?: CalendarConnectionCreateNestedOneWithoutMeetingsInput;
    tags?: MeetingTagCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesCreateNestedOneWithoutMeetingInput;
    speakers?: SpeakerCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateWithoutShareLinksInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentUncheckedCreateNestedManyWithoutMeetingInput;
    tags?: MeetingTagUncheckedCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesUncheckedCreateNestedOneWithoutMeetingInput;
    speakers?: SpeakerUncheckedCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingCreateOrConnectWithoutShareLinksInput = {
    where: MeetingWhereUniqueInput;
    create: XOR<
      MeetingCreateWithoutShareLinksInput,
      MeetingUncheckedCreateWithoutShareLinksInput
    >;
  };

  export type MeetingUpsertWithoutShareLinksInput = {
    update: XOR<
      MeetingUpdateWithoutShareLinksInput,
      MeetingUncheckedUpdateWithoutShareLinksInput
    >;
    create: XOR<
      MeetingCreateWithoutShareLinksInput,
      MeetingUncheckedCreateWithoutShareLinksInput
    >;
    where?: MeetingWhereInput;
  };

  export type MeetingUpdateToOneWithWhereWithoutShareLinksInput = {
    where?: MeetingWhereInput;
    data: XOR<
      MeetingUpdateWithoutShareLinksInput,
      MeetingUncheckedUpdateWithoutShareLinksInput
    >;
  };

  export type MeetingUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUpdateManyWithoutMeetingNestedInput;
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput;
    organization?: OrganizationUpdateOneWithoutMeetingsNestedInput;
    calendarConnection?: CalendarConnectionUpdateOneWithoutMeetingsNestedInput;
    tags?: MeetingTagUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUpdateOneWithoutMeetingNestedInput;
    speakers?: SpeakerUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput;
    tags?: MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUncheckedUpdateOneWithoutMeetingNestedInput;
    speakers?: SpeakerUncheckedUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type UserCreateWithoutCalendarConnectionsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionCreateNestedOneWithoutUserInput;
    tags?: TagCreateNestedManyWithoutUserInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesCreateNestedManyWithoutReviewerInput;
  };

  export type UserUncheckedCreateWithoutCalendarConnectionsInput = {
    id?: string;
    email: string;
    password?: string | null;
    name?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: $Enums.Role;
    isActive?: boolean;
    telegramId?: string | null;
    telegramChatId?: string | null;
    telegramLinkCode?: string | null;
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput;
    templates?: MinutesTemplateUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    notificationSettings?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput;
    tags?: TagUncheckedCreateNestedManyWithoutUserInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    reviewedMinutes?: MinutesUncheckedCreateNestedManyWithoutReviewerInput;
  };

  export type UserCreateOrConnectWithoutCalendarConnectionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCalendarConnectionsInput,
      UserUncheckedCreateWithoutCalendarConnectionsInput
    >;
  };

  export type MeetingCreateWithoutCalendarConnectionInput = {
    id?: string;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentCreateNestedManyWithoutMeetingInput;
    user: UserCreateNestedOneWithoutMeetingsInput;
    organization?: OrganizationCreateNestedOneWithoutMeetingsInput;
    tags?: MeetingTagCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingUncheckedCreateWithoutCalendarConnectionInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
    keyMoments?: KeyMomentUncheckedCreateNestedManyWithoutMeetingInput;
    tags?: MeetingTagUncheckedCreateNestedManyWithoutMeetingInput;
    minutes?: MinutesUncheckedCreateNestedOneWithoutMeetingInput;
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutMeetingInput;
    speakers?: SpeakerUncheckedCreateNestedManyWithoutMeetingInput;
    transcript?: TranscriptSegmentUncheckedCreateNestedManyWithoutMeetingInput;
  };

  export type MeetingCreateOrConnectWithoutCalendarConnectionInput = {
    where: MeetingWhereUniqueInput;
    create: XOR<
      MeetingCreateWithoutCalendarConnectionInput,
      MeetingUncheckedCreateWithoutCalendarConnectionInput
    >;
  };

  export type MeetingCreateManyCalendarConnectionInputEnvelope = {
    data:
      | MeetingCreateManyCalendarConnectionInput
      | MeetingCreateManyCalendarConnectionInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutCalendarConnectionsInput = {
    update: XOR<
      UserUpdateWithoutCalendarConnectionsInput,
      UserUncheckedUpdateWithoutCalendarConnectionsInput
    >;
    create: XOR<
      UserCreateWithoutCalendarConnectionsInput,
      UserUncheckedCreateWithoutCalendarConnectionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCalendarConnectionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCalendarConnectionsInput,
      UserUncheckedUpdateWithoutCalendarConnectionsInput
    >;
  };

  export type UserUpdateWithoutCalendarConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput;
    tags?: TagUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUpdateManyWithoutReviewerNestedInput;
  };

  export type UserUncheckedUpdateWithoutCalendarConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null;
    telegramLinkCode?: NullableStringFieldUpdateOperationsInput | string | null;
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput;
    templates?: MinutesTemplateUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    notificationSettings?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput;
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    reviewedMinutes?: MinutesUncheckedUpdateManyWithoutReviewerNestedInput;
  };

  export type MeetingUpsertWithWhereUniqueWithoutCalendarConnectionInput = {
    where: MeetingWhereUniqueInput;
    update: XOR<
      MeetingUpdateWithoutCalendarConnectionInput,
      MeetingUncheckedUpdateWithoutCalendarConnectionInput
    >;
    create: XOR<
      MeetingCreateWithoutCalendarConnectionInput,
      MeetingUncheckedCreateWithoutCalendarConnectionInput
    >;
  };

  export type MeetingUpdateWithWhereUniqueWithoutCalendarConnectionInput = {
    where: MeetingWhereUniqueInput;
    data: XOR<
      MeetingUpdateWithoutCalendarConnectionInput,
      MeetingUncheckedUpdateWithoutCalendarConnectionInput
    >;
  };

  export type MeetingUpdateManyWithWhereWithoutCalendarConnectionInput = {
    where: MeetingScalarWhereInput;
    data: XOR<
      MeetingUpdateManyMutationInput,
      MeetingUncheckedUpdateManyWithoutCalendarConnectionInput
    >;
  };

  export type MeetingCreateManyUserInput = {
    id?: string;
    organizationId?: string | null;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
  };

  export type MinutesTemplateCreateManyUserInput = {
    id?: string;
    organizationId?: string | null;
    name: string;
    description?: string | null;
    format: string;
    sections: JsonNullValueInput | InputJsonValue;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationCreateManyUserInput = {
    id?: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    read?: boolean;
    meetingId?: string | null;
    createdAt?: Date | string;
  };

  export type TagCreateManyUserInput = {
    id?: string;
    organizationId?: string | null;
    name: string;
    color?: string;
    createdAt?: Date | string;
  };

  export type MembershipCreateManyUserInput = {
    id?: string;
    organizationId: string;
    role?: $Enums.MemberRole;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MinutesCreateManyReviewerInput = {
    id?: string;
    meetingId: string;
    content: string;
    status?: $Enums.MinutesStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CalendarConnectionCreateManyUserInput = {
    id?: string;
    provider: $Enums.CalendarProvider;
    accessToken: string;
    refreshToken: string;
    expiresAt: Date | string;
    lastSyncAt?: Date | string | null;
    status?: $Enums.ConnectionStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MeetingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUpdateManyWithoutMeetingNestedInput;
    organization?: OrganizationUpdateOneWithoutMeetingsNestedInput;
    calendarConnection?: CalendarConnectionUpdateOneWithoutMeetingsNestedInput;
    tags?: MeetingTagUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput;
    tags?: MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUncheckedUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUncheckedUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type MinutesTemplateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneWithoutTemplatesNestedInput;
  };

  export type MinutesTemplateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesTemplateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TagUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meetings?: MeetingTagUpdateManyWithoutTagNestedInput;
    organization?: OrganizationUpdateOneWithoutTagsNestedInput;
  };

  export type TagUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meetings?: MeetingTagUncheckedUpdateManyWithoutTagNestedInput;
  };

  export type TagUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput;
  };

  export type MembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meeting?: MeetingUpdateOneRequiredWithoutMinutesNestedInput;
    versions?: MinutesVersionUpdateManyWithoutMinutesNestedInput;
  };

  export type MinutesUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    versions?: MinutesVersionUncheckedUpdateManyWithoutMinutesNestedInput;
  };

  export type MinutesUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    status?: EnumMinutesStatusFieldUpdateOperationsInput | $Enums.MinutesStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CalendarConnectionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?:
      | EnumCalendarProviderFieldUpdateOperationsInput
      | $Enums.CalendarProvider;
    accessToken?: StringFieldUpdateOperationsInput | string;
    refreshToken?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastSyncAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFieldUpdateOperationsInput
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meetings?: MeetingUpdateManyWithoutCalendarConnectionNestedInput;
  };

  export type CalendarConnectionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?:
      | EnumCalendarProviderFieldUpdateOperationsInput
      | $Enums.CalendarProvider;
    accessToken?: StringFieldUpdateOperationsInput | string;
    refreshToken?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastSyncAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFieldUpdateOperationsInput
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meetings?: MeetingUncheckedUpdateManyWithoutCalendarConnectionNestedInput;
  };

  export type CalendarConnectionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?:
      | EnumCalendarProviderFieldUpdateOperationsInput
      | $Enums.CalendarProvider;
    accessToken?: StringFieldUpdateOperationsInput | string;
    refreshToken?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastSyncAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?:
      | EnumConnectionStatusFieldUpdateOperationsInput
      | $Enums.ConnectionStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MembershipCreateManyOrganizationInput = {
    id?: string;
    userId: string;
    role?: $Enums.MemberRole;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MeetingCreateManyOrganizationInput = {
    id?: string;
    userId: string;
    calendarConnectionId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
  };

  export type MinutesTemplateCreateManyOrganizationInput = {
    id?: string;
    userId: string;
    name: string;
    description?: string | null;
    format: string;
    sections: JsonNullValueInput | InputJsonValue;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TagCreateManyOrganizationInput = {
    id?: string;
    userId: string;
    name: string;
    color?: string;
    createdAt?: Date | string;
  };

  export type MembershipUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput;
  };

  export type MembershipUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MembershipUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUpdateManyWithoutMeetingNestedInput;
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput;
    calendarConnection?: CalendarConnectionUpdateOneWithoutMeetingsNestedInput;
    tags?: MeetingTagUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput;
    tags?: MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUncheckedUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUncheckedUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    calendarConnectionId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type MinutesTemplateUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutTemplatesNestedInput;
  };

  export type MinutesTemplateUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesTemplateUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    format?: StringFieldUpdateOperationsInput | string;
    sections?: JsonNullValueInput | InputJsonValue;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TagUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meetings?: MeetingTagUpdateManyWithoutTagNestedInput;
    user?: UserUpdateOneRequiredWithoutTagsNestedInput;
  };

  export type TagUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meetings?: MeetingTagUncheckedUpdateManyWithoutTagNestedInput;
  };

  export type TagUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    color?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubscriptionCreateManyPlanInput = {
    id?: string;
    userId: string;
    active?: boolean;
    startsAt?: Date | string;
    endsAt?: Date | string | null;
  };

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput;
    usage?: WeeklyUsageUpdateManyWithoutSubscriptionNestedInput;
  };

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usage?: WeeklyUsageUncheckedUpdateManyWithoutSubscriptionNestedInput;
  };

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type WeeklyUsageCreateManySubscriptionInput = {
    id?: string;
    weekStartDate: Date | string;
    uploadCount?: number;
    minutesProcessed?: number;
  };

  export type WeeklyUsageUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    uploadCount?: IntFieldUpdateOperationsInput | number;
    minutesProcessed?: IntFieldUpdateOperationsInput | number;
  };

  export type WeeklyUsageUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    uploadCount?: IntFieldUpdateOperationsInput | number;
    minutesProcessed?: IntFieldUpdateOperationsInput | number;
  };

  export type WeeklyUsageUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    uploadCount?: IntFieldUpdateOperationsInput | number;
    minutesProcessed?: IntFieldUpdateOperationsInput | number;
  };

  export type KeyMomentCreateManyMeetingInput = {
    id?: string;
    timestamp: number;
    label: string;
    description?: string | null;
    type?: $Enums.MomentType;
    isAutomatic?: boolean;
    createdBy?: string | null;
    createdAt?: Date | string;
  };

  export type MeetingTagCreateManyMeetingInput = {
    id?: string;
    tagId: string;
    createdAt?: Date | string;
  };

  export type ShareLinkCreateManyMeetingInput = {
    id?: string;
    token: string;
    expiresAt?: Date | string | null;
    shareType?: $Enums.ShareType;
    createdAt?: Date | string;
  };

  export type SpeakerCreateManyMeetingInput = {
    id?: string;
    name: string;
    isUnknown?: boolean;
    isConfirmed?: boolean;
    nameConfidence?: number;
  };

  export type TranscriptSegmentCreateManyMeetingInput = {
    id?: string;
    speakerId?: string | null;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
  };

  export type KeyMomentUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timestamp?: FloatFieldUpdateOperationsInput | number;
    label?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumMomentTypeFieldUpdateOperationsInput | $Enums.MomentType;
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type KeyMomentUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timestamp?: FloatFieldUpdateOperationsInput | number;
    label?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumMomentTypeFieldUpdateOperationsInput | $Enums.MomentType;
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type KeyMomentUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timestamp?: FloatFieldUpdateOperationsInput | number;
    label?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumMomentTypeFieldUpdateOperationsInput | $Enums.MomentType;
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingTagUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tag?: TagUpdateOneRequiredWithoutMeetingsNestedInput;
  };

  export type MeetingTagUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tagId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingTagUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tagId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ShareLinkUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    shareType?: EnumShareTypeFieldUpdateOperationsInput | $Enums.ShareType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ShareLinkUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    shareType?: EnumShareTypeFieldUpdateOperationsInput | $Enums.ShareType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ShareLinkUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    shareType?: EnumShareTypeFieldUpdateOperationsInput | $Enums.ShareType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SpeakerUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isUnknown?: BoolFieldUpdateOperationsInput | boolean;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    nameConfidence?: FloatFieldUpdateOperationsInput | number;
    segments?: TranscriptSegmentUpdateManyWithoutSpeakerNestedInput;
  };

  export type SpeakerUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isUnknown?: BoolFieldUpdateOperationsInput | boolean;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    nameConfidence?: FloatFieldUpdateOperationsInput | number;
    segments?: TranscriptSegmentUncheckedUpdateManyWithoutSpeakerNestedInput;
  };

  export type SpeakerUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isUnknown?: BoolFieldUpdateOperationsInput | boolean;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    nameConfidence?: FloatFieldUpdateOperationsInput | number;
  };

  export type TranscriptSegmentUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    edits?: SegmentEditUpdateManyWithoutSegmentNestedInput;
    corrections?: TranscriptCorrectionUpdateManyWithoutSegmentNestedInput;
    speaker?: SpeakerUpdateOneWithoutSegmentsNestedInput;
  };

  export type TranscriptSegmentUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    edits?: SegmentEditUncheckedUpdateManyWithoutSegmentNestedInput;
    corrections?: TranscriptCorrectionUncheckedUpdateManyWithoutSegmentNestedInput;
  };

  export type TranscriptSegmentUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SegmentEditCreateManySegmentInput = {
    id?: string;
    previousText: string;
    newText: string;
    editedBy: string;
    editReason?: string | null;
    createdAt?: Date | string;
  };

  export type TranscriptCorrectionCreateManySegmentInput = {
    id?: string;
    originalText: string;
    correctedText: string;
    correctedBy: string;
    createdAt?: Date | string;
  };

  export type SegmentEditUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousText?: StringFieldUpdateOperationsInput | string;
    newText?: StringFieldUpdateOperationsInput | string;
    editedBy?: StringFieldUpdateOperationsInput | string;
    editReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SegmentEditUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousText?: StringFieldUpdateOperationsInput | string;
    newText?: StringFieldUpdateOperationsInput | string;
    editedBy?: StringFieldUpdateOperationsInput | string;
    editReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SegmentEditUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousText?: StringFieldUpdateOperationsInput | string;
    newText?: StringFieldUpdateOperationsInput | string;
    editedBy?: StringFieldUpdateOperationsInput | string;
    editReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TranscriptCorrectionUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    originalText?: StringFieldUpdateOperationsInput | string;
    correctedText?: StringFieldUpdateOperationsInput | string;
    correctedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TranscriptCorrectionUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    originalText?: StringFieldUpdateOperationsInput | string;
    correctedText?: StringFieldUpdateOperationsInput | string;
    correctedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TranscriptCorrectionUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    originalText?: StringFieldUpdateOperationsInput | string;
    correctedText?: StringFieldUpdateOperationsInput | string;
    correctedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TranscriptSegmentCreateManySpeakerInput = {
    id?: string;
    meetingId: string;
    startTime: number;
    endTime: number;
    text: string;
    languagesUsed?: TranscriptSegmentCreatelanguagesUsedInput | string[];
    originalText?: string | null;
  };

  export type TranscriptSegmentUpdateWithoutSpeakerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    edits?: SegmentEditUpdateManyWithoutSegmentNestedInput;
    corrections?: TranscriptCorrectionUpdateManyWithoutSegmentNestedInput;
    meeting?: MeetingUpdateOneRequiredWithoutTranscriptNestedInput;
  };

  export type TranscriptSegmentUncheckedUpdateWithoutSpeakerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
    edits?: SegmentEditUncheckedUpdateManyWithoutSegmentNestedInput;
    corrections?: TranscriptCorrectionUncheckedUpdateManyWithoutSegmentNestedInput;
  };

  export type TranscriptSegmentUncheckedUpdateManyWithoutSpeakerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    startTime?: FloatFieldUpdateOperationsInput | number;
    endTime?: FloatFieldUpdateOperationsInput | number;
    text?: StringFieldUpdateOperationsInput | string;
    languagesUsed?: TranscriptSegmentUpdatelanguagesUsedInput | string[];
    originalText?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type MinutesVersionCreateManyMinutesInput = {
    id?: string;
    content: string;
    version: number;
    createdAt?: Date | string;
  };

  export type MinutesVersionUpdateWithoutMinutesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    version?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesVersionUncheckedUpdateWithoutMinutesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    version?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MinutesVersionUncheckedUpdateManyWithoutMinutesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    version?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingTagCreateManyTagInput = {
    id?: string;
    meetingId: string;
    createdAt?: Date | string;
  };

  export type MeetingTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    meeting?: MeetingUpdateOneRequiredWithoutTagsNestedInput;
  };

  export type MeetingTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string;
    meetingId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MeetingCreateManyCalendarConnectionInput = {
    id?: string;
    userId: string;
    organizationId?: string | null;
    title: string;
    originalFileName: string;
    durationSeconds?: number;
    fileUrl?: string | null;
    status?: $Enums.MeetingStatus;
    languageCode?: string | null;
    transcriptLang?: string | null;
    minutesLang?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    avgSpeakerConfidence?: number | null;
    inaudibleCount?: number;
    qualityScore?: number | null;
    lastProcessedAt?: Date | string | null;
  };

  export type MeetingUpdateWithoutCalendarConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUpdateManyWithoutMeetingNestedInput;
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput;
    organization?: OrganizationUpdateOneWithoutMeetingsNestedInput;
    tags?: MeetingTagUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateWithoutCalendarConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    keyMoments?: KeyMomentUncheckedUpdateManyWithoutMeetingNestedInput;
    tags?: MeetingTagUncheckedUpdateManyWithoutMeetingNestedInput;
    minutes?: MinutesUncheckedUpdateOneWithoutMeetingNestedInput;
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutMeetingNestedInput;
    speakers?: SpeakerUncheckedUpdateManyWithoutMeetingNestedInput;
    transcript?: TranscriptSegmentUncheckedUpdateManyWithoutMeetingNestedInput;
  };

  export type MeetingUncheckedUpdateManyWithoutCalendarConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    originalFileName?: StringFieldUpdateOperationsInput | string;
    durationSeconds?: IntFieldUpdateOperationsInput | number;
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus;
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null;
    transcriptLang?: NullableStringFieldUpdateOperationsInput | string | null;
    minutesLang?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    avgSpeakerConfidence?:
      | NullableFloatFieldUpdateOperationsInput
      | number
      | null;
    inaudibleCount?: IntFieldUpdateOperationsInput | number;
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null;
    lastProcessedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
